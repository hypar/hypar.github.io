<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>HyPar: doc/Numerical_Method.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>doc/Numerical_Method.md</h1><a href="a00033.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 Numerical <a class="code" href="a00033.html#a1610bc0f5a3c1062419d67e161327d37">Method</a>
<a name="l00002"></a><a class="code" href="a00033.html#a1610bc0f5a3c1062419d67e161327d37">00002</a> ================
<a name="l00003"></a>00003 
<a name="l00004"></a>00004 <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> solves the following partial differential <a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a> (PDE) using a conservative finite-difference
<a name="l00005"></a>00005 algorithm on a Cartesian grid.
<a name="l00006"></a>00006 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00007"></a>00007   \frac {\partial {\bf u}} {\partial <a class="code" href="a00031.html#ac71d8a4e2847ef13524ec70ed9f5d7d4">t</a>} = {\bf F}_{\rm hyp}\left({\bf u}\right) + {\bf F}_{\rm par}\left({\bf u}\right) + {\bf F}_{\rm sou}\left({\bf u}\right)
<a name="l00008"></a>00008 \f}
<a name="l00009"></a>00009 where \f${\bf F}_{\rm hyp}\f$ is the hyperbolic term, \f${\bf F}_{\rm par}\f$ is the parabolic term, and 
<a name="l00010"></a>00010 \f${\bf F}_{\rm sou}\f$ is the source term. Each of these is discretized in space as described below (in
<a name="l00011"></a>00011 the section <span class="stringliteral">&quot;Spatial Discretization&quot;</span>), to 
<a name="l00012"></a><a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">00012</a> obtain the following semi-discrete ordinary differential <a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a> (ODE) in time:
<a name="l00013"></a>00013 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00014"></a>00014   \frac {d {\bf u}} {d <a class="code" href="a00031.html#ac71d8a4e2847ef13524ec70ed9f5d7d4">t</a>} = \hat{\bf F}_{\rm hyp}\left({\bf u}\right) + \hat{\bf F}_{\rm par}\left({\bf u}\right) + \hat{\bf F}_{\rm sou}\left({\bf u}\right)
<a name="l00015"></a>00015 \f}
<a name="l00016"></a>00016 where \f$\hat{\left(\cdot\right)}\f$ represents the spatially discretized <a class="code" href="a00064.html#a0bc2e5eea004e13e7e0d14dc8493fa5f">terms</a>. The governing PDE can be
<a name="l00017"></a>00017 of any space dimension. 
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 \section spatial_discretization Spatial Discretization
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 Hyperbolic term
<a name="l00022"></a>00022 ---------------
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 The hyperbolic term is of the following <a class="code" href="a00033.html#a042d8b42c654aa8b8ff712c1033963aa">form</a>:
<a name="l00025"></a>00025 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00026"></a>00026   {\bf F}_{\rm hyp}\left({\bf u}\right) = -\sum_{d=0}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1} \frac{\partial {\bf f}_d\left({\bf u}\right)}{\partial x_d}
<a name="l00027"></a>00027 \f}
<a name="l00028"></a>00028 and is discretized as:
<a name="l00029"></a>00029 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00030"></a>00030   {\bf F}_{\rm hyp}\left({\bf u}\right) \approx - \sum_{d=0}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1} \frac{1}{\Delta x_d} \left[ \hat{\bf f}_{d,j+1/2} - \hat{\bf f}_{d,j-1/2} \right]
<a name="l00031"></a>00031 \f}
<a name="l00032"></a><a class="code" href="a00033.html#adcc0e6de361772764b238180e552533e">00032</a> where \f$d\f$ is the spatial dimension, \f$D\f$ is the total number of spatial <a class="code" href="a00033.html#adcc0e6de361772764b238180e552533e">dimensions</a>, \f$j\f$ denotes the grid <a class="code" href="a00031.html#a3c3f941ca00d3a46c402ac279bc0b44e">index</a> along \f$d\f$. This
<a name="l00033"></a><a class="code" href="a00033.html#a93e7db794730c0755fe02ab1ffe7715c">00033</a> is implemented in <a class="code" href="a00033.html#a93e7db794730c0755fe02ab1ffe7715c">HyperbolicFunction</a>().
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 The numerical approximation \f$\hat{\bf f}_{d,j+1/2}\f$ of the primitive of the <a class="code" href="a00064.html#ae94fb13b2c09c2f8b5cdbb2fbe99cad7">flux</a> \f${\bf f}_d\left({\bf u}\right)\f$ at the grid interfaces \f$j+1/2\f$ is expressed
<a name="l00036"></a>00036 as
<a name="l00037"></a>00037 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00038"></a>00038   \hat{\bf f}_{d,j+1/2} = \mathcal{U}\left(\hat{\bf f}^L_{d,j+1/2},\hat{\bf f}^R_{d,j+1/2},\hat{\bf u}^L_{d,j+1/2},\hat{\bf u}^R_{d,j+1/2}\right)
<a name="l00039"></a>00039 \f}
<a name="l00040"></a>00040 where \f$\mathcal{U}\f$ is an upwinding function. #<a class="code" href="a00015.html#a7eb68b9643feb74bd49f3a171b66eef1">HyPar::Upwind</a> points to the physical <a class="code" href="a00033.html#ac4336de6d1835c2fc39662f53e2f6e2e">model</a>-specific upwinding function that implements
<a name="l00041"></a><a class="code" href="a00033.html#ac4336de6d1835c2fc39662f53e2f6e2e">00041</a> \f$\mathcal{U}\f$, and is <span class="keyword">set</span> <a class="code" href="a00032.html#a124150da8eed3d9f42e9361cc143ed7e">by</a> the initialization function of a specific physical <a class="code" href="a00033.html#ac4336de6d1835c2fc39662f53e2f6e2e">model</a> (<span class="keywordflow">for</span> <a class="code" href="a00032.html#aff6369b7fb5859bb002145c1c010f831">example</a> <a class="code" href="a00032.html#a96d0f06dcec440c0f9d1b9d1d74127d5">Euler1DInitialize</a>()). The physical <a class="code" href="a00033.html#ac4336de6d1835c2fc39662f53e2f6e2e">model</a>
<a name="l00042"></a>00042 is <a class="code" href="a00032.html#aa18752ebe19b49b626048c92d4586801">specified</a> <a class="code" href="a00032.html#a124150da8eed3d9f42e9361cc143ed7e">by</a> setting #<a class="code" href="a00015.html#ad3fe4b266b398f3a7567ac1b241d99a2">HyPar::model</a> (read from \a <span class="stringliteral">&quot;solver.inp&quot;</span> in <a class="code" href="a00039.html#a1eaea8a114ef1dad09df700d03e735e9">ReadInputs</a>()).
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 \f$\hat{\bf f}^{L,R}_{d,j+1/2}\f$ are the left- and right-biased numerically interpolated values of the primitive of the <a class="code" href="a00064.html#ae94fb13b2c09c2f8b5cdbb2fbe99cad7">flux</a> \f${\bf f}_d\left({\bf u}\right)\f$
<a name="l00045"></a>00045 at the grid interfaces and are computed <span class="keyword">using</span> #<a class="code" href="a00015.html#a17e1cfc7de4fe33c6ee88f2cc42883e7">HyPar::InterpolateInterfacesHyp</a>. They are initialized in <a class="code" href="a00039.html#a8166bb7cded409b3baa135d99fd6bc7c">InitializeSolvers</a>() based on the <a class="code" href="a00032.html#aadd5786eddf29a076126f4201bb7c244">value</a> of 
<a name="l00046"></a>00046 <span class="preprocessor">#HyPar::spatial_scheme_hyp (read from \a &quot;solver.inp&quot; in ReadInputs()). See interpolation.h for all the spatial discretization schemes implemented.</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span>
<a name="l00048"></a>00048 <span class="preprocessor">#HyPar::HyperbolicFunction points to HyperbolicFunction().</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>
<a name="l00050"></a>00050 Parabolic term
<a name="l00051"></a>00051 --------------
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 The parabolic term can take two different forms as described below:-
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="a00033.html#a01b034bd2577d902357ab456b3eb49ab">00055</a> \b No \b cross-derivatives: In <span class="keyword">this</span> <a class="code" href="a00033.html#a042d8b42c654aa8b8ff712c1033963aa">form</a>, the parabolic term is of the following form:
<a name="l00056"></a>00056 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00057"></a>00057   {\bf F}_{\rm par}\left({\bf u}\right) = \sum_{d=0}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1} \frac {\partial^2 {\bf g}_d\left({\bf u}\right)} {\partial x_d^2}
<a name="l00058"></a>00058 \f}
<a name="l00059"></a>00059 where \f$d\f$ is the spatial dimension, and \f$D\f$ is the total number of spatial dimensions. If the parabolic function is 
<a name="l00060"></a>00060 in <span class="keyword">this</span> form, then the physical <a class="code" href="a00033.html#ac4336de6d1835c2fc39662f53e2f6e2e">model</a> must specify #<a class="code" href="a00015.html#ad8f03ca8c9fd6e1e235203495e8f2173">HyPar::GFunction</a> which must point to the function that computes 
<a name="l00061"></a>00061 \f${\bf g}_d\left({\bf u}\right)\f$. In <span class="keyword">this</span> <span class="keywordflow">case</span>, the spatial <a class="code" href="a00033.html#a006f5ed6c12ae3d4f8e840cb181a05ca">discretization</a> is carried out in one of two <a class="code" href="a00033.html#a01b034bd2577d902357ab456b3eb49ab">ways</a>:-
<a name="l00062"></a>00062 
<a name="l00063"></a><a class="code" href="a00033.html#a62d59663e168051efcb7306776473ecb">00063</a> + Conservative <a class="code" href="a00033.html#a006f5ed6c12ae3d4f8e840cb181a05ca">discretization</a>, implemented in <a class="code" href="a00033.html#a62d59663e168051efcb7306776473ecb">ParabolicFunctionCons1Stage</a>() and invoked <a class="code" href="a00032.html#a124150da8eed3d9f42e9361cc143ed7e">by</a> setting #<a class="code" href="a00015.html#ad45d57b33d578bf602574a221bf53d93">HyPar::spatial_type_par</a> 
<a name="l00064"></a>00064   to #<a class="code" href="a00039.html#aabd653aa5d489ae2d0d8140290f6f026">_CONS_1STAGE_</a>: The parabolic term is discretized as
<a name="l00065"></a>00065 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00066"></a>00066   {\bf F}_{\rm par}\left({\bf u}\right) \approx \sum_{d=0}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1} \frac {1}{\Delta x_d^2} \left[ \hat{\bf g}_{d,j+1/2} - \hat{\bf g}_{d,j-1/2} \right]
<a name="l00067"></a>00067 \f}
<a name="l00068"></a>00068   where \f$j\f$ denotes the grid <a class="code" href="a00031.html#a3c3f941ca00d3a46c402ac279bc0b44e">index</a> along \f$d\f$. \f$\hat{\bf g}_{d,j+1/2}\f$ is the numerical approximation to the second primitive
<a name="l00069"></a>00069   of \f${\bf g}_d\left({\bf u}\right)\f$ and is computed <span class="keyword">using</span> #<a class="code" href="a00015.html#a13a0f9420009a55a3689f407a2c8efea">HyPar::InterpolateInterfacesPar</a>.
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="a00033.html#ac018abe1663638bf7fb3c955728fb9d1">00071</a> + Non-conservative, 1-Stage discretization, implemented in <a class="code" href="a00033.html#ac018abe1663638bf7fb3c955728fb9d1">ParabolicFunctionNC1Stage</a>() and invoked <a class="code" href="a00032.html#a124150da8eed3d9f42e9361cc143ed7e">by</a> setting #<a class="code" href="a00015.html#ad45d57b33d578bf602574a221bf53d93">HyPar::spatial_type_par</a>
<a name="l00072"></a>00072   to #<a class="code" href="a00039.html#a18ee8cd9b4297a259b08aa4cdfe30aa1">_NC_1STAGE_</a>: The parabolic term is discretized as
<a name="l00073"></a>00073 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00074"></a>00074   {\bf F}_{\rm par}\left({\bf u}\right) \approx \sum_{d=0}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1} \frac {1}{\Delta x_d^2} \left[ \mathcal{L}_d\left({\bf g}_d\right) \right]
<a name="l00075"></a>00075 \f}
<a name="l00076"></a>00076   where \f$\mathcal{L}\f$ represents the finite-difference Laplacian <span class="keyword">operator</span>, and is computed <span class="keyword">using</span> #<a class="code" href="a00015.html#a4b350316573a1d93caf01c5f1d43a45f">HyPar::SecondDerivativePar</a>.
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 \b With \b cross-derivatives: In <span class="keyword">this</span> form, the parabolic term is of the following form:
<a name="l00079"></a>00079 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00080"></a>00080   {\bf F}_{\rm par}\left({\bf u}\right) = \sum_{d1=0}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1}\sum_{d2=0}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1} \frac {\partial^2 h_{d1,d2}\left({\bf u}\right)} {\partial x_{d1} \partial x_{d2}}
<a name="l00081"></a>00081 \f}
<a name="l00082"></a>00082 where \f$d1,d2\f$ are spatial dimensions, \f$D\f$ is the total number of spatial dimensions. If the parabolic function is
<a name="l00083"></a>00083 in <span class="keyword">this</span> form, then the physical <a class="code" href="a00033.html#ac4336de6d1835c2fc39662f53e2f6e2e">model</a> must specify #<a class="code" href="a00015.html#a122bcc1ec2e20b3bc69d169580529021">HyPar::HFunction</a> which must point to the function that computes
<a name="l00084"></a>00084 \f${\bf h}_{d1,d2}\left({\bf u}\right)\f$. In <span class="keyword">this</span> <span class="keywordflow">case</span>, the spatial discretization is carried out in one of two <a class="code" href="a00033.html#a01b034bd2577d902357ab456b3eb49ab">ways</a>:-
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 + Non-conservative 2-stage discretization, implemented in <a class="code" href="a00104.html#a9f5c8ed9c587aa71c9f75209222ad67c">ParabolicFunctionNC2Stage</a>() and invoked <a class="code" href="a00032.html#a124150da8eed3d9f42e9361cc143ed7e">by</a> setting <span class="preprocessor">#HyPar::spatial_type_par</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>  to #<a class="code" href="a00039.html#a9f4de86b900c9aa5f097c2746e17612a">_NC_2STAGE_</a>: The parabolic term is discretized as
<a name="l00088"></a>00088 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00089"></a>00089   {\bf F}_{\rm par}\left({\bf u}\right) \approx \sum_{d1=0}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1}\sum_{d2=0}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1} \frac {1}{\Delta x_{d1} \Delta x_{d2}} \left[ \mathcal{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>}_{d1}\left(\mathcal{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>}_{d2}\left({\bf g}_d\right)\right) \right]
<a name="l00090"></a>00090 \f}
<a name="l00091"></a>00091   where \f$\mathcal{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>}_d\f$ denotes the finite-difference first derivative <span class="keyword">operator</span> along spatial dimension \f$d\f$, and is computed <span class="keyword">using</span> #<a class="code" href="a00015.html#add4554e1a8a541607b867db7ec38d7a9">HyPar::FirstDerivativePar</a>.
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 + Non-conservative, <span class="stringliteral">&quot;1.5-Stage&quot;</span> discretization, implemented in <a class="code" href="a00104.html#aedd832fdf4002f675da44a840e132456">ParabolicFunctionNC1_5Stage</a>() and invoked <a class="code" href="a00032.html#a124150da8eed3d9f42e9361cc143ed7e">by</a> setting <span class="preprocessor">#HyPar::spatial_type_par</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>  to #<a class="code" href="a00039.html#a7bc6f9c42df5610bc5d844ad95c74fb8">_NC_1_5STAGE_</a>: The parabolic term is discretized as
<a name="l00095"></a>00095 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00096"></a>00096   {\bf F}_{\rm par}\left({\bf u}\right) \approx \sum_{d1=0}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1}\sum_{d2=0,d2 \ne d1}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1} \frac {1}{\Delta x_{d1} \Delta x_{d2}} \left[ \mathcal{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>}_{d1}\left(\mathcal{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>}_{d2}\left({\bf g}_d\right)\right) \right]
<a name="l00097"></a>00097                   + \sum_{d=0}^{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>-1} \frac {1}{\Delta x_d^2} \left[ \mathcal{L}_d\left({\bf g}_d\right) \right]
<a name="l00098"></a>00098 \f}
<a name="l00099"></a>00099   where \f$\mathcal{<a class="code" href="a00031.html#add034d002483743ecf892648b0a4b6cc">D</a>}_d\f$ denotes the finite-difference first derivative operator along spatial dimension \f$d\f$ (computed <span class="keyword">using</span> #<a class="code" href="a00015.html#add4554e1a8a541607b867db7ec38d7a9">HyPar::FirstDerivativePar</a>).
<a name="l00100"></a>00100   and \f$\mathcal{L}\f$ represents the finite-difference Laplacian operator (computed <span class="keyword">using</span> #<a class="code" href="a00015.html#a4b350316573a1d93caf01c5f1d43a45f">HyPar::SecondDerivativePar</a>).
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 The function pointers #<a class="code" href="a00015.html#a13a0f9420009a55a3689f407a2c8efea">HyPar::InterpolateInterfacesPar</a>, #<a class="code" href="a00015.html#a4b350316573a1d93caf01c5f1d43a45f">HyPar::SecondDerivativePar</a>, and #<a class="code" href="a00015.html#add4554e1a8a541607b867db7ec38d7a9">HyPar::FirstDerivativePar</a> are <span class="keyword">set</span> in <a class="code" href="a00039.html#a8166bb7cded409b3baa135d99fd6bc7c">InitializeSolvers</a>() based on the <a class="code" href="a00032.html#aadd5786eddf29a076126f4201bb7c244">value</a> of 
<a name="l00103"></a>00103 <span class="preprocessor">#HyPar::spatial_scheme_par (read from \a &quot;solver.inp&quot; in ReadInputs()). See interpolation.h, firstderivative.h, and secondderivative.h for the spatial</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span>disretization methods implemented.
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 Depending on which of the above forms are <a class="code" href="a00032.html#aa2f9253c1a63124e53d64db71f7e7c16">used</a>, #<a class="code" href="a00015.html#a75e8be4ea8c1ae2e99fc1e802e69a573">HyPar::ParabolicFunction</a> points to either of <a class="code" href="a00033.html#a62d59663e168051efcb7306776473ecb">ParabolicFunctionCons1Stage</a>(), <a class="code" href="a00033.html#ac018abe1663638bf7fb3c955728fb9d1">ParabolicFunctionNC1Stage</a>(),
<a name="l00107"></a>00107 <a class="code" href="a00104.html#a9f5c8ed9c587aa71c9f75209222ad67c">ParabolicFunctionNC2Stage</a>(), or <a class="code" href="a00104.html#aedd832fdf4002f675da44a840e132456">ParabolicFunctionNC1_5Stage</a>() (<span class="keyword">set</span> in <a class="code" href="a00039.html#a8166bb7cded409b3baa135d99fd6bc7c">InitializeSolvers</a>()).
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 Source term
<a name="l00110"></a>00110 -----------
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 #<a class="code" href="a00015.html#a662e256e081a2b74f971d02c747892b8">HyPar::SourceFunction</a> points to <a class="code" href="a00104.html#a6f2b6bacb5d50cb9fce6e3e00d55cc6d">SourceFunction</a>(). There is no discretization involved in general, and <span class="keyword">this</span> function
<a name="l00113"></a>00113 just calls the physical <a class="code" href="a00033.html#ac4336de6d1835c2fc39662f53e2f6e2e">model</a>-specific source function to which #<a class="code" href="a00015.html#a1685cd0c6b8c413bdbbe86d8f4475c58">HyPar::SFunction</a> points.
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 \section time_integration Time Integration
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 Native Time Integrators
<a name="l00119"></a>00119 -----------------------
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 The semi-discrete ODE is integrated in time <span class="keyword">using</span> <span class="keyword">explicit</span> multi-stage time integration methods. The ODE can be written as:
<a name="l00122"></a>00122 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00123"></a>00123   \frac {d {\bf u}} {d <a class="code" href="a00031.html#ac71d8a4e2847ef13524ec70ed9f5d7d4">t</a>} = {\bf F}\left({\bf u}\right)
<a name="l00124"></a>00124 \f}
<a name="l00125"></a>00125 where
<a name="l00126"></a>00126 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00127"></a>00127   {\bf F}\left({\bf u}\right) = \hat{\bf F}_{\rm hyp}\left({\bf u}\right) + \hat{\bf F}_{\rm par}\left({\bf u}\right) + \hat{\bf F}_{\rm sou}\left({\bf u}\right)
<a name="l00128"></a>00128 \f}
<a name="l00129"></a>00129 The following <span class="keyword">explicit</span> time integration methods are implemented in <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> (see timeintegration.h):
<a name="l00130"></a>00130 + Forward Euler - <a class="code" href="a00061.html#a5fe3d9828c6afcbc00cf6fdd940ebe4b">TimeForwardEuler</a>(), #<a class="code" href="a00061.html#af9b1e641532cff8859c5c5a8377f5feb">_FORWARD_EULER_</a>
<a name="l00131"></a>00131 + Explicit Runge-Kutta - <a class="code" href="a00061.html#aca6ebec6e6998f0c509bb38fa91f3321">TimeRK</a>(), #<a class="code" href="a00061.html#a50d4bf1e7e4825cc062fca99a770e5ce">_RK_</a>
<a name="l00132"></a>00132 + Explicit General Linear Methods with Global Error Estimation - <a class="code" href="a00061.html#a7b76988ab950d39d505042dc1f09b875">TimeGLMGEE</a>(), #<a class="code" href="a00061.html#aad9619c099daeb3e6b1b7ef9e03e38d8">_GLM_GEE_</a>
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 \sa <a class="code" href="a00039.html#a5242c7db89f8888de5d72251e5da91c2">Solve</a>()
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <a class="code" href="a00032.html#a74efd4099e297716dbf2fa701e90b65e">PETSc</a> Time Integrators
<a name="l00138"></a>00138 ----------------------
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 If compiled with <a class="code" href="a00032.html#a74efd4099e297716dbf2fa701e90b65e">PETSc</a> (https:<span class="comment">//www.mcs.anl.gov/petsc/), HyPar can use all the time integration methods and features implemented in the \b TS module of</span>
<a name="l00141"></a>00141 <a class="code" href="a00032.html#a74efd4099e297716dbf2fa701e90b65e">PETSc</a>. See the following for relevant documentation of <a class="code" href="a00032.html#a74efd4099e297716dbf2fa701e90b65e">PETSc</a> time integrators:
<a name="l00142"></a>00142 + http:<span class="comment">//www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/index.html</span>
<a name="l00143"></a>00143 + http:<span class="comment">//www.mcs.anl.gov/petsc/petsc-current/src/ts/examples/tutorials/index.html</span>
<a name="l00144"></a>00144 + http:<span class="comment">//www.mcs.anl.gov/petsc/petsc-current/docs/manual.pdf (Chapter 6: Scalable ODE and DAE Solvers)</span>
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 In <a class="code" href="a00032.html#acd2d71c0bebc6551f6d5d3c2870a9baa">addition</a> to explicit time integration, the semi-discrete ODE can be solved using 
<a name="l00147"></a>00147 + \b Implicit \b methods (Eg. backward Euler (TSBEULER - http:<span class="comment">//www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/TSBEULER.html),</span>
<a name="l00148"></a>00148 Crank-Nicholson (TSCN - http:<span class="comment">//www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/TSCN.html#TSCN), \f$\theta\f$-method (TSTHETA - http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/TSTHETA.html#TSTHETA), </span>
<a name="l00149"></a>00149 etc.)
<a name="l00150"></a>00150 + &lt;B&gt;Semi-implicit (IMEX) methods&lt;/B&gt; (TSARKIMEX - http:<span class="comment">//www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/TSARKIMEX.html)</span>
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 Implementation: see petscinterface.h and <a class="code" href="a00039.html#a4dc9b9ce6ce776b7901fa2a6c9c9c1cf" title="Integrate in time with PETSc.">SolvePETSc</a>().
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 \b Implicit and \b IMEX time integration: 
<a name="l00155"></a>00155 + The Jacobian-free approach is used to compute the Jacobian of the implicit term (i.<a class="code" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">e</a>., the action of the Jacobian on a vector
<a name="l00156"></a>00156   is approximated using a directional derivative). Use the flag &lt;B&gt;-jfnk_epsilon \&lt;<a class="code" href="a00032.html#aadd5786eddf29a076126f4201bb7c244">value</a>\&gt;&lt;/B&gt; to specify the parameter \f$\epsilon\f$
<a name="l00157"></a>00157   for the directional derivative computation (default: \f$10^{-6}\f$). See <a class="code" href="a00046.html#a4edf057726501be3e8fe54e16fafe07b">PetscJacobianFunctionIMEX_JFNK</a>(), <a class="code" href="a00046.html#a68f5a93a79d56fcb964224f649af4ac9">PetscJacobianFunction_JFNK</a>().
<a name="l00158"></a>00158 + A preconditioner can only be used <span class="keywordflow">for</span> physical models that define the Jacobian (#<a class="code" href="a00015.html#a15eea1647344c503deb1d9f89cead631">HyPar::JFunction</a>) 
<a name="l00159"></a>00159   (<span class="keywordflow">for</span> <a class="code" href="a00032.html#aff6369b7fb5859bb002145c1c010f831">example</a>, <a class="code" href="a00260.html#aa4ded73e5b8c1e32c83b1bfbd495643d">LinearADRJacobian</a>(), <a class="code" href="a00204.html#a7ab3a531ada5d839c915add13cea5ae0">Euler1DJacobian</a>(), <a class="code" href="a00270.html#ac1c2c8071407ef03f9e102617df5eafb">NavierStokes2DJacobian</a>(), <a class="code" href="a00285.html#a263d12debe46a00911f249c191423492">NavierStokes3DJacobian</a>(), etc).
<a name="l00160"></a>00160   The flag &lt;B&gt;-<a class="code" href="a00032.html#ae67ada76676088d6700a562ecef7aa78">with_pc&lt;/B&gt;</a> should be <a class="code" href="a00032.html#aa18752ebe19b49b626048c92d4586801">specified</a> to <a class="code" href="a00063.html#aa62d35257af3497101065692a222b8d8">use</a> a preconditioner.
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 &lt;B&gt;IMEX Time Integration&lt;/B&gt;: For implicit-explicit (IMEX) time integration, the semi-discrete ODE can be written as follows:
<a name="l00163"></a>00163 \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00164"></a>00164   \frac {d {\bf u}} {d <a class="code" href="a00031.html#ac71d8a4e2847ef13524ec70ed9f5d7d4">t</a>} = {\bf F}\left({\bf u}\right) + {\bf G}\left({\bf u}\right)
<a name="l00165"></a>00165 \f}
<a name="l00166"></a>00166 where \f${\bf F}\left({\bf u}\right)\f$ is integrated explicitly in time and \f${\bf G}\left({\bf u}\right)\f$
<a name="l00167"></a>00167 is integrated implicitly in time. The following flags (<a class="code" href="a00032.html#aa18752ebe19b49b626048c92d4586801">specified</a> in the command line or in the &lt;B&gt;.petscrc&lt;/B&gt;
<a name="l00168"></a>00168 file) can be used to specify which of the hyperbolic, parabolic, or source <a class="code" href="a00064.html#a0bc2e5eea004e13e7e0d14dc8493fa5f">terms</a> are treated explicitly, and 
<a name="l00169"></a>00169 which are treated implicitly.
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 Term                                                        |  Explicit             | Implicit
<a name="l00172"></a>00172 ------------------------------------------------------------|-----------------------|---------------------
<a name="l00173"></a>00173 Hyperbolic \f$\hat{\bf F}_{\rm hyp}\left({\bf u}\right)\f$  | -hyperbolic_explicit  | -hyperbolic_implicit
<a name="l00174"></a>00174 Parabolic \f$\hat{\bf F}_{\rm par}\left({\bf u}\right)\f$   | -parabolic_explicit   | -parabolic_implicit
<a name="l00175"></a>00175 Source \f$\hat{\bf F}_{\rm sou}\left({\bf u}\right)\f$      | -source_explicit      | -source_implicit
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 + If contradictory flags are <a class="code" href="a00032.html#aa18752ebe19b49b626048c92d4586801">specified</a>, i.e.,
<a name="l00178"></a>00178 
<a name="l00179"></a>00179         -parabolic_explicit -parabolic_implicit
<a name="l00180"></a>00180 
<a name="l00181"></a>00181   the flag <a class="code" href="a00032.html#aa8a31735113a81ccfa37219e606349cd">specifying</a> implicit treatment takes precedence.
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 + In <a class="code" href="a00032.html#acd2d71c0bebc6551f6d5d3c2870a9baa">addition</a>, <span class="keywordflow">if</span> a partitioning of the hyperbolic <a class="code" href="a00064.html#ae94fb13b2c09c2f8b5cdbb2fbe99cad7">flux</a> is defined and is being used (#<a class="code" href="a00015.html#a5bed0cb9665daad89f4377c4f7609df4">HyPar::SplitHyperbolicFlux</a>),
<a name="l00184"></a>00184   i.e,
<a name="l00185"></a>00185   \f{<a class="code" href="a00033.html#ac3f62e1b06188678336543688cb7709e">equation</a>}{
<a name="l00186"></a>00186     \hat{\bf F}_{\rm hyp}\left({\bf u}\right) = \left[\hat{\bf F}_{\rm hyp}\left({\bf u}\right) - \delta\hat{\bf F}_{\rm hyp}\left({\bf u}\right)\right] + \delta\hat{\bf F}_{\rm hyp}\left({\bf u}\right)
<a name="l00187"></a>00187   \f}
<a name="l00188"></a>00188   the following flags can be used to specify which of these two <a class="code" href="a00064.html#a0bc2e5eea004e13e7e0d14dc8493fa5f">terms</a> are treated explicitly and which are treated implicitly.
<a name="l00189"></a>00189 
<a name="l00190"></a>00190     Term                                                                                                            |  Explicit               | Implicit
<a name="l00191"></a>00191     ----------------------------------------------------------------------------------------------------------------|-------------------------|---------------------
<a name="l00192"></a>00192     \f$\left[\hat{\bf F}_{\rm hyp}\left({\bf u}\right) - \delta\hat{\bf F}_{\rm hyp}\left({\bf u}\right)\right]\f$  | -hyperbolic_f_explicit  | -hyperbolic_f_implicit
<a name="l00193"></a>00193     \f$\delta\hat{\bf F}_{\rm hyp}\left({\bf u}\right)\f$                                                           | -hyperbolic_df_explicit | -hyperbolic_df_implicit
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 
</pre></div></div>
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=10897352; 
var sc_invisible=1; 
var sc_security="83042f57"; 
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
target="_blank"><img class="statcounter"
src="//c.statcounter.com/10897352/0/83042f57/1/"
alt="website statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
