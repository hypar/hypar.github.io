<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>HyPar: src/BoundaryConditions/BCSlipWall.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>src/BoundaryConditions/BCSlipWall.c File Reference</h1>
<p>Slip-wall boundary conditions.  
<a href="#_details">More...</a></p>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="a00036_source.html">basic.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="a00034_source.html">arrayfunctions.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="a00037_source.html">boundaryconditions.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="a00047_source.html">physicalmodels/euler1d.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="a00048_source.html">physicalmodels/euler2d.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="a00055_source.html">physicalmodels/navierstokes3d.h</a>&gt;</code><br/>

<p><a href="a00077_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#abdeb4e91e1441a25130cb2d3a1be09b0">BCSlipWallU</a> (void *b, void *m, int ndims, int nvars, int *size, int ghosts, double *phi, double waqt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html#ab200c2fba9ceeadcb1eac34fda5ddcb7">BCSlipWallDU</a> (void *b, void *m, int ndims, int nvars, int *size, int ghosts, double *phi, double *phi_ref, double waqt)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Slip-wall boundary conditions. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Debojyoti Ghosh </dd></dl>

<p>Definition in file <a class="el" href="a00077_source.html">BCSlipWall.c</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="abdeb4e91e1441a25130cb2d3a1be09b0"></a><!-- doxytag: member="BCSlipWall.c::BCSlipWallU" ref="abdeb4e91e1441a25130cb2d3a1be09b0" args="(void *b, void *m, int ndims, int nvars, int *size, int ghosts, double *phi, double waqt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSlipWallU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Applies the slip-wall boundary condition: This is specific to the two and three dimensional Euler and Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). It is used for simulating inviscid walls or symmetric boundaries. The pressure, density, and tangential velocity at the ghost points are extrapolated from the interior, while the normal velocity at the ghost points is set such that the interpolated value at the boundary face is equal to the specified wall velocity. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00077_source.html#l00022">22</a> of file <a class="el" href="a00077_source.html">BCSlipWall.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00032"></a>00032 {
<a name="l00033"></a>00033   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00036"></a>00036   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038   <span class="keywordflow">if</span> (ndims == 1) {
<a name="l00039"></a>00039 
<a name="l00040"></a>00040     <span class="comment">/* create a fake physics object */</span>
<a name="l00041"></a>00041     <a class="code" href="a00005.html" title="Structure containing variables and parameters specific to the 1D Euler equations...">Euler1D</a> physics; 
<a name="l00042"></a>00042     <span class="keywordtype">double</span> gamma; 
<a name="l00043"></a>00043     gamma = physics.<a class="code" href="a00005.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00044"></a>00044     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00047"></a>00047       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00048"></a>00048       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00049"></a>00049       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00050"></a>00050       <span class="keywordtype">int</span> done = 0;
<a name="l00051"></a>00051       <span class="keywordflow">while</span> (!done) {
<a name="l00052"></a>00052         <span class="keywordtype">int</span> p1, p2;
<a name="l00053"></a>00053         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00054"></a>00054         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00055"></a>00055         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00056"></a>00056         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00057"></a>00057         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00058"></a>00058         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00059"></a>00059         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00060"></a>00060         
<a name="l00061"></a>00061         <span class="comment">/* flow variables in the interior */</span>
<a name="l00062"></a>00062         <span class="keywordtype">double</span> rho, uvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00063"></a>00063         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, energy_gpt, pressure_gpt;
<a name="l00064"></a>00064         <a class="code" href="a00047.html#af35510fb1477577f57c57cc2a862b1e7">_Euler1DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,energy,pressure,(&amp;physics));
<a name="l00065"></a>00065         <span class="comment">/* set the ghost point values */</span>
<a name="l00066"></a>00066         rho_gpt = rho;
<a name="l00067"></a>00067         pressure_gpt = pressure;
<a name="l00068"></a>00068         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00069"></a>00069         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00070"></a>00070                     + 0.5 * rho_gpt * uvel_gpt*uvel_gpt;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072         phi[nvars*p1+0] = rho_gpt;
<a name="l00073"></a>00073         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00074"></a>00074         phi[nvars*p1+2] = energy_gpt;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00077"></a>00077       }
<a name="l00078"></a>00078     }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="comment">/* create a fake physics object */</span>
<a name="l00083"></a>00083     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00084"></a>00084     <span class="keywordtype">double</span> gamma; 
<a name="l00085"></a>00085     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00086"></a>00086     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00089"></a>00089       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00090"></a>00090       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00091"></a>00091       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00092"></a>00092       <span class="keywordtype">int</span> done = 0;
<a name="l00093"></a>00093       <span class="keywordflow">while</span> (!done) {
<a name="l00094"></a>00094         <span class="keywordtype">int</span> p1, p2;
<a name="l00095"></a>00095         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00096"></a>00096         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00097"></a>00097         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00098"></a>00098         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00099"></a>00099         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00100"></a>00100         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00101"></a>00101         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00102"></a>00102         
<a name="l00103"></a>00103         <span class="comment">/* flow variables in the interior */</span>
<a name="l00104"></a>00104         <span class="keywordtype">double</span> rho, uvel, vvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00105"></a>00105         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00106"></a>00106         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00107"></a>00107         <span class="comment">/* set the ghost point values */</span>
<a name="l00108"></a>00108         rho_gpt = rho;
<a name="l00109"></a>00109         pressure_gpt = pressure;
<a name="l00110"></a>00110         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00111"></a>00111           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00112"></a>00112           vvel_gpt = vvel;
<a name="l00113"></a>00113         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00114"></a>00114           uvel_gpt = uvel;
<a name="l00115"></a>00115           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00116"></a>00116         } <span class="keywordflow">else</span> {
<a name="l00117"></a>00117           uvel_gpt = 0.0;
<a name="l00118"></a>00118           vvel_gpt = 0.0;
<a name="l00119"></a>00119         }
<a name="l00120"></a>00120         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00121"></a>00121                     + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00122"></a>00122 
<a name="l00123"></a>00123         phi[nvars*p1+0] = rho_gpt;
<a name="l00124"></a>00124         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00125"></a>00125         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00126"></a>00126         phi[nvars*p1+3] = energy_gpt;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00129"></a>00129       }
<a name="l00130"></a>00130     }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     <span class="comment">/* create a fake physics object */</span>
<a name="l00135"></a>00135     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics; 
<a name="l00136"></a>00136     <span class="keywordtype">double</span> gamma; 
<a name="l00137"></a>00137     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00138"></a>00138     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00141"></a>00141       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00142"></a>00142       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00143"></a>00143       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00144"></a>00144       <span class="keywordtype">int</span> done = 0;
<a name="l00145"></a>00145       <span class="keywordflow">while</span> (!done) {
<a name="l00146"></a>00146         <span class="keywordtype">int</span> p1, p2;
<a name="l00147"></a>00147         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00148"></a>00148         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00149"></a>00149         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00150"></a>00150         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00151"></a>00151         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00152"></a>00152         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00153"></a>00153         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00154"></a>00154         
<a name="l00155"></a>00155         <span class="comment">/* flow variables in the interior */</span>
<a name="l00156"></a>00156         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, pressure;
<a name="l00157"></a>00157         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00158"></a>00158         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00159"></a>00159         <span class="comment">/* set the ghost point values */</span>
<a name="l00160"></a>00160         rho_gpt = rho;
<a name="l00161"></a>00161         pressure_gpt = pressure;
<a name="l00162"></a>00162         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00163"></a>00163           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00164"></a>00164           vvel_gpt = vvel;
<a name="l00165"></a>00165           wvel_gpt = wvel;
<a name="l00166"></a>00166         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00167"></a>00167           uvel_gpt = uvel;
<a name="l00168"></a>00168           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00169"></a>00169           wvel_gpt = wvel;
<a name="l00170"></a>00170         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>) {
<a name="l00171"></a>00171           uvel_gpt = uvel;
<a name="l00172"></a>00172           vvel_gpt = vvel;
<a name="l00173"></a>00173           wvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>] - wvel;
<a name="l00174"></a>00174         } <span class="keywordflow">else</span> {
<a name="l00175"></a>00175           uvel_gpt = 0.0;
<a name="l00176"></a>00176           vvel_gpt = 0.0;
<a name="l00177"></a>00177           wvel_gpt = 0.0;
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00180"></a>00180                     + 0.5 * rho_gpt 
<a name="l00181"></a>00181                     * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183         phi[nvars*p1+0] = rho_gpt;
<a name="l00184"></a>00184         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00185"></a>00185         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00186"></a>00186         phi[nvars*p1+3] = rho_gpt * wvel_gpt;
<a name="l00187"></a>00187         phi[nvars*p1+4] = energy_gpt;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00190"></a>00190       }
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   }
<a name="l00194"></a>00194   <span class="keywordflow">return</span>(0);
<a name="l00195"></a>00195 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab200c2fba9ceeadcb1eac34fda5ddcb7"></a><!-- doxytag: member="BCSlipWall.c::BCSlipWallDU" ref="ab200c2fba9ceeadcb1eac34fda5ddcb7" args="(void *b, void *m, int ndims, int nvars, int *size, int ghosts, double *phi, double *phi_ref, double waqt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSlipWallDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Applies the slip-wall boundary condition to the delta-solution: This is specific to the two and three dimensional Euler and Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). It is used for simulating inviscid walls or symmetric boundaries. The pressure, density, and tangential velocity at the ghost points are extrapolated from the interior, while the normal velocity at the ghost points is set such that the interpolated value at the boundary face is equal to the specified wall velocity. <br/>
<br/>
 The above treatment is applied on the delta-solution added to the reference solution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00077_source.html#l00206">206</a> of file <a class="el" href="a00077_source.html">BCSlipWall.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00214"></a>00214                                                                                      {\bf U}\f$.*/
<a name="l00215"></a>00215                  <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00216"></a>00216                  <span class="keywordtype">double</span>  waqt      
<a name="l00217"></a>00217                 )
<a name="l00218"></a>00218 {
<a name="l00219"></a>00219   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00222"></a>00222   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00223"></a>00223   <span class="keywordtype">int</span> v;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225   <span class="keywordflow">if</span> (ndims == 1) {
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     <span class="comment">/* create a fake physics object */</span>
<a name="l00228"></a>00228     <a class="code" href="a00005.html" title="Structure containing variables and parameters specific to the 1D Euler equations...">Euler1D</a> physics; 
<a name="l00229"></a>00229     <span class="keywordtype">double</span> gamma; 
<a name="l00230"></a>00230     gamma = physics.<a class="code" href="a00005.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00231"></a>00231     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00234"></a>00234       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00235"></a>00235       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00236"></a>00236       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00237"></a>00237       <span class="keywordtype">int</span> done = 0;
<a name="l00238"></a>00238       <span class="keywordflow">while</span> (!done) {
<a name="l00239"></a>00239         <span class="keywordtype">int</span> p1, p2;
<a name="l00240"></a>00240         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00241"></a>00241         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00242"></a>00242         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00243"></a>00243         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00244"></a>00244         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00245"></a>00245         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00246"></a>00246         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00247"></a>00247 
<a name="l00248"></a>00248         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00249"></a>00249         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00250"></a>00250         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00251"></a>00251         
<a name="l00252"></a>00252         <span class="comment">/* flow variables in the interior */</span>
<a name="l00253"></a>00253         <span class="keywordtype">double</span> rho , uvel , energy , <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a> ;
<a name="l00254"></a>00254         <span class="keywordtype">double</span> rho0, uvel0, energy0, pressure0;
<a name="l00255"></a>00255         <a class="code" href="a00047.html#af35510fb1477577f57c57cc2a862b1e7">_Euler1DGetFlowVar_</a>(phi_total,rho,uvel,energy,pressure,(&amp;physics));
<a name="l00256"></a>00256         <a class="code" href="a00047.html#af35510fb1477577f57c57cc2a862b1e7">_Euler1DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,energy0,pressure0,(&amp;physics));
<a name="l00257"></a>00257         <span class="comment">/* set the ghost point values */</span>
<a name="l00258"></a>00258         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, energy_gpt, pressure_gpt;
<a name="l00259"></a>00259         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00260"></a>00260         <span class="comment">/* ghost point values of the total flow variables */</span>
<a name="l00261"></a>00261         rho_gpt = rho;
<a name="l00262"></a>00262         pressure_gpt = pressure;
<a name="l00263"></a>00263         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00264"></a>00264         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00265"></a>00265                     + 0.5 * rho_gpt * uvel_gpt*uvel_gpt;
<a name="l00266"></a>00266         <span class="comment">/* ghost point value of the reference flow variables */</span>
<a name="l00267"></a>00267         rho0_gpt = rho0;
<a name="l00268"></a>00268         pressure0_gpt = pressure0;
<a name="l00269"></a>00269         uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00270"></a>00270         energy0_gpt = inv_gamma_m1*pressure0_gpt 
<a name="l00271"></a>00271                     + 0.5 * rho0_gpt * uvel0_gpt*uvel0_gpt;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273         phi[nvars*p1+0] = rho_gpt             - rho0_gpt;
<a name="l00274"></a>00274         phi[nvars*p1+1] = rho_gpt * uvel_gpt  - rho0_gpt * uvel0_gpt;
<a name="l00275"></a>00275         phi[nvars*p1+2] = energy_gpt          - energy0_gpt;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00278"></a>00278       }
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="comment">/* create a fake physics object */</span>
<a name="l00284"></a>00284     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00285"></a>00285     <span class="keywordtype">double</span> gamma; 
<a name="l00286"></a>00286     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00287"></a>00287     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00290"></a>00290       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00291"></a>00291       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00292"></a>00292       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00293"></a>00293       <span class="keywordtype">int</span> done = 0;
<a name="l00294"></a>00294       <span class="keywordflow">while</span> (!done) {
<a name="l00295"></a>00295         <span class="keywordtype">int</span> p1, p2;
<a name="l00296"></a>00296         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00297"></a>00297         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00298"></a>00298         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00299"></a>00299         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00300"></a>00300         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00301"></a>00301         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00302"></a>00302         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00303"></a>00303 
<a name="l00304"></a>00304         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00305"></a>00305         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00306"></a>00306         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00307"></a>00307         
<a name="l00308"></a>00308         <span class="comment">/* flow variables in the interior */</span>
<a name="l00309"></a>00309         <span class="keywordtype">double</span> rho , uvel , vvel , energy , pressure ;
<a name="l00310"></a>00310         <span class="keywordtype">double</span> rho0, uvel0, vvel0, energy0, pressure0;
<a name="l00311"></a>00311         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>(phi_total,rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00312"></a>00312         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,energy0,pressure0,(&amp;physics));
<a name="l00313"></a>00313         <span class="comment">/* set the ghost point values */</span>
<a name="l00314"></a>00314         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00315"></a>00315         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00316"></a>00316         <span class="comment">/* ghost point values of the total flow variables */</span>
<a name="l00317"></a>00317         rho_gpt = rho;
<a name="l00318"></a>00318         pressure_gpt = pressure;
<a name="l00319"></a>00319         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00320"></a>00320           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00321"></a>00321           vvel_gpt = vvel;
<a name="l00322"></a>00322         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00323"></a>00323           uvel_gpt = uvel;
<a name="l00324"></a>00324           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00325"></a>00325         } <span class="keywordflow">else</span> {
<a name="l00326"></a>00326           uvel_gpt = 0.0;
<a name="l00327"></a>00327           vvel_gpt = 0.0;
<a name="l00328"></a>00328         }
<a name="l00329"></a>00329         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00330"></a>00330                     + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00331"></a>00331         <span class="comment">/* ghost point value of the reference flow variables */</span>
<a name="l00332"></a>00332         rho0_gpt = rho0;
<a name="l00333"></a>00333         pressure0_gpt = pressure0;
<a name="l00334"></a>00334         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00335"></a>00335           uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00336"></a>00336           vvel0_gpt = vvel0;
<a name="l00337"></a>00337         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00338"></a>00338           uvel0_gpt = uvel0;
<a name="l00339"></a>00339           vvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel0;
<a name="l00340"></a>00340         } <span class="keywordflow">else</span> {
<a name="l00341"></a>00341           uvel0_gpt = 0.0;
<a name="l00342"></a>00342           vvel0_gpt = 0.0;
<a name="l00343"></a>00343         }
<a name="l00344"></a>00344         energy0_gpt = inv_gamma_m1*pressure0_gpt 
<a name="l00345"></a>00345                     + 0.5 * rho0_gpt * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         phi[nvars*p1+0] = rho_gpt             - rho0_gpt;
<a name="l00348"></a>00348         phi[nvars*p1+1] = rho_gpt * uvel_gpt  - rho0_gpt * uvel0_gpt;
<a name="l00349"></a>00349         phi[nvars*p1+2] = rho_gpt * vvel_gpt  - rho0_gpt * vvel0_gpt;
<a name="l00350"></a>00350         phi[nvars*p1+3] = energy_gpt          - energy0_gpt;
<a name="l00351"></a>00351 
<a name="l00352"></a>00352         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00353"></a>00353       }
<a name="l00354"></a>00354     }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00357"></a>00357 
<a name="l00358"></a>00358     <span class="comment">/* create a fake physics object */</span>
<a name="l00359"></a>00359     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics; 
<a name="l00360"></a>00360     <span class="keywordtype">double</span> gamma; 
<a name="l00361"></a>00361     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00362"></a>00362     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00365"></a>00365       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00366"></a>00366       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00367"></a>00367       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00368"></a>00368       <span class="keywordtype">int</span> done = 0;
<a name="l00369"></a>00369       <span class="keywordflow">while</span> (!done) {
<a name="l00370"></a>00370         <span class="keywordtype">int</span> p1, p2;
<a name="l00371"></a>00371         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00372"></a>00372         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00373"></a>00373         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00374"></a>00374         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00375"></a>00375         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00376"></a>00376         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00377"></a>00377         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00378"></a>00378         
<a name="l00379"></a>00379         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00380"></a>00380         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00381"></a>00381         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00382"></a>00382         
<a name="l00383"></a>00383         <span class="comment">/* flow variables in the interior */</span>
<a name="l00384"></a>00384         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, pressure;
<a name="l00385"></a>00385         <span class="keywordtype">double</span> rho0, uvel0, vvel0, wvel0, energy0, pressure0;
<a name="l00386"></a>00386         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>(phi_total,rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00387"></a>00387         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,wvel0,energy0,pressure0,(&amp;physics));
<a name="l00388"></a>00388         <span class="comment">/* set the ghost point values */</span>
<a name="l00389"></a>00389         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00390"></a>00390         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, wvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00391"></a>00391         <span class="comment">/* setting the ghost point values for the total flow variables */</span>
<a name="l00392"></a>00392         rho_gpt = rho;
<a name="l00393"></a>00393         pressure_gpt = pressure;
<a name="l00394"></a>00394         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00395"></a>00395           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00396"></a>00396           vvel_gpt = vvel;
<a name="l00397"></a>00397           wvel_gpt = wvel;
<a name="l00398"></a>00398         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00399"></a>00399           uvel_gpt = uvel;
<a name="l00400"></a>00400           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00401"></a>00401           wvel_gpt = wvel;
<a name="l00402"></a>00402         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>) {
<a name="l00403"></a>00403           uvel_gpt = uvel;
<a name="l00404"></a>00404           vvel_gpt = vvel;
<a name="l00405"></a>00405           wvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>] - wvel;
<a name="l00406"></a>00406         } <span class="keywordflow">else</span> {
<a name="l00407"></a>00407           uvel_gpt = 0.0;
<a name="l00408"></a>00408           vvel_gpt = 0.0;
<a name="l00409"></a>00409           wvel_gpt = 0.0;
<a name="l00410"></a>00410         }
<a name="l00411"></a>00411         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00412"></a>00412                     + 0.5 * rho_gpt 
<a name="l00413"></a>00413                     * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00414"></a>00414         <span class="comment">/* setting the ghost point values for the reference flow variables */</span>
<a name="l00415"></a>00415         rho0_gpt = rho0;
<a name="l00416"></a>00416         pressure0_gpt = pressure0;
<a name="l00417"></a>00417         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00418"></a>00418           uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00419"></a>00419           vvel0_gpt = vvel0;
<a name="l00420"></a>00420           wvel0_gpt = wvel0;
<a name="l00421"></a>00421         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00422"></a>00422           uvel0_gpt = uvel0;
<a name="l00423"></a>00423           vvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel0;
<a name="l00424"></a>00424           wvel0_gpt = wvel0;
<a name="l00425"></a>00425         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>) {
<a name="l00426"></a>00426           uvel0_gpt = uvel0;
<a name="l00427"></a>00427           vvel0_gpt = vvel0;
<a name="l00428"></a>00428           wvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>] - wvel0;
<a name="l00429"></a>00429         } <span class="keywordflow">else</span> {
<a name="l00430"></a>00430           uvel0_gpt = 0.0;
<a name="l00431"></a>00431           vvel0_gpt = 0.0;
<a name="l00432"></a>00432           wvel0_gpt = 0.0;
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434         energy0_gpt = inv_gamma_m1*pressure0_gpt 
<a name="l00435"></a>00435                     + 0.5 * rho0_gpt 
<a name="l00436"></a>00436                     * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt + wvel0_gpt*wvel0_gpt);
<a name="l00437"></a>00437 
<a name="l00438"></a>00438         phi[nvars*p1+0] = rho_gpt            - rho0_gpt;
<a name="l00439"></a>00439         phi[nvars*p1+1] = rho_gpt * uvel_gpt - rho0_gpt * uvel0_gpt;
<a name="l00440"></a>00440         phi[nvars*p1+2] = rho_gpt * vvel_gpt - rho0_gpt * vvel0_gpt;
<a name="l00441"></a>00441         phi[nvars*p1+3] = rho_gpt * wvel_gpt - rho0_gpt * wvel0_gpt;
<a name="l00442"></a>00442         phi[nvars*p1+4] = energy_gpt         - energy0_gpt;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00445"></a>00445       }
<a name="l00446"></a>00446     }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   }
<a name="l00449"></a>00449   <span class="keywordflow">return</span>(0);
<a name="l00450"></a>00450 }
</pre></div></p>

</div>
</div>
</div>
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=10897352; 
var sc_invisible=1; 
var sc_security="83042f57"; 
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
target="_blank"><img class="statcounter"
src="//c.statcounter.com/10897352/0/83042f57/1/"
alt="website statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
