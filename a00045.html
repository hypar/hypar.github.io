<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>HyPar: include/mpivars.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>include/mpivars.h File Reference</h1>
<p>MPI related structure and function definitions.  
<a href="#_details">More...</a></p>
<code>#include &lt;mpi.h&gt;</code><br/>

<p><a href="a00045_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">MPIVariables</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure of MPI-related variables.  <a href="a00019.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a45dcb265863a65d862bb16222e7e623c">MPIBroadcast_double</a> (double *, int, int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#acd7957559b9206224c7da3cab4f22b27">MPIBroadcast_integer</a> (int *, int, int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#ad408e5a44e863cca50112d1e2f728597">MPIBroadcast_character</a> (char *, int, int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#ade449de8860c4b1060ca15bf7a80476f">MPICreateCommunicators</a> (int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#af59eb9eb78e6e99df5630429e5383617">MPIFreeCommunicators</a> (int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a87419c70e96bbafe1e63821ba1d2e975">MPICreateIOGroups</a> (void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#ac2f0cce702a9ce439753286ce227c7a2">MPIExchangeBoundaries1D</a> (void *, double *, int, int, int, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a60ace5964c051fa481e6a1e6f1ef75d7">MPIExchangeBoundariesnD</a> (int, int, int *, int, void *, double *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#ac4c9e0736d7419f96307c6e6298d3f45">MPIGatherArray1D</a> (void *, double *, double *, int, int, int, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a4cea2f7d5b8d6fad35c84c59da86631a">MPIGatherArraynD</a> (int, void *, double *, double *, int *, int *, int, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a690395a8c8453cdfb455de275a46be07">MPIPartitionArraynD</a> (int, void *, double *, double *, int *, int *, int, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a77f4e7a03979d9fabce2a536a113ff42">MPIPartitionArray1D</a> (void *, double *, double *, int, int, int, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a5795cc6a69ea39684662afc8c2557272">MPIGetArrayDatanD</a> (double *, double *, int *, int *, int *, int *, int, int, int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a9a3fc32b7d4bea6a1dac44ab21c9202e">MPILocalDomainLimits</a> (int, int, void *, int *, int *, int *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a184fc81a4d6618de22a60c9d8436fc83">MPIMax_integer</a> (int *, int *, int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a42b8065bc8e4830aef4c26e58ab4d38d">MPIMax_long</a> (long *, long *, int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a33aa37e0050ec72dadb8d63851df51ec">MPIMax_double</a> (double *, double *, int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#ac57453b9ebabb57bbadd0521c9151aaf">MPIMin_integer</a> (int *, int *, int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a754822278a5d215ecfafa28f1beed7bf">MPIMin_double</a> (double *, double *, int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#abd61f932b070ee84262d9d98b6dd854f">MPISum_double</a> (double *, double *, int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a25c7df0ff2e4f81a64368ea72894a4f8">MPISum_integer</a> (int *, int *, int, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#af8194ca5a460534fdbe391035a95c69d">MPIPartition1D</a> (int, int, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#a36e2be86c7dc0d9dd088ed2f5842f556">MPIRank1D</a> (int, int *, int *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#afe59a0480bb81cc0d7877ba547b3e28c">MPIRanknD</a> (int, int, int *, int *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#ad9bc49863d543b6251903e9150c46a9c">MPIGetFilename</a> (char *, void *, char *)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>MPI related structure and function definitions. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Debojyoti Ghosh </dd></dl>

<p>Definition in file <a class="el" href="a00045_source.html">mpivars.h</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a45dcb265863a65d862bb16222e7e623c"></a><!-- doxytag: member="mpivars.h::MPIBroadcast_double" ref="a45dcb265863a65d862bb16222e7e623c" args="(double *, int, int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIBroadcast_double </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>comm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Broadcast a double to all ranks</p>
<p>Broadcast an array of type <em>double</em> to all MPI ranks </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>array to broadcast to all ranks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of array to broadcast </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>rank from which to broadcast </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comm</em>&nbsp;</td><td>MPI communicator within which to broadcast </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00160_source.html#l00009">9</a> of file <a class="el" href="a00160_source.html">MPIBroadcast.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00015"></a>00015 {
<a name="l00016"></a>00016 <span class="preprocessor">#ifndef serial</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span>  MPI_Bcast(x,size,MPI_DOUBLE,root,*((MPI_Comm*)comm));
<a name="l00018"></a>00018 <span class="preprocessor">#endif</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00020"></a>00020 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="acd7957559b9206224c7da3cab4f22b27"></a><!-- doxytag: member="mpivars.h::MPIBroadcast_integer" ref="acd7957559b9206224c7da3cab4f22b27" args="(int *, int, int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIBroadcast_integer </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>comm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Broadcast an integer to all ranks</p>
<p>Broadcast an array of type <em>int</em> to all MPI ranks </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>array to broadcast to all ranks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of array to broadcast </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>rank from which to broadcast </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comm</em>&nbsp;</td><td>MPI communicator within which to broadcast </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00160_source.html#l00023">23</a> of file <a class="el" href="a00160_source.html">MPIBroadcast.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00029"></a>00029 {
<a name="l00030"></a>00030 <span class="preprocessor">#ifndef serial</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>  MPI_Bcast(x,size,MPI_INT,root,*((MPI_Comm*)comm));
<a name="l00032"></a>00032 <span class="preprocessor">#endif</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00034"></a>00034 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad408e5a44e863cca50112d1e2f728597"></a><!-- doxytag: member="mpivars.h::MPIBroadcast_character" ref="ad408e5a44e863cca50112d1e2f728597" args="(char *, int, int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIBroadcast_character </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>comm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Broadcast a character to all ranks</p>
<p>Broadcast an array of type <em>char</em> to all MPI ranks </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>array to broadcast to all ranks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of array to broadcast </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>rank from which to broadcast </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comm</em>&nbsp;</td><td>MPI communicator within which to broadcast </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00160_source.html#l00037">37</a> of file <a class="el" href="a00160_source.html">MPIBroadcast.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00043"></a>00043 {
<a name="l00044"></a>00044 <span class="preprocessor">#ifndef serial</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>  MPI_Bcast(x,size,MPI_CHAR,root,*((MPI_Comm*)comm));
<a name="l00046"></a>00046 <span class="preprocessor">#endif</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00048"></a>00048 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ade449de8860c4b1060ca15bf7a80476f"></a><!-- doxytag: member="mpivars.h::MPICreateCommunicators" ref="ade449de8860c4b1060ca15bf7a80476f" args="(int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPICreateCommunicators </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create communicators required for the tridiagonal solver in compact schemes</p>
<p>Create subcommunicators from MPI_WORLD, where each subcommunicator contains MPI ranks along a spatial dimension. Consider a two-dimensional problem, partitioned on 21 MPI ranks as follows: </p>
<div align="center">
<img src="mpi_ranks.png" alt="mpi_ranks.png"/>
</div>
 <p>This function will create 10 subcommunicators with the following ranks: + 0,1,2,3,4,5,6 + 7,8,9,10,11,12,13 + 14,15,16,17,18,19,20 + 0,7,14 + 1,8,15 + 2,9,16 + 3,10,17 + 4,11,18 + 5,12,19 + 6,13,20</p>
<p>These subcommunicators are useful for parallel computations along grid lines. For example, a compact finite-difference scheme solves implicit systems along grid lines in every spatial dimension. Thus, the subcommunicator may be passed on to the parallel systems solver instead of MPI_WORLD. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00161_source.html#l00035">35</a> of file <a class="el" href="a00161_source.html">MPICommunicators.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00039"></a>00039 {
<a name="l00040"></a>00040   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> *mpi = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00041"></a>00041 <span class="preprocessor">#ifdef serial</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>  mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a> = NULL;
<a name="l00043"></a>00043 <span class="preprocessor">#else</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>  <span class="keywordtype">int</span>          i,n,color,key;
<a name="l00045"></a>00045   <span class="keywordtype">int</span>          *ip,*iproc;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047   mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a> = (MPI_Comm*) calloc (ndims, <span class="keyword">sizeof</span>(MPI_Comm));
<a name="l00048"></a>00048   <span class="keywordflow">if</span> (ndims == 1) MPI_Comm_dup(mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>);
<a name="l00049"></a>00049   <span class="keywordflow">else</span> {
<a name="l00050"></a>00050     ip    = (<span class="keywordtype">int</span>*) calloc (ndims-1,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00051"></a>00051     iproc = (<span class="keywordtype">int</span>*) calloc (ndims-1,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00052"></a>00052     <span class="keywordflow">for</span> (n=0; n&lt;ndims; n++) {
<a name="l00053"></a>00053       <span class="keywordtype">int</span> tick=0; 
<a name="l00054"></a>00054       <span class="keywordflow">for</span> (i=0; i&lt;ndims; i++) {
<a name="l00055"></a>00055         <span class="keywordflow">if</span> (i != n) {
<a name="l00056"></a>00056           ip[tick]    = mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[i];
<a name="l00057"></a>00057           iproc[tick] = mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[i];
<a name="l00058"></a>00058           tick++;
<a name="l00059"></a>00059         }
<a name="l00060"></a>00060       }
<a name="l00061"></a>00061       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims-1,iproc,ip,0,color); 
<a name="l00062"></a>00062       key   = mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[n];
<a name="l00063"></a>00063       MPI_Comm_split(mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,color,key,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[n]);
<a name="l00064"></a>00064     }
<a name="l00065"></a>00065     free(ip);
<a name="l00066"></a>00066     free(iproc);
<a name="l00067"></a>00067   }
<a name="l00068"></a>00068 <span class="preprocessor">#endif</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00070"></a>00070 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af59eb9eb78e6e99df5630429e5383617"></a><!-- doxytag: member="mpivars.h::MPIFreeCommunicators" ref="af59eb9eb78e6e99df5630429e5383617" args="(int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIFreeCommunicators </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free/destroy communicators created</p>
<p>Free the subcommunicators created in <a class="el" href="a00045.html#ade449de8860c4b1060ca15bf7a80476f">MPICreateCommunicators()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00161_source.html#l00075">75</a> of file <a class="el" href="a00161_source.html">MPICommunicators.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00079"></a>00079 {
<a name="l00080"></a>00080 <span class="preprocessor">#ifndef serial</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>  <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> *mpi = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00082"></a>00082   <span class="keywordtype">int</span>          n;
<a name="l00083"></a>00083   <span class="keywordflow">for</span> (n=0; n&lt;ndims; n++) MPI_Comm_free(&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[n]);
<a name="l00084"></a>00084   free(mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>);
<a name="l00085"></a>00085   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#a92096d6b87420d0e71b38c6dc5e10b14">IOParticipant</a>) MPI_Comm_free(&amp;mpi-&gt;<a class="code" href="a00019.html#ae297d101be8576bfb36202ebb61085e6">IOWorld</a>);
<a name="l00086"></a>00086 <span class="preprocessor">#endif</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00088"></a>00088 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a87419c70e96bbafe1e63821ba1d2e975"></a><!-- doxytag: member="mpivars.h::MPICreateIOGroups" ref="a87419c70e96bbafe1e63821ba1d2e975" args="(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPICreateIOGroups </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create I/O groups for file reading and writing -- Group leaders gather data from all other ranks in the group and write to file, and read from file and sends the data to the appropriate ranks in the group. Thus, number of ranks participating in file I/O is equal to the number of groups (which is an input), and can be set to the number of I/O nodes available.</p>
<p>Create I/O groups of MPI ranks: A scalable approach to file I/O when running simulations on a large number of processors (&gt;10,000) is partitioning all the MPI ranks into I/O group. Each group has a "leader" that: + Input - reads the local data of each member rank from the file and sends it to that member. + Output - gets the local data of each member rank and writes it to a file.</p>
<p>The number of I/O groups (and hence, the number of I/O ranks reading and writing to files) is specified through <a class="el" href="a00019.html#a297fca986fa3aa27de07a0c746ffaaa8">MPIVariables::N_IORanks</a>. Ideally, this would correspond to the number of I/O nodes available for the total number of compute nodes being used on a HPC platform.</p>
<p>Two extreme cases are: + Number of I/O ranks is 1, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>., just one rank (typically rank 0) is responsible for reading and writing the local data of every rank. + Number of I/O ranks is equal to the total number of MPI ranks, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>., each MPI rank reads and writes from and to its own files.</p>
<p>Neither of the extreme cases are scalable.</p>
<p>Notes: + If the total number of MPI ranks (<a class="el" href="a00019.html#ae68326adc3b3862f1162832f70727b06">MPIVariables::nproc</a>) is not an integer multiple of the specified number of I/O groups (<a class="el" href="a00019.html#a297fca986fa3aa27de07a0c746ffaaa8">MPIVariables::N_IORanks</a>), then only 1 rank is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00168_source.html#l00037">37</a> of file <a class="el" href="a00168_source.html">MPIIOGroups.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00038"></a>00038 {
<a name="l00039"></a>00039   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> *mpi = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#ifndef serial</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043   <span class="keywordtype">int</span> nproc         = mpi-&gt;<a class="code" href="a00019.html#ae68326adc3b3862f1162832f70727b06">nproc</a>;
<a name="l00044"></a>00044   <span class="keywordtype">int</span> rank          = mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>;
<a name="l00045"></a>00045   <span class="keywordtype">int</span> N_IORanks     = mpi-&gt;<a class="code" href="a00019.html#a297fca986fa3aa27de07a0c746ffaaa8">N_IORanks</a>;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047   <span class="keywordtype">int</span> GroupSize;
<a name="l00048"></a>00048   <span class="keywordflow">if</span> (nproc%N_IORanks==0) GroupSize = nproc/N_IORanks;
<a name="l00049"></a>00049   <span class="keywordflow">else</span> {
<a name="l00050"></a>00050     <span class="keywordflow">if</span> (!rank) {
<a name="l00051"></a>00051       printf(<span class="stringliteral">&quot;Note: in MPICreateIOGroups() - Number of &quot;</span>);
<a name="l00052"></a>00052       printf(<span class="stringliteral">&quot;ranks (nproc) is not divisible by number &quot;</span>);
<a name="l00053"></a>00053       printf(<span class="stringliteral">&quot;of IO ranks (N_IORanks). Readjusting number &quot;</span>);
<a name="l00054"></a>00054       printf(<span class="stringliteral">&quot;of IO ranks to fix this.\n&quot;</span>);
<a name="l00055"></a>00055     }
<a name="l00056"></a>00056     N_IORanks = 1;
<a name="l00057"></a>00057     <span class="keywordflow">if</span> (!rank) {
<a name="l00058"></a>00058       printf(<span class="stringliteral">&quot;Number of IO Ranks: %d\n&quot;</span>,N_IORanks);
<a name="l00059"></a>00059     }
<a name="l00060"></a>00060     GroupSize = nproc;
<a name="l00061"></a>00061   }
<a name="l00062"></a>00062 
<a name="l00063"></a>00063   mpi-&gt;<a class="code" href="a00019.html#a1654ada98aca560c6cb1dc79bb6576c3">CommGroup</a>  = rank/GroupSize;
<a name="l00064"></a>00064   mpi-&gt;<a class="code" href="a00019.html#a1e6b9b6dca494aa45e43214f120e6630">IORank</a>     = mpi-&gt;<a class="code" href="a00019.html#a1654ada98aca560c6cb1dc79bb6576c3">CommGroup</a> * GroupSize;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066   <span class="comment">/* set flag for whether this rank does file I/O */</span>
<a name="l00067"></a>00067   <span class="keywordflow">if</span> (rank == mpi-&gt;<a class="code" href="a00019.html#a1e6b9b6dca494aa45e43214f120e6630">IORank</a>)  mpi-&gt;<a class="code" href="a00019.html#a92096d6b87420d0e71b38c6dc5e10b14">IOParticipant</a> = 1;
<a name="l00068"></a>00068   <span class="keywordflow">else</span>                      mpi-&gt;<a class="code" href="a00019.html#a92096d6b87420d0e71b38c6dc5e10b14">IOParticipant</a> = 0;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070   <span class="comment">/* save the first and last process of this group */</span>
<a name="l00071"></a>00071   mpi-&gt;<a class="code" href="a00019.html#aff30abd72b51ad067b03ec6d574973a1">GroupStartRank</a> = mpi-&gt;<a class="code" href="a00019.html#a1e6b9b6dca494aa45e43214f120e6630">IORank</a>;
<a name="l00072"></a>00072   mpi-&gt;<a class="code" href="a00019.html#ada7c6833a6ee759beee80a693cf86072">GroupEndRank</a>   = (mpi-&gt;<a class="code" href="a00019.html#a1654ada98aca560c6cb1dc79bb6576c3">CommGroup</a>+1)*GroupSize;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074   <span class="comment">/* create a new communicator with the IO participants */</span>
<a name="l00075"></a>00075   <span class="keywordtype">int</span> i,*FileIORanks;
<a name="l00076"></a>00076   MPI_Group WorldGroup, IOGroup;
<a name="l00077"></a>00077   FileIORanks = (<span class="keywordtype">int</span>*) calloc (N_IORanks,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00078"></a>00078   <span class="keywordflow">for</span> (i=0; i&lt;N_IORanks; i++) FileIORanks[i] = i*GroupSize;
<a name="l00079"></a>00079   MPI_Comm_group(mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;WorldGroup);
<a name="l00080"></a>00080   MPI_Group_incl(WorldGroup,N_IORanks,FileIORanks,&amp;IOGroup);
<a name="l00081"></a>00081   MPI_Comm_create(mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,IOGroup,&amp;mpi-&gt;<a class="code" href="a00019.html#ae297d101be8576bfb36202ebb61085e6">IOWorld</a>);
<a name="l00082"></a>00082   MPI_Group_free(&amp;IOGroup);
<a name="l00083"></a>00083   MPI_Group_free(&amp;WorldGroup);
<a name="l00084"></a>00084   free(FileIORanks);
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="preprocessor">#endif</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>
<a name="l00088"></a>00088   <span class="keywordflow">return</span>(0);
<a name="l00089"></a>00089 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac2f0cce702a9ce439753286ce227c7a2"></a><!-- doxytag: member="mpivars.h::MPIExchangeBoundaries1D" ref="ac2f0cce702a9ce439753286ce227c7a2" args="(void *, double *, int, int, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIExchangeBoundaries1D </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange boundary (ghost point) values for an essentially 1D array (like grid coordinates)</p>
<p>Exchange the data across MPI ranks and fill in ghost points for a 1D array. In a multidimensional simulation, a 1D array is an array of data along one of the spatial dimensions, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>. its an array storing a variable that varies in only one of the spatial dimension. For example, for a 2D problem on a Cartesian grid (with spatial dimensions x and y), the array of x-coordinates is a 1D array along x, and the array of y-coordinates is a 1D array along y. Thus, the size of the 1D array is equal to the size of the domain along the spatial dimension corresponding to that array.</p>
<p>Consider a two-dimensional problem, partitioned on 21 MPI ranks as follows: </p>
<div align="center">
<img src="mpi_ranks.png" alt="mpi_ranks.png"/>
</div>
  and consider rank 9.</p>
<p>If the argument <em>dir</em> is specified as 0, and thus we are dealing with a 1D array along dimension 0, then + Rank 9 will exchange data with ranks 8 and 10, and fill in its ghost points.</p>
<p>If <em>dir</em> is specified as 1, and thus we are dealing with a 1D array along dimension 1, then + Rank 9 will exchange data with ranks 2 and 16, and fill in its ghost points. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The 1D array for which to exchange data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Size of the array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension corresponding to the 1D array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions in the simulation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00162_source.html#l00032">32</a> of file <a class="el" href="a00162_source.html">MPIExchangeBoundaries1D.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00040"></a>00040 {
<a name="l00041"></a>00041 <span class="preprocessor">#ifndef serial</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>  <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>  *mpi = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00043"></a>00043   <span class="keywordtype">int</span>           i;
<a name="l00044"></a>00044   
<a name="l00045"></a>00045   <span class="keywordtype">int</span> *ip     = mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>;
<a name="l00046"></a>00046   <span class="keywordtype">int</span> *iproc  = mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>;
<a name="l00047"></a>00047   <span class="keywordtype">int</span> non      = 0; <span class="comment">/* number of neighbours */</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049   <span class="keywordtype">int</span> neighbor_rank[2] = {-1,-1};
<a name="l00050"></a>00050   <span class="keywordtype">int</span> nip[ndims];
<a name="l00051"></a>00051 
<a name="l00052"></a>00052   <span class="comment">/* each process has 2 neighbors (except at physical boundaries)       */</span>
<a name="l00053"></a>00053   <span class="comment">/* calculate the rank of these neighbors (-1 -&gt; none)                 */</span>
<a name="l00054"></a>00054   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(ip,nip,ndims);  nip[dir]--;
<a name="l00055"></a>00055   <span class="keywordflow">if</span> (ip[dir] == 0)             neighbor_rank[0] = -1;
<a name="l00056"></a>00056   <span class="keywordflow">else</span>                          neighbor_rank[0] = <a class="code" href="a00045.html#a36e2be86c7dc0d9dd088ed2f5842f556">MPIRank1D</a>(ndims,iproc,nip);
<a name="l00057"></a>00057   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(ip,nip,ndims);  nip[dir]++;
<a name="l00058"></a>00058   <span class="keywordflow">if</span> (ip[dir] == (iproc[dir]-1))neighbor_rank[1] = -1;
<a name="l00059"></a>00059   <span class="keywordflow">else</span>                          neighbor_rank[1] = <a class="code" href="a00045.html#a36e2be86c7dc0d9dd088ed2f5842f556">MPIRank1D</a>(ndims,iproc,nip);
<a name="l00060"></a>00060 
<a name="l00061"></a>00061   <span class="comment">/* Allocate send and receive buffers */</span>
<a name="l00062"></a>00062   <span class="keywordtype">double</span> sendbuf[2][ghosts], recvbuf[2][ghosts];
<a name="l00063"></a>00063 
<a name="l00064"></a>00064   <span class="comment">/* count number of neighbors and copy data to send buffers */</span>
<a name="l00065"></a>00065   non = 0;
<a name="l00066"></a>00066   <span class="keywordflow">if</span> (neighbor_rank[0] != -1) {
<a name="l00067"></a>00067     non++;
<a name="l00068"></a>00068     <span class="keywordflow">for</span> (i = 0; i &lt; ghosts; i++) sendbuf[0][i] = x[i+ghosts];
<a name="l00069"></a>00069   }
<a name="l00070"></a>00070   <span class="keywordflow">if</span> (neighbor_rank[1] != -1) {
<a name="l00071"></a>00071     non++;
<a name="l00072"></a>00072     <span class="keywordflow">for</span> (i = 0; i &lt; ghosts; i++) sendbuf[1][i] = x[i+N];
<a name="l00073"></a>00073   }
<a name="l00074"></a>00074   MPI_Request requests[2*non];
<a name="l00075"></a>00075   MPI_Status  statuses[2*non];
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   <span class="comment">/* exchange the data */</span>
<a name="l00078"></a>00078   <span class="keywordtype">int</span> tick = 0;
<a name="l00079"></a>00079   <span class="keywordflow">if</span> (neighbor_rank[0]!= -1) {
<a name="l00080"></a>00080     MPI_Irecv(recvbuf[0],ghosts,MPI_DOUBLE,neighbor_rank[0],1631,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;requests[tick]);
<a name="l00081"></a>00081     MPI_Isend(sendbuf[0],ghosts,MPI_DOUBLE,neighbor_rank[0],1631,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;requests[tick+non]);
<a name="l00082"></a>00082     tick++;
<a name="l00083"></a>00083   }
<a name="l00084"></a>00084   <span class="keywordflow">if</span> (neighbor_rank[1] != -1) {
<a name="l00085"></a>00085     MPI_Irecv(recvbuf[1],ghosts,MPI_DOUBLE,neighbor_rank[1],1631,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;requests[tick]);
<a name="l00086"></a>00086     MPI_Isend(sendbuf[1],ghosts,MPI_DOUBLE,neighbor_rank[1],1631,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;requests[tick+non]);
<a name="l00087"></a>00087     tick++;
<a name="l00088"></a>00088   }
<a name="l00089"></a>00089 
<a name="l00090"></a>00090   <span class="comment">/* Wait till data transfer is done */</span>
<a name="l00091"></a>00091   MPI_Waitall(2*non,requests,statuses);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   <span class="comment">/* copy received data to ghost points */</span>
<a name="l00094"></a>00094   <span class="keywordflow">if</span> (neighbor_rank[0] != -1) <span class="keywordflow">for</span> (i = 0; i &lt; ghosts; i++) x[i]          = recvbuf[0][i];
<a name="l00095"></a>00095   <span class="keywordflow">if</span> (neighbor_rank[1] != -1) <span class="keywordflow">for</span> (i = 0; i &lt; ghosts; i++) x[i+N+ghosts] = recvbuf[1][i];
<a name="l00096"></a>00096   
<a name="l00097"></a>00097 <span class="preprocessor">#endif</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00099"></a>00099 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a60ace5964c051fa481e6a1e6f1ef75d7"></a><!-- doxytag: member="mpivars.h::MPIExchangeBoundariesnD" ref="a60ace5964c051fa481e6a1e6f1ef75d7" args="(int, int, int *, int, void *, double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIExchangeBoundariesnD </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange boundary (ghost point) values for an n-dimensional array (like the solution array)</p>
<p>Exchange data across MPI ranks, and fill in ghost points for an n-dimensional array (where <em>n</em> is the total number of spatial dimensions). If any of the physical boundaries are periodic, this function also exchanges data and fills in the ghost points for these boundaries.</p>
<p>The n-dimensional array must be stored in the memory as a single-index array, with the following order of mapping: + Number of variables (vector components) + Spatial dimension 0 + Spatial dimension 1 + ... + Spatial dimensions <em>ndims-1</em> </p>
<p>For example, consider a 2D simulation (<em>ndims</em> = 2), of size <img class="formulaInl" alt="$7 \times 3$" src="form_187.png"/>, with <img class="formulaInl" alt="$4$" src="form_188.png"/> vector components (<em>nvars</em> = 4). The following figure shows the layout (without the ghost points): </p>
<div align="center">
<img src="layout.png" alt="layout.png"/>
</div>
 <p>The bold numbers in parentheses represent the 2D indices. The numbers below them are the indices of the array that correspond to that 2D location. Thus, elements 40,41,42, and 43 in the array are the 1st, 2nd, 3rd, and 4th vector components at location (1,3).</p>
<p>If <img class="formulaInl" alt="${\bf i}\left[{\rm ndims}\right]$" src="form_189.png"/> is an integer array representing an n-dimensional index (for example, <img class="formulaInl" alt="$\left(5,4\right)$" src="form_190.png"/> in 2D, <img class="formulaInl" alt="$\left(3,5,2\right)$" src="form_191.png"/> in 3D), and the number of vector components is <em>nvars</em>, then: + <a class="el" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a> computes the index <img class="formulaInl" alt="$p$" src="form_6.png"/> in the array corresponding to <img class="formulaInl" alt="${\bf i}$" src="form_192.png"/>. In the above example, <img class="formulaInl" alt="${\bf i} = \left(1,3\right) \rightarrow p = 10$" src="form_193.png"/>. + <em>var</em>[nvars*p+v] accesses the <em>v-th</em> component of the n-dimensional array <em>var</em> at location <img class="formulaInl" alt="${\bf i}$" src="form_192.png"/>. In the above example, to access the 3rd vector component at location <img class="formulaInl" alt="$\left(1,3\right)$" src="form_194.png"/>, we have <img class="formulaInl" alt="$p=10$" src="form_195.png"/>, so <em>var</em> [4*10+2] = <em>var</em> [42]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables (vector components) at each grid location </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>Integer array whose elements are the local size along each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The array for which to exchange data and fill in ghost points </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00163_source.html#l00042">42</a> of file <a class="el" href="a00163_source.html">MPIExchangeBoundariesnD.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00050"></a>00050 {
<a name="l00051"></a>00051 <span class="preprocessor">#ifndef serial</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span>  <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>  *mpi = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00053"></a>00053   <span class="keywordtype">int</span>           d;
<a name="l00054"></a>00054   
<a name="l00055"></a>00055   <span class="keywordtype">int</span> *ip     = mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>;
<a name="l00056"></a>00056   <span class="keywordtype">int</span> *iproc  = mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>;
<a name="l00057"></a>00057   <span class="keywordtype">int</span> *bcflag = mpi-&gt;<a class="code" href="a00019.html#af40a5a3066fdb53a47e4627071abc2bc">bcperiodic</a>;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   <span class="keywordtype">int</span> neighbor_rank[2*ndims], nip[ndims], <a class="code" href="a00031.html#a3c3f941ca00d3a46c402ac279bc0b44e">index</a>[ndims], bounds[ndims], offset[ndims];
<a name="l00060"></a>00060   MPI_Request rcvreq[2*ndims], sndreq[2*ndims];
<a name="l00061"></a>00061   <span class="keywordflow">for</span> (d=0; d&lt;2*ndims; d++) rcvreq[d] = sndreq[d] = MPI_REQUEST_NULL;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063   <span class="comment">/* each process has 2*ndims neighbors (except at non-periodic physical boundaries)  */</span>
<a name="l00064"></a>00064   <span class="comment">/* calculate the rank of these neighbors (-1 -&gt; none)                               */</span>
<a name="l00065"></a>00065   <span class="keywordflow">for</span> (d = 0; d &lt; ndims; d++) {
<a name="l00066"></a>00066     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(ip,nip,ndims); 
<a name="l00067"></a>00067     <span class="keywordflow">if</span> (ip[d] == 0) nip[d] = iproc[d]-1;
<a name="l00068"></a>00068     <span class="keywordflow">else</span>            nip[d]--;
<a name="l00069"></a>00069     <span class="keywordflow">if</span> ((ip[d] == 0) &amp;&amp; (!bcflag[d])) neighbor_rank[2*d]   = -1;
<a name="l00070"></a>00070     <span class="keywordflow">else</span>                              neighbor_rank[2*d]   = <a class="code" href="a00045.html#a36e2be86c7dc0d9dd088ed2f5842f556">MPIRank1D</a>(ndims,iproc,nip);
<a name="l00071"></a>00071     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(ip,nip,ndims); 
<a name="l00072"></a>00072     <span class="keywordflow">if</span> (ip[d] == (iproc[d]-1)) nip[d] = 0;
<a name="l00073"></a>00073     <span class="keywordflow">else</span>                       nip[d]++;
<a name="l00074"></a>00074     <span class="keywordflow">if</span> ((ip[d] == (iproc[d]-1)) &amp;&amp; (!bcflag[d]))  neighbor_rank[2*d+1] = -1;
<a name="l00075"></a>00075     <span class="keywordflow">else</span>                                          neighbor_rank[2*d+1] = <a class="code" href="a00045.html#a36e2be86c7dc0d9dd088ed2f5842f556">MPIRank1D</a>(ndims,iproc,nip);
<a name="l00076"></a>00076   }
<a name="l00077"></a>00077 
<a name="l00078"></a>00078   <span class="comment">/* calculate dimensions of each of the send-receive regions */</span>
<a name="l00079"></a>00079   <span class="keywordtype">double</span> *sendbuf = mpi-&gt;<a class="code" href="a00019.html#aba3b15034da676474db917f9f5533085">sendbuf</a>;
<a name="l00080"></a>00080   <span class="keywordtype">double</span> *recvbuf = mpi-&gt;<a class="code" href="a00019.html#afc23e46e08649e112e8d64d780cea5cb">recvbuf</a>;
<a name="l00081"></a>00081   <span class="keywordtype">int</span>    stride   = mpi-&gt;<a class="code" href="a00019.html#a4c12bdea025b404c7dd79f368fc03efd">maxbuf</a>;
<a name="l00082"></a>00082   <span class="keywordtype">int</span>    bufdim[ndims];
<a name="l00083"></a>00083   <span class="keywordflow">for</span> (d = 0; d &lt; ndims; d++) {
<a name="l00084"></a>00084     bufdim[d] = 1;
<a name="l00085"></a>00085     <span class="keywordtype">int</span> i;
<a name="l00086"></a>00086     <span class="keywordflow">for</span> (i = 0; i &lt; ndims; i++) {
<a name="l00087"></a>00087       <span class="keywordflow">if</span> (i == d) bufdim[d] *= ghosts;
<a name="l00088"></a>00088       <span class="keywordflow">else</span>        bufdim[d] *= dim[i];
<a name="l00089"></a>00089     }
<a name="l00090"></a>00090   }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092   <span class="comment">/* post the receive requests */</span>
<a name="l00093"></a>00093   <span class="keywordflow">for</span> (d = 0; d &lt; ndims; d++) {
<a name="l00094"></a>00094     <span class="keywordflow">if</span> (neighbor_rank[2*d  ] != -1) {
<a name="l00095"></a>00095       MPI_Irecv(&amp;recvbuf[2*d*stride],bufdim[d]*nvars,MPI_DOUBLE,neighbor_rank[2*d  ],1630,
<a name="l00096"></a>00096                 mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;rcvreq[2*d]);
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098     <span class="keywordflow">if</span> (neighbor_rank[2*d+1] != -1) {
<a name="l00099"></a>00099       MPI_Irecv(&amp;recvbuf[(2*d+1)*stride],bufdim[d]*nvars,MPI_DOUBLE,neighbor_rank[2*d+1],1631,
<a name="l00100"></a>00100                 mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;rcvreq[2*d+1]);
<a name="l00101"></a>00101     }
<a name="l00102"></a>00102   }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="comment">/* count number of neighbors and copy data to send buffers */</span>
<a name="l00105"></a>00105   <span class="keywordflow">for</span> (d = 0; d &lt; ndims; d++) {
<a name="l00106"></a>00106     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds,ndims); bounds[d] = ghosts;
<a name="l00107"></a>00107     <span class="keywordflow">if</span> (neighbor_rank[2*d] != -1) {
<a name="l00108"></a>00108       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(offset,ndims,0);
<a name="l00109"></a>00109       <span class="keywordtype">int</span> done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index,ndims,0);
<a name="l00110"></a>00110       <span class="keywordflow">while</span> (!done) {
<a name="l00111"></a>00111         <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,dim,index,offset,ghosts,p1);
<a name="l00112"></a>00112         <span class="keywordtype">int</span> p2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds,index,0,p2);
<a name="l00113"></a>00113         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((var+nvars*p1),(sendbuf+2*d*stride+nvars*p2),nvars);
<a name="l00114"></a>00114         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,index,done);
<a name="l00115"></a>00115       }
<a name="l00116"></a>00116     }
<a name="l00117"></a>00117     <span class="keywordflow">if</span> (neighbor_rank[2*d+1] != -1) {
<a name="l00118"></a>00118       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(offset,ndims,0);offset[d] = dim[d]-ghosts;
<a name="l00119"></a>00119       <span class="keywordtype">int</span> done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index,ndims,0);
<a name="l00120"></a>00120       <span class="keywordflow">while</span> (!done) {
<a name="l00121"></a>00121         <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,dim,index,offset,ghosts,p1);
<a name="l00122"></a>00122         <span class="keywordtype">int</span> p2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds,index,0,p2);
<a name="l00123"></a>00123         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((var+nvars*p1),(sendbuf+(2*d+1)*stride+nvars*p2),nvars);
<a name="l00124"></a>00124         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,index,done);
<a name="l00125"></a>00125       }
<a name="l00126"></a>00126     }
<a name="l00127"></a>00127   }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129   <span class="comment">/* send the data */</span>
<a name="l00130"></a>00130   <span class="keywordflow">for</span> (d = 0; d &lt; ndims; d++) {
<a name="l00131"></a>00131     <span class="keywordflow">if</span> (neighbor_rank[2*d  ] != -1) {
<a name="l00132"></a>00132       MPI_Isend(&amp;sendbuf[2*d*stride],bufdim[d]*nvars,MPI_DOUBLE,neighbor_rank[2*d  ],1631,
<a name="l00133"></a>00133                 mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;sndreq[2*d]);
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135     <span class="keywordflow">if</span> (neighbor_rank[2*d+1] != -1) {
<a name="l00136"></a>00136       MPI_Isend(&amp;sendbuf[(2*d+1)*stride],bufdim[d]*nvars,MPI_DOUBLE,neighbor_rank[2*d+1],1630,
<a name="l00137"></a>00137                 mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;sndreq[2*d+1]);
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139   }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <span class="comment">/* Wait till data is done received */</span>
<a name="l00142"></a>00142   MPI_Waitall(2*ndims,rcvreq,MPI_STATUS_IGNORE);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="comment">/* copy received data to ghost points */</span>
<a name="l00145"></a>00145   <span class="keywordflow">for</span> (d = 0; d &lt; ndims; d++) {
<a name="l00146"></a>00146     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds,ndims); bounds[d] = ghosts;
<a name="l00147"></a>00147     <span class="keywordflow">if</span> (neighbor_rank[2*d] != -1) {
<a name="l00148"></a>00148       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(offset,ndims,0); offset[d] = -ghosts;
<a name="l00149"></a>00149       <span class="keywordtype">int</span> done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index,ndims,0);
<a name="l00150"></a>00150       <span class="keywordflow">while</span> (!done) {
<a name="l00151"></a>00151         <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,dim,index,offset,ghosts,p1);
<a name="l00152"></a>00152         <span class="keywordtype">int</span> p2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds,index,0,p2);
<a name="l00153"></a>00153         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((recvbuf+2*d*stride+nvars*p2),(var+nvars*p1),nvars);
<a name="l00154"></a>00154         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,index,done);
<a name="l00155"></a>00155       }
<a name="l00156"></a>00156     }
<a name="l00157"></a>00157     <span class="keywordflow">if</span> (neighbor_rank[2*d+1] != -1) {
<a name="l00158"></a>00158       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(offset,ndims,0); offset[d] = dim[d];
<a name="l00159"></a>00159       <span class="keywordtype">int</span> done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index,ndims,0);
<a name="l00160"></a>00160       <span class="keywordflow">while</span> (!done) {
<a name="l00161"></a>00161         <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,dim,index,offset,ghosts,p1);
<a name="l00162"></a>00162         <span class="keywordtype">int</span> p2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds,index,0,p2);
<a name="l00163"></a>00163         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((recvbuf+(2*d+1)*stride+nvars*p2),(var+nvars*p1),nvars);
<a name="l00164"></a>00164         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,index,done);
<a name="l00165"></a>00165       }
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167   }
<a name="l00168"></a>00168   
<a name="l00169"></a>00169   <span class="comment">/* Wait till send requests are complete before freeing memory */</span>
<a name="l00170"></a>00170   MPI_Waitall(2*ndims,sndreq,MPI_STATUS_IGNORE);
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="preprocessor">#endif</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00174"></a>00174 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac4c9e0736d7419f96307c6e6298d3f45"></a><!-- doxytag: member="mpivars.h::MPIGatherArray1D" ref="ac4c9e0736d7419f96307c6e6298d3f45" args="(void *, double *, double *, int, int, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIGatherArray1D </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>xg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>istart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N_local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gather local arrays into a global array for an essentially 1D array</p>
<p>Gathers the contents of a 1D array (partitioned amongst MPI ranks) into a global 1D array on the root rank (rank 0). See documentation of <a class="el" href="a00045.html#ac2f0cce702a9ce439753286ce227c7a2">MPIExchangeBoundaries1D()</a> on what a "1D 
  array" is in the context of a multidimensional simulation. The 1D array must be the same along spatial dimensions normal to the one it represents.</p>
<p>Notes: + The global array must not have ghost points. + The global array must be preallocated on only rank 0. On other ranks, it must be NULL. + Since this function deals with a 1D array, more than one rank may be sending the same piece of data to rank 0 (<a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>. if there are more than one MPI rank along the dimensions normal to one corresponding to <em>x</em> ). The implementation of this function ignores this and overwrites that portion with the latest data sent. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xg</em>&nbsp;</td><td>Global 1D array (must be preallocated) without ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Local 1D array to be gathered </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>istart</em>&nbsp;</td><td>Starting index (global) of this rank's portion of the array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iend</em>&nbsp;</td><td>Ending index (global) of this rank's portion of the array + 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N_local</em>&nbsp;</td><td>Local size of the array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00164_source.html#l00026">26</a> of file <a class="el" href="a00164_source.html">MPIGatherArray1D.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00035"></a>00035 {
<a name="l00036"></a>00036   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> *mpi = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00037"></a>00037   <span class="keywordtype">int</span>          ierr = 0;
<a name="l00038"></a>00038 
<a name="l00039"></a>00039   <span class="comment">/* xg should be non-null only on root */</span>
<a name="l00040"></a>00040   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a> &amp;&amp; xg) {
<a name="l00041"></a>00041     fprintf(stderr,<span class="stringliteral">&quot;Error in MPIGatherArray1D(): global array exists on non-root processors (rank %d).\n&quot;</span>,
<a name="l00042"></a>00042             mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>);
<a name="l00043"></a>00043     ierr = 1;
<a name="l00044"></a>00044   }
<a name="l00045"></a>00045   <span class="keywordflow">if</span> ((!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) &amp;&amp; (!xg)) {
<a name="l00046"></a>00046     fprintf(stderr,<span class="stringliteral">&quot;Error in MPIGatherArray1D(): global array is not allocated on root processor.\n&quot;</span>);
<a name="l00047"></a>00047     ierr = 1;
<a name="l00048"></a>00048   }
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   <span class="comment">/* create and copy data to a buffer to send to the root process */</span>
<a name="l00051"></a>00051   <span class="keywordtype">double</span> *buffer = (<span class="keywordtype">double</span>*) calloc (N_local,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00052"></a>00052   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((x+ghosts),(buffer),N_local);
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   <span class="keywordflow">if</span> (!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) {
<a name="l00055"></a>00055 <span class="preprocessor">#ifndef serial</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>    MPI_Status status;
<a name="l00057"></a>00057 <span class="preprocessor">#endif</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>    <span class="keywordtype">int</span> proc;
<a name="l00059"></a>00059     <span class="keywordflow">for</span> (proc = 0; proc &lt; mpi-&gt;<a class="code" href="a00019.html#ae68326adc3b3862f1162832f70727b06">nproc</a>; proc++) {
<a name="l00060"></a>00060       <span class="comment">/* Find out the domain limits for each process */</span>
<a name="l00061"></a>00061       <span class="keywordtype">int</span> is,ie;
<a name="l00062"></a>00062       <span class="keywordflow">if</span> (proc) {
<a name="l00063"></a>00063 <span class="preprocessor">#ifndef serial</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span>        MPI_Recv(&amp;is,1,MPI_INT,proc,1442,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;status);
<a name="l00065"></a>00065         MPI_Recv(&amp;ie,1,MPI_INT,proc,1443,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;status);
<a name="l00066"></a>00066 <span class="preprocessor">#endif</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>      } <span class="keywordflow">else</span> { is = istart; ie = iend; }
<a name="l00068"></a>00068       <span class="keywordtype">int</span> size = ie - is;
<a name="l00069"></a>00069       <span class="keywordflow">if</span> (proc) {
<a name="l00070"></a>00070 <span class="preprocessor">#ifndef serial</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>        <span class="keywordtype">double</span> *recvbuf = (<span class="keywordtype">double</span>*) calloc (size,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00072"></a>00072         MPI_Recv(recvbuf,size,MPI_DOUBLE,proc,1916,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;status);
<a name="l00073"></a>00073         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((recvbuf),(xg+is),size);
<a name="l00074"></a>00074         free(recvbuf);
<a name="l00075"></a>00075 <span class="preprocessor">#endif</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span>      } <span class="keywordflow">else</span> <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(buffer,(xg+is),size);
<a name="l00077"></a>00077     }
<a name="l00078"></a>00078 
<a name="l00079"></a>00079   } <span class="keywordflow">else</span> {
<a name="l00080"></a>00080 <span class="preprocessor">#ifndef serial</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>    <span class="comment">/* Meanwhile, on other processes - send stuff to root */</span>
<a name="l00082"></a>00082     MPI_Send(&amp;istart,1      ,MPI_INT   ,0,1442,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>);
<a name="l00083"></a>00083     MPI_Send(&amp;iend  ,1      ,MPI_INT   ,0,1443,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>);
<a name="l00084"></a>00084     MPI_Send(buffer ,N_local,MPI_DOUBLE,0,1916,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>);
<a name="l00085"></a>00085 <span class="preprocessor">#endif</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>  }
<a name="l00087"></a>00087 
<a name="l00088"></a>00088   free(buffer);
<a name="l00089"></a>00089   <span class="keywordflow">return</span>(ierr);
<a name="l00090"></a>00090 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4cea2f7d5b8d6fad35c84c59da86631a"></a><!-- doxytag: member="mpivars.h::MPIGatherArraynD" ref="a4cea2f7d5b8d6fad35c84c59da86631a" args="(int, void *, double *, double *, int *, int *, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIGatherArraynD </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>xg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dim_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dim_local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gather local arrays into a global array for an n-dimensional array</p>
<p>Gathers the contents of an n-dimensional array, partitioned amongst the MPI ranks, in to a global array on rank 0. See documentation of <a class="el" href="a00045.html#a60ace5964c051fa481e6a1e6f1ef75d7">MPIExchangeBoundariesnD()</a> for how the n-dimensional array is stored in the memory as a single-index array.</p>
<p>Notes: + The global array must have no ghost points. + The global array must be allocated only on rank 0. On other ranks, it must be NULL. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xg</em>&nbsp;</td><td>Global array (preallocated) without ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dim_global</em>&nbsp;</td><td>Integer array with elements as global size along each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dim_local</em>&nbsp;</td><td>Integer array with elements as local size along each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables (vector components) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00165_source.html#l00021">21</a> of file <a class="el" href="a00165_source.html">MPIGatherArraynD.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00031"></a>00031 {
<a name="l00032"></a>00032   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> *mpi = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00033"></a>00033   <span class="keywordtype">int</span>          d, size;
<a name="l00034"></a>00034   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036   <span class="keywordtype">int</span> is[ndims], ie[ndims], <a class="code" href="a00031.html#a3c3f941ca00d3a46c402ac279bc0b44e">index</a>[ndims], bounds[ndims];
<a name="l00037"></a>00037 
<a name="l00038"></a>00038   <span class="comment">/* xg should be non-null only on root */</span>
<a name="l00039"></a>00039   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a> &amp;&amp; xg) {
<a name="l00040"></a>00040     fprintf(stderr,<span class="stringliteral">&quot;Error in MPIGatherArraynD(): global array exists on non-root processors (rank %d).\n&quot;</span>,
<a name="l00041"></a>00041             mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>);
<a name="l00042"></a>00042     <span class="keywordflow">return</span>(1);
<a name="l00043"></a>00043   }
<a name="l00044"></a>00044   <span class="keywordflow">if</span> ((!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) &amp;&amp; (!xg)) {
<a name="l00045"></a>00045     fprintf(stderr,<span class="stringliteral">&quot;Error in MPIGatherArraynD(): global array is not allocated on root processor.\n&quot;</span>);
<a name="l00046"></a>00046     <span class="keywordflow">return</span>(1);
<a name="l00047"></a>00047   }
<a name="l00048"></a>00048 
<a name="l00049"></a>00049   <span class="comment">/* calculate total size of local domain (w/o ghosts) */</span>
<a name="l00050"></a>00050   size = 1;
<a name="l00051"></a>00051   <span class="keywordflow">for</span> (d = 0; d &lt; ndims; d++) size *= dim_local[d];
<a name="l00052"></a>00052 
<a name="l00053"></a>00053   <span class="comment">/* create and copy data to send to root process */</span>
<a name="l00054"></a>00054   <span class="keywordtype">double</span> *buffer = (<span class="keywordtype">double</span>*) calloc (size*nvars, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00055"></a>00055   <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00034.html#ac4ae1109cf287763cef63cc38d52589f">ArrayCopynD</a>(ndims,x,buffer,dim_local,ghosts,0,index,nvars); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00056"></a>00056 
<a name="l00057"></a>00057   <span class="keywordflow">if</span> (!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) {
<a name="l00058"></a>00058     <span class="keywordtype">int</span> proc;
<a name="l00059"></a>00059     <span class="keywordflow">for</span> (proc = 0; proc &lt; mpi-&gt;<a class="code" href="a00019.html#ae68326adc3b3862f1162832f70727b06">nproc</a>; proc++) {
<a name="l00060"></a>00060       <span class="keywordtype">int</span> d,done,size;
<a name="l00061"></a>00061       <span class="comment">/* Find out the domain limits for each process */</span>
<a name="l00062"></a>00062       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00045.html#a9a3fc32b7d4bea6a1dac44ab21c9202e">MPILocalDomainLimits</a>(ndims,proc,mpi,dim_global,is,ie); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00063"></a>00063       size = 1;
<a name="l00064"></a>00064       <span class="keywordflow">for</span> (d=0; d&lt;ndims; d++) {
<a name="l00065"></a>00065         size *= (ie[d]-is[d]);
<a name="l00066"></a>00066         bounds[d] = ie[d] - is[d];
<a name="l00067"></a>00067       }
<a name="l00068"></a>00068       <span class="keywordflow">if</span> (proc) {
<a name="l00069"></a>00069 <span class="preprocessor">#ifndef serial</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span>        MPI_Status status;
<a name="l00071"></a>00071         <span class="keywordtype">double</span> *recvbuf = (<span class="keywordtype">double</span>*) calloc (size*nvars, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00072"></a>00072         MPI_Recv(recvbuf,size*nvars,MPI_DOUBLE,proc,1902,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;status);
<a name="l00073"></a>00073         <span class="keywordtype">int</span> done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index,ndims,0);
<a name="l00074"></a>00074         <span class="keywordflow">while</span> (!done) {
<a name="l00075"></a>00075           <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds,index,0,p1);
<a name="l00076"></a>00076           <span class="keywordtype">int</span> p2; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,dim_global,index,is,0,p2);
<a name="l00077"></a>00077           <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((recvbuf+nvars*p1),(xg+nvars*p2),nvars);
<a name="l00078"></a>00078           <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,index,done);
<a name="l00079"></a>00079         }
<a name="l00080"></a>00080         free(recvbuf);
<a name="l00081"></a>00081 <span class="preprocessor">#endif</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span>      } <span class="keywordflow">else</span> {
<a name="l00083"></a>00083         done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index,ndims,0);
<a name="l00084"></a>00084         <span class="keywordflow">while</span> (!done) {
<a name="l00085"></a>00085           <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds,index,0,p1);
<a name="l00086"></a>00086           <span class="keywordtype">int</span> p2; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,dim_global,index,is,0,p2);
<a name="l00087"></a>00087           <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((buffer+nvars*p1),(xg+nvars*p2),nvars);
<a name="l00088"></a>00088           <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,index,done);
<a name="l00089"></a>00089         }
<a name="l00090"></a>00090       }
<a name="l00091"></a>00091     }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   } <span class="keywordflow">else</span> {
<a name="l00094"></a>00094 <span class="preprocessor">#ifndef serial</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span>    <span class="comment">/* Meanwhile, on other processes */</span>
<a name="l00096"></a>00096     MPI_Send(buffer,size*nvars,MPI_DOUBLE,0,1902,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>);
<a name="l00097"></a>00097 <span class="preprocessor">#endif</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span>  }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100   free(buffer);
<a name="l00101"></a>00101   <span class="keywordflow">return</span>(0);
<a name="l00102"></a>00102 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a690395a8c8453cdfb455de275a46be07"></a><!-- doxytag: member="mpivars.h::MPIPartitionArraynD" ref="a690395a8c8453cdfb455de275a46be07" args="(int, void *, double *, double *, int *, int *, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIPartitionArraynD </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>xg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dim_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dim_local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Partition a global array into local arrays for an n-dimensional array</p>
<p>Partitions the contents of a global n-dimensional array on rank 0 (root) to local n-dimensional arrays on all the MPI ranks. See documentation of <a class="el" href="a00045.html#a60ace5964c051fa481e6a1e6f1ef75d7">MPIExchangeBoundariesnD()</a> for how the n-dimensional array is stored in the memory as a single-index array.</p>
<p>Notes: + The global array must have no ghost points. + The global array must be allocated only on rank 0. On other ranks, it must be NULL. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xg</em>&nbsp;</td><td>Global array (preallocated) without ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dim_global</em>&nbsp;</td><td>Integer array with elements as global size along each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dim_local</em>&nbsp;</td><td>Integer array with elements as local size along each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables (vector components) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00174_source.html#l00021">21</a> of file <a class="el" href="a00174_source.html">MPIPartitionArraynD.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00031"></a>00031 {
<a name="l00032"></a>00032   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> *mpi = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00033"></a>00033   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035   <span class="keywordtype">int</span> is[ndims], ie[ndims], <a class="code" href="a00031.html#a3c3f941ca00d3a46c402ac279bc0b44e">index</a>[ndims], bounds[ndims];
<a name="l00036"></a>00036 
<a name="l00037"></a>00037   <span class="comment">/* xg should be non-null only on root */</span>
<a name="l00038"></a>00038   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a> &amp;&amp; xg) {
<a name="l00039"></a>00039     fprintf(stderr,<span class="stringliteral">&quot;Error in MPIPartitionArraynD(): global array exists on non-root processors (rank %d).\n&quot;</span>,
<a name="l00040"></a>00040             mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>);
<a name="l00041"></a>00041     <span class="keywordflow">return</span>(1);
<a name="l00042"></a>00042   }
<a name="l00043"></a>00043   <span class="keywordflow">if</span> ((!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) &amp;&amp; (!xg)) {
<a name="l00044"></a>00044     fprintf(stderr,<span class="stringliteral">&quot;Error in MPIPartitionArraynD(): global array is not allocated on root processor.\n&quot;</span>);
<a name="l00045"></a>00045     <span class="keywordflow">return</span>(1);
<a name="l00046"></a>00046   }
<a name="l00047"></a>00047 
<a name="l00048"></a>00048   <span class="keywordflow">if</span> (!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) {
<a name="l00049"></a>00049     <span class="keywordtype">int</span> proc;
<a name="l00050"></a>00050     <span class="keywordflow">for</span> (proc = 0; proc &lt; mpi-&gt;<a class="code" href="a00019.html#ae68326adc3b3862f1162832f70727b06">nproc</a>; proc++) {
<a name="l00051"></a>00051       <span class="keywordtype">int</span> d,done,size;
<a name="l00052"></a>00052       <span class="comment">/* Find out the domain limits for each process */</span>
<a name="l00053"></a>00053       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00045.html#a9a3fc32b7d4bea6a1dac44ab21c9202e">MPILocalDomainLimits</a>(ndims,proc,mpi,dim_global,is,ie); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00054"></a>00054       size = 1;
<a name="l00055"></a>00055       <span class="keywordflow">for</span> (d=0; d&lt;ndims; d++) {
<a name="l00056"></a>00056         size *= (ie[d]-is[d]);
<a name="l00057"></a>00057         bounds[d] = ie[d] - is[d];
<a name="l00058"></a>00058       }
<a name="l00059"></a>00059       <span class="keywordtype">double</span> *buffer = (<span class="keywordtype">double</span>*) calloc (size*nvars, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00060"></a>00060       done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index,ndims,0);
<a name="l00061"></a>00061       <span class="keywordflow">while</span> (!done) {
<a name="l00062"></a>00062         <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,dim_global,index,is,0,p1);
<a name="l00063"></a>00063         <span class="keywordtype">int</span> p2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds,index,0,p2);
<a name="l00064"></a>00064         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((xg+nvars*p1),(buffer+nvars*p2),nvars);
<a name="l00065"></a>00065         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,index,done);
<a name="l00066"></a>00066       }
<a name="l00067"></a>00067       <span class="keywordflow">if</span> (proc) {
<a name="l00068"></a>00068 <span class="preprocessor">#ifndef serial</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span>        MPI_Send(buffer,size*nvars,MPI_DOUBLE,proc,1538,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>);
<a name="l00070"></a>00070 <span class="preprocessor">#endif</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>      } <span class="keywordflow">else</span> {
<a name="l00072"></a>00072         done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index,ndims,0);
<a name="l00073"></a>00073         <span class="keywordflow">while</span> (!done) {
<a name="l00074"></a>00074           <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim_local,index,ghosts,p1);
<a name="l00075"></a>00075           <span class="keywordtype">int</span> p2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim_local,index,0,p2);
<a name="l00076"></a>00076           <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((buffer+nvars*p2),(x+nvars*p1),nvars);
<a name="l00077"></a>00077           <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,dim_local,index,done);
<a name="l00078"></a>00078         }
<a name="l00079"></a>00079       }
<a name="l00080"></a>00080       free(buffer);
<a name="l00081"></a>00081     }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083   } <span class="keywordflow">else</span> {
<a name="l00084"></a>00084 <span class="preprocessor">#ifndef serial</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span>    <span class="comment">/* Meanwhile, on other processes */</span>
<a name="l00086"></a>00086     MPI_Status  status;
<a name="l00087"></a>00087     <span class="keywordtype">int</span> d, done, size;
<a name="l00088"></a>00088     size = 1; <span class="keywordflow">for</span> (d=0; d&lt;ndims; d++) size *= dim_local[d];
<a name="l00089"></a>00089     <span class="keywordtype">double</span> *buffer = (<span class="keywordtype">double</span>*) calloc (size*nvars, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00090"></a>00090     MPI_Recv(buffer,size*nvars,MPI_DOUBLE,0,1538,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;status);
<a name="l00091"></a>00091     done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index,ndims,0);
<a name="l00092"></a>00092     <span class="keywordflow">while</span> (!done) {
<a name="l00093"></a>00093       <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim_local,index,ghosts,p1);
<a name="l00094"></a>00094       <span class="keywordtype">int</span> p2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim_local,index,0,p2);
<a name="l00095"></a>00095       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((buffer+nvars*p2),(x+nvars*p1),nvars);
<a name="l00096"></a>00096       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,dim_local,index,done);
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098     free(buffer);
<a name="l00099"></a>00099 <span class="preprocessor">#endif</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>  }
<a name="l00101"></a>00101   <span class="keywordflow">return</span>(0);
<a name="l00102"></a>00102 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a77f4e7a03979d9fabce2a536a113ff42"></a><!-- doxytag: member="mpivars.h::MPIPartitionArray1D" ref="a77f4e7a03979d9fabce2a536a113ff42" args="(void *, double *, double *, int, int, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIPartitionArray1D </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>xg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>istart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N_local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Partition a global array into local arrays for an essentially 1D array</p>
<p>Partitions the contents of a global 1D array on the root rank (rank 0) to local arrays on all the MPI ranks. See documentation of <a class="el" href="a00045.html#ac2f0cce702a9ce439753286ce227c7a2">MPIExchangeBoundaries1D()</a> on what a "1D 
  array" is in the context of a multidimensional simulation. The 1D array must be the same along spatial dimensions normal to the one it represents.</p>
<p>Notes: + The global array must not have ghost points. + The global array must be preallocated on only rank 0. On other ranks, it must be NULL. + Since this function deals with a 1D array, more than one rank may be receiving the same piece of data from rank 0 (<a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>. if there are more than one MPI rank along the dimensions normal to one corresponding to <em>x</em> ). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xg</em>&nbsp;</td><td>Global 1D array (must be preallocated) without ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Local 1D array to be gathered </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>istart</em>&nbsp;</td><td>Starting index (global) of this rank's portion of the array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iend</em>&nbsp;</td><td>Ending index (global) of this rank's portion of the array + 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N_local</em>&nbsp;</td><td>Local size of the array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00173_source.html#l00025">25</a> of file <a class="el" href="a00173_source.html">MPIPartitionArray1D.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00034"></a>00034 {
<a name="l00035"></a>00035   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> *mpi = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00036"></a>00036   <span class="keywordtype">int</span>          ierr = 0;
<a name="l00037"></a>00037 <span class="preprocessor">#ifndef serial</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>  MPI_Status   status;
<a name="l00039"></a>00039 <span class="preprocessor">#endif</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a>00041   <span class="comment">/* xg should be non-null only on root */</span>
<a name="l00042"></a>00042   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a> &amp;&amp; xg) {
<a name="l00043"></a>00043     fprintf(stderr,<span class="stringliteral">&quot;Error in MPIPartitionArray1D(): global array exists on non-root processors (rank %d).\n&quot;</span>,
<a name="l00044"></a>00044             mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>);
<a name="l00045"></a>00045     ierr = 1;
<a name="l00046"></a>00046   }
<a name="l00047"></a>00047   <span class="keywordflow">if</span> ((!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) &amp;&amp; (!xg)) {
<a name="l00048"></a>00048     fprintf(stderr,<span class="stringliteral">&quot;Error in MPIPartitionArray1D(): global array is not allocated on root processor.\n&quot;</span>);
<a name="l00049"></a>00049     ierr = 1;
<a name="l00050"></a>00050   }
<a name="l00051"></a>00051 
<a name="l00052"></a>00052   <span class="keywordflow">if</span> (!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) {
<a name="l00053"></a>00053     <span class="keywordtype">int</span> proc;
<a name="l00054"></a>00054     <span class="keywordflow">for</span> (proc = 0; proc &lt; mpi-&gt;<a class="code" href="a00019.html#ae68326adc3b3862f1162832f70727b06">nproc</a>; proc++) {
<a name="l00055"></a>00055       <span class="comment">/* Find out the domain limits for each process */</span>
<a name="l00056"></a>00056       <span class="keywordtype">int</span> is,ie;
<a name="l00057"></a>00057       <span class="keywordflow">if</span> (proc) {
<a name="l00058"></a>00058 <span class="preprocessor">#ifndef serial</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>        MPI_Recv(&amp;is,1,MPI_INT,proc,1442,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;status);
<a name="l00060"></a>00060         MPI_Recv(&amp;ie,1,MPI_INT,proc,1443,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;status);
<a name="l00061"></a>00061 <span class="preprocessor">#endif</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>      } <span class="keywordflow">else</span> {
<a name="l00063"></a>00063         is = istart;
<a name="l00064"></a>00064         ie = iend;
<a name="l00065"></a>00065       }
<a name="l00066"></a>00066       <span class="keywordtype">int</span> size = ie - is;
<a name="l00067"></a>00067       <span class="keywordtype">double</span> *buffer = (<span class="keywordtype">double</span>*) calloc (size, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00068"></a>00068       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((xg+is),buffer,size);
<a name="l00069"></a>00069       <span class="keywordflow">if</span> (proc) {
<a name="l00070"></a>00070 <span class="preprocessor">#ifndef serial</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>        MPI_Send(buffer,size,MPI_DOUBLE,proc,1539,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>);
<a name="l00072"></a>00072 <span class="preprocessor">#endif</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span>      } <span class="keywordflow">else</span> <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(buffer,x,N_local);
<a name="l00074"></a>00074       free(buffer);
<a name="l00075"></a>00075     }
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   } <span class="keywordflow">else</span> {
<a name="l00078"></a>00078 <span class="preprocessor">#ifndef serial</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>    <span class="comment">/* Meanwhile, on other processes */</span>
<a name="l00080"></a>00080     <span class="comment">/* send local start and end indices to root */</span>
<a name="l00081"></a>00081     MPI_Send(&amp;istart,1,MPI_INT,0,1442,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>);
<a name="l00082"></a>00082     MPI_Send(&amp;iend  ,1,MPI_INT,0,1443,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>);
<a name="l00083"></a>00083     <span class="keywordtype">double</span> *buffer = (<span class="keywordtype">double</span>*) calloc (N_local, <span class="keyword">sizeof</span>(buffer));
<a name="l00084"></a>00084     MPI_Recv(buffer,N_local,MPI_DOUBLE,0,1539,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;status);
<a name="l00085"></a>00085     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(buffer,x,N_local);
<a name="l00086"></a>00086     free(buffer);
<a name="l00087"></a>00087 <span class="preprocessor">#endif</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span>  }
<a name="l00089"></a>00089   <span class="keywordflow">return</span>(ierr);
<a name="l00090"></a>00090 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5795cc6a69ea39684662afc8c2557272"></a><!-- doxytag: member="mpivars.h::MPIGetArrayDatanD" ref="a5795cc6a69ea39684662afc8c2557272" args="(double *, double *, int *, int *, int *, int *, int, int, int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIGetArrayDatanD </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>fetch data from an n-dimensional local array on another rank</p>
<p>This function lets one rank get a portion of a local n-dimensional array on another rank. The n-dimensional array must be stored in the memory as a single-index array as described in the documentation of <a class="el" href="a00045.html#a60ace5964c051fa481e6a1e6f1ef75d7">MPIExchangeBoundariesnD()</a>. The <em>source</em> rank sends to the <em>dest</em> rank a logically rectangular n-dimensional portion of its local copy of an array <em>x</em>. The extent of this logically rectangular portion is defined by <em>limits</em>. + <em>limits</em> is an array of size 2x the number of spatial dimensions, with elements as: [ is[0], ie[0], is[1], ie[1], ..., is[ndims-1], ie[ndims-1] ], where is[n] is the starting index along spatial dimension n, and ie[n] is the end index (+1) along spatial dimension n. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xbuf</em>&nbsp;</td><td>preallocated memory on destination rank to hold the received data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>local array of which a part is needed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>MPI rank of the source </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>MPI rank of the destination </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limits</em>&nbsp;</td><td>Integer array (of size 2*ndims) with the start and end indices along each spatial dimension of the desired portion of the array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>Integer array whose elements are the local size of x in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables (vector components) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00166_source.html#l00021">21</a> of file <a class="el" href="a00166_source.html">MPIGetArrayDatanD.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00034"></a>00034 {
<a name="l00035"></a>00035   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> *mpi  = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00036"></a>00036   <span class="keywordtype">int</span>          d;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038   <span class="keywordtype">int</span> source_rank = <a class="code" href="a00045.html#a36e2be86c7dc0d9dd088ed2f5842f556">MPIRank1D</a>(ndims,mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>,source);
<a name="l00039"></a>00039   <span class="keywordtype">int</span> dest_rank   = <a class="code" href="a00045.html#a36e2be86c7dc0d9dd088ed2f5842f556">MPIRank1D</a>(ndims,mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>,dest  );
<a name="l00040"></a>00040 
<a name="l00041"></a>00041   <span class="keywordtype">int</span> is[ndims], ie[ndims], <a class="code" href="a00031.html#a3c3f941ca00d3a46c402ac279bc0b44e">index</a>[ndims], bounds[ndims], size;
<a name="l00042"></a>00042   size    = 1;
<a name="l00043"></a>00043   <span class="keywordflow">for</span> (d=0; d&lt;ndims; d++) {
<a name="l00044"></a>00044     is[d] =  limits[2*d  ];
<a name="l00045"></a>00045     ie[d] =  limits[2*d+1];
<a name="l00046"></a>00046     size  *= (ie[d] - is[d]);
<a name="l00047"></a>00047   }
<a name="l00048"></a>00048   <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,ie,is,ndims);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   <span class="keywordflow">if</span> (source_rank == dest_rank) {
<a name="l00051"></a>00051     <span class="comment">/* source and dest are the same process */</span>
<a name="l00052"></a>00052     <span class="keywordtype">int</span> done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index,ndims,0);
<a name="l00053"></a>00053     <span class="keywordflow">while</span> (!done) {
<a name="l00054"></a>00054       <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds,index,0,p1);
<a name="l00055"></a>00055       <span class="keywordtype">int</span> p2; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,dim,index,is,ghosts,p2);
<a name="l00056"></a>00056       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((x+nvars*p2),(xbuf+nvars*p1),nvars);
<a name="l00057"></a>00057       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,index,done);
<a name="l00058"></a>00058     }
<a name="l00059"></a>00059   } <span class="keywordflow">else</span> {
<a name="l00060"></a>00060 <span class="preprocessor">#ifdef serial</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span>    fprintf(stderr,<span class="stringliteral">&quot;Error in MPIGetArrayDatanD(): This is a serial run. Source and &quot;</span>);
<a name="l00062"></a>00062     fprintf(stderr,<span class="stringliteral">&quot;destination ranks must be equal. Instead they are %d and %d.\n&quot;</span>,
<a name="l00063"></a>00063                     source_rank,dest_rank);
<a name="l00064"></a>00064     <span class="keywordflow">return</span>(1);
<a name="l00065"></a>00065 <span class="preprocessor">#else</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a> == source_rank) {
<a name="l00067"></a>00067       <span class="keywordtype">double</span> *buf = (<span class="keywordtype">double</span>*) calloc (size*nvars, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00068"></a>00068       <span class="keywordtype">int</span> done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index,ndims,0);
<a name="l00069"></a>00069       <span class="keywordflow">while</span> (!done) {
<a name="l00070"></a>00070         <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds,index,0,p1);
<a name="l00071"></a>00071         <span class="keywordtype">int</span> p2; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,dim,index,is,ghosts,p2);
<a name="l00072"></a>00072         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((x+nvars*p2),(buf+nvars*p1),nvars);
<a name="l00073"></a>00073         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,index,done);
<a name="l00074"></a>00074       }
<a name="l00075"></a>00075       MPI_Send(buf,size*nvars,MPI_DOUBLE,dest_rank,2211,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>);
<a name="l00076"></a>00076       free(buf);
<a name="l00077"></a>00077     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a> == dest_rank) {
<a name="l00078"></a>00078       MPI_Status status;
<a name="l00079"></a>00079       MPI_Recv(xbuf,size*nvars,MPI_DOUBLE,source_rank,2211,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;status);
<a name="l00080"></a>00080     } <span class="keywordflow">else</span> {
<a name="l00081"></a>00081       fprintf(stderr,<span class="stringliteral">&quot;Error in MPIGetArrayData3D(): Process %d shouldn&apos;t have entered this function.\n&quot;</span>,
<a name="l00082"></a>00082               mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>);
<a name="l00083"></a>00083       <span class="keywordflow">return</span>(1);
<a name="l00084"></a>00084     }
<a name="l00085"></a>00085 <span class="preprocessor">#endif</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>  }
<a name="l00087"></a>00087   <span class="keywordflow">return</span>(0);
<a name="l00088"></a>00088 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9a3fc32b7d4bea6a1dac44ab21c9202e"></a><!-- doxytag: member="mpivars.h::MPILocalDomainLimits" ref="a9a3fc32b7d4bea6a1dac44ab21c9202e" args="(int, int, void *, int *, int *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPILocalDomainLimits </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dim_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the local domain limits/extend in terms of the global domain</p>
<p>Computes the local domain limites: Given a MPI rank <em>p</em>, this function will compute the starting and ending indices of the local domain on this rank. These indices are global. + The starting and ending indices are stored in preallocated integer arrays, whose elements are these indices in each spatial dimension. + The ending index is 1 + actual last index; thus the one can write the loop as (i=start; i&lt;end; i++) and <b>not</b> (i=start; i&lt;=end; i++). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>MPI rank </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dim_global</em>&nbsp;</td><td>Integer array with elements as global size in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is</em>&nbsp;</td><td>Integer array whose elements will contain the starting index of the local domain on rank <em>p</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ie</em>&nbsp;</td><td>Integer array whose elements will contain the ending index of the local domain on rank <em>p</em> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00169_source.html#l00018">18</a> of file <a class="el" href="a00169_source.html">MPILocalDomainLimits.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00026"></a>00026 {
<a name="l00027"></a>00027   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> *mpi = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00028"></a>00028   <span class="keywordtype">int</span>          i;
<a name="l00029"></a>00029   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00030"></a>00030 
<a name="l00031"></a>00031   <span class="keywordtype">int</span> ip[ndims];
<a name="l00032"></a>00032   <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00045.html#afe59a0480bb81cc0d7877ba547b3e28c">MPIRanknD</a>(ndims,p,mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>,ip); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00033"></a>00033 
<a name="l00034"></a>00034   <span class="keywordflow">for</span> (i=0; i&lt;ndims; i++) {
<a name="l00035"></a>00035     <span class="keywordtype">int</span> imax_local, isize, root = 0;
<a name="l00036"></a>00036     imax_local = <a class="code" href="a00045.html#af8194ca5a460534fdbe391035a95c69d">MPIPartition1D</a>(dim_global[i],mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[i],root );
<a name="l00037"></a>00037     isize      = <a class="code" href="a00045.html#af8194ca5a460534fdbe391035a95c69d">MPIPartition1D</a>(dim_global[i],mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[i],ip[i]);
<a name="l00038"></a>00038     <span class="keywordflow">if</span> (is)  is[i] = ip[i]*imax_local;
<a name="l00039"></a>00039     <span class="keywordflow">if</span> (ie)  ie[i] = ip[i]*imax_local + isize;
<a name="l00040"></a>00040   }
<a name="l00041"></a>00041   <span class="keywordflow">return</span>(0);
<a name="l00042"></a>00042 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a184fc81a4d6618de22a60c9d8436fc83"></a><!-- doxytag: member="mpivars.h::MPIMax_integer" ref="a184fc81a4d6618de22a60c9d8436fc83" args="(int *, int *, int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIMax_integer </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>comm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the maximum in an integer array over all ranks</p>
<p>Compute the global maximum over all MPI ranks in a given communicator for <em>int</em> datatype. + If <em>var</em> is an array of size greater than 1, <em>global</em> will be an array of the same size with each element as the maximum value of that element in <em>var</em> on all the MPI ranks in the given communicator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>array to contain the global maximums </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comm</em>&nbsp;</td><td>MPI communicator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00170_source.html#l00015">15</a> of file <a class="el" href="a00170_source.html">MPIMax.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00021"></a>00021 {
<a name="l00022"></a>00022 <span class="preprocessor">#ifdef serial</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span>  <span class="keywordtype">int</span> i;
<a name="l00024"></a>00024   <span class="keywordflow">for</span> (i = 0; i &lt; size; i++)  global[i] = var[i];
<a name="l00025"></a>00025 <span class="preprocessor">#else</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>  MPI_Allreduce((var==global?MPI_IN_PLACE:var),global,size,MPI_INT,MPI_MAX,*((MPI_Comm*)comm));
<a name="l00027"></a>00027 <span class="preprocessor">#endif</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00029"></a>00029 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a42b8065bc8e4830aef4c26e58ab4d38d"></a><!-- doxytag: member="mpivars.h::MPIMax_long" ref="a42b8065bc8e4830aef4c26e58ab4d38d" args="(long *, long *, int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIMax_long </td>
          <td>(</td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the maximum in a long integer array over all ranks </p>

</div>
</div>
<a class="anchor" id="a33aa37e0050ec72dadb8d63851df51ec"></a><!-- doxytag: member="mpivars.h::MPIMax_double" ref="a33aa37e0050ec72dadb8d63851df51ec" args="(double *, double *, int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIMax_double </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>comm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the maximum in a double array over all ranks</p>
<p>Compute the global maximum over all MPI ranks in a given communicator for <em>double</em> datatype. + If <em>var</em> is an array of size greater than 1, <em>global</em> will be an array of the same size with each element as the maximum value of that element in <em>var</em> on all the MPI ranks in the given communicator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>array to contain the global maximums </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comm</em>&nbsp;</td><td>MPI communicator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00170_source.html#l00038">38</a> of file <a class="el" href="a00170_source.html">MPIMax.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00044"></a>00044 {
<a name="l00045"></a>00045 <span class="preprocessor">#ifdef serial</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span>  <span class="keywordtype">int</span> i;
<a name="l00047"></a>00047   <span class="keywordflow">for</span> (i = 0; i &lt; size; i++)  global[i] = var[i];
<a name="l00048"></a>00048 <span class="preprocessor">#else</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>  MPI_Allreduce((var==global?MPI_IN_PLACE:var),global,size,MPI_DOUBLE,MPI_MAX,*((MPI_Comm*)comm));
<a name="l00050"></a>00050 <span class="preprocessor">#endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00052"></a>00052 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac57453b9ebabb57bbadd0521c9151aaf"></a><!-- doxytag: member="mpivars.h::MPIMin_integer" ref="ac57453b9ebabb57bbadd0521c9151aaf" args="(int *, int *, int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIMin_integer </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>comm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the minimum in an integer array over all ranks</p>
<p>Compute the global minimum over all MPI ranks in a given communicator for <em>int</em> datatype. + If <em>var</em> is an array of size greater than 1, <em>global</em> will be an array of the same size with each element as the minimum value of he that element in <em>var</em> on all the MPI ranks in the given communicator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>array to contain the global minimums </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comm</em>&nbsp;</td><td>MPI communicator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00171_source.html#l00015">15</a> of file <a class="el" href="a00171_source.html">MPIMin.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00021"></a>00021 {
<a name="l00022"></a>00022 <span class="preprocessor">#ifdef serial</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span>  <span class="keywordtype">int</span> i;
<a name="l00024"></a>00024   <span class="keywordflow">for</span> (i = 0; i &lt; size; i++)  global[i] = var[i];
<a name="l00025"></a>00025 <span class="preprocessor">#else</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>  MPI_Allreduce((var==global?MPI_IN_PLACE:var),global,size,MPI_INT,MPI_MIN,*((MPI_Comm*)comm));
<a name="l00027"></a>00027 <span class="preprocessor">#endif</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00029"></a>00029 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a754822278a5d215ecfafa28f1beed7bf"></a><!-- doxytag: member="mpivars.h::MPIMin_double" ref="a754822278a5d215ecfafa28f1beed7bf" args="(double *, double *, int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIMin_double </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>comm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the minimum in a double array over all ranks</p>
<p>Compute the global minimum over all MPI ranks in a given communicator for <em>double</em> datatype. + If <em>var</em> is an array of size greater than 1, <em>global</em> will be an array of the same size with each element as the minimum value of that element in <em>var</em> on all the MPI ranks in the given communicator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>array to contain the global minimums </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comm</em>&nbsp;</td><td>MPI communicator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00171_source.html#l00038">38</a> of file <a class="el" href="a00171_source.html">MPIMin.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00044"></a>00044 {
<a name="l00045"></a>00045 <span class="preprocessor">#ifdef serial</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span>  <span class="keywordtype">int</span> i;
<a name="l00047"></a>00047   <span class="keywordflow">for</span> (i = 0; i &lt; size; i++)  global[i] = var[i];
<a name="l00048"></a>00048 <span class="preprocessor">#else</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>  MPI_Allreduce((var==global?MPI_IN_PLACE:var),global,size,MPI_DOUBLE,MPI_MIN,*((MPI_Comm*)comm));
<a name="l00050"></a>00050 <span class="preprocessor">#endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00052"></a>00052 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abd61f932b070ee84262d9d98b6dd854f"></a><!-- doxytag: member="mpivars.h::MPISum_double" ref="abd61f932b070ee84262d9d98b6dd854f" args="(double *, double *, int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPISum_double </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>comm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the sum of an array of doubles over all ranks</p>
<p>Compute the global sum over all MPI ranks in a given communicator for <em>double</em> datatype. + If <em>var</em> is an array of size greater than 1, <em>global</em> will be an array of the same size with each element as the sum of that element in <em>var</em> on all the MPI ranks in the given communicator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>array to contain the global sums </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comm</em>&nbsp;</td><td>MPI communicator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00177_source.html#l00039">39</a> of file <a class="el" href="a00177_source.html">MPISum.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00045"></a>00045 {
<a name="l00046"></a>00046 <span class="preprocessor">#ifdef serial</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span>  <span class="keywordtype">int</span> i;
<a name="l00048"></a>00048   <span class="keywordflow">for</span> (i = 0; i &lt; size; i++)  global[i] = var[i];
<a name="l00049"></a>00049 <span class="preprocessor">#else</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>  MPI_Allreduce((var==global?MPI_IN_PLACE:var),global,size,MPI_DOUBLE,MPI_SUM,*((MPI_Comm*)comm));
<a name="l00051"></a>00051 <span class="preprocessor">#endif</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00053"></a>00053 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a25c7df0ff2e4f81a64368ea72894a4f8"></a><!-- doxytag: member="mpivars.h::MPISum_integer" ref="a25c7df0ff2e4f81a64368ea72894a4f8" args="(int *, int *, int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPISum_integer </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>comm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the sum of an array of integers over all ranks</p>
<p>Compute the global sum over all MPI ranks in a given communicator for <em>int</em> datatype. + If <em>var</em> is an array of size greater than 1, <em>global</em> will be an array of the same size with each element as the sum of that element in <em>var</em> on all the MPI ranks in the given communicator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>array to contain the global sums </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the local array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comm</em>&nbsp;</td><td>MPI communicator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00177_source.html#l00016">16</a> of file <a class="el" href="a00177_source.html">MPISum.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00022"></a>00022 {
<a name="l00023"></a>00023 <span class="preprocessor">#ifdef serial</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>  <span class="keywordtype">int</span> i;
<a name="l00025"></a>00025   <span class="keywordflow">for</span> (i = 0; i &lt; size; i++)  global[i] = var[i];
<a name="l00026"></a>00026 <span class="preprocessor">#else</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>  MPI_Allreduce((var==global?MPI_IN_PLACE:var),global,size,MPI_INT,MPI_SUM,*((MPI_Comm*)comm));
<a name="l00028"></a>00028 <span class="preprocessor">#endif</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(0);
<a name="l00030"></a>00030 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af8194ca5a460534fdbe391035a95c69d"></a><!-- doxytag: member="mpivars.h::MPIPartition1D" ref="af8194ca5a460534fdbe391035a95c69d" args="(int, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIPartition1D </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nglobal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rank</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Partition (along a dimension) the domain given global size and number of ranks</p>
<p>Given a 1D array of a given global size <em>nglobal</em>, and the total number of MPI ranks <em>nproc</em> on which it will be partitioned, this function computes the size of the local part of the 1D array on <em>rank</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nglobal</em>&nbsp;</td><td>Global size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nproc</em>&nbsp;</td><td>Total number of ranks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rank</em>&nbsp;</td><td>Rank </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00172_source.html#l00014">14</a> of file <a class="el" href="a00172_source.html">MPIPartition1D.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00019"></a>00019 {
<a name="l00020"></a>00020   <span class="keywordtype">int</span> nlocal;
<a name="l00021"></a>00021   <span class="keywordflow">if</span> (nglobal%nproc == 0) nlocal = nglobal/nproc;
<a name="l00022"></a>00022   <span class="keywordflow">else</span> {
<a name="l00023"></a>00023     <span class="keywordflow">if</span> (rank == nproc-1)  nlocal = nglobal/nproc + nglobal%nproc;
<a name="l00024"></a>00024     <span class="keywordflow">else</span>                  nlocal = nglobal/nproc;
<a name="l00025"></a>00025   }
<a name="l00026"></a>00026   <span class="keywordflow">return</span>(nlocal);
<a name="l00027"></a>00027 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a36e2be86c7dc0d9dd088ed2f5842f556"></a><!-- doxytag: member="mpivars.h::MPIRank1D" ref="a36e2be86c7dc0d9dd088ed2f5842f556" args="(int, int *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIRank1D </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>iproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>ip</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate 1D rank from the n-dimensional rank</p>
<p>This function returns the 1D rank, given the n-dimensional rank and the total number of MPI ranks along each spatial dimension.</p>
<p><b>1D</b> <b>Rank:</b> This is the rank of the process in the communicator.<br/>
 <b>n-Dimensional</b> <b>Rank:</b> This represents an integer array, where each element is the rank of the process along a spatial dimension.</p>
<p>Consider a 2D simulation running with 21 MPI ranks - 7 along the <em>x</em> direction, and 3 along the <em>y</em> direction, as shown in the following figure: </p>
<div align="center">
<img src="nd_ranks.png" alt="nd_ranks.png"/>
</div>
  The boldface number in the parentheses is the n-dimensional rank (n=2), while the number below it in normal typeface is the 1D rank, corresponding to the rank in the MPI communicator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iproc</em>&nbsp;</td><td>Integer array whose elements are the number of MPI ranks along each dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ip</em>&nbsp;</td><td>Integer array whose elements are the rank of this process along each dimension </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00175_source.html#l00026">26</a> of file <a class="el" href="a00175_source.html">MPIRank1D.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00031"></a>00031 {
<a name="l00032"></a>00032   <span class="keywordtype">int</span> i,rank = 0, term = 1;
<a name="l00033"></a>00033   <span class="keywordflow">for</span> (i=0; i&lt;ndims; i++) {
<a name="l00034"></a>00034     rank += (ip[i]*term);
<a name="l00035"></a>00035     term *= iproc[i];
<a name="l00036"></a>00036   }
<a name="l00037"></a>00037   
<a name="l00038"></a>00038   <span class="keywordflow">return</span>(rank);
<a name="l00039"></a>00039 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="afe59a0480bb81cc0d7877ba547b3e28c"></a><!-- doxytag: member="mpivars.h::MPIRanknD" ref="afe59a0480bb81cc0d7877ba547b3e28c" args="(int, int, int *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MPIRanknD </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>iproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>ip</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the n-dimensional rank from the 1D rank</p>
<p>This function computes the n-dimensional rank, given the 1D rank and the total number of MPI ranks along each spatial dimension.</p>
<p><b>1D</b> <b>Rank:</b> This is the rank of the process in the communicator.<br/>
 <b>n-Dimensional</b> <b>Rank:</b> This represents an integer array, where each element is the rank of the process along a spatial dimension.</p>
<p>Consider a 2D simulation running with 21 MPI ranks - 7 along the <em>x</em> direction, and 3 along the <em>y</em> direction, as shown in the following figure: </p>
<div align="center">
<img src="nd_ranks.png" alt="nd_ranks.png"/>
</div>
  The boldface number in the parentheses is the n-dimensional rank (n=2), while the number below it in normal typeface is the 1D rank, corresponding to the rank in the MPI communicator.</p>
<p>Note: + the array to hold the computed n-dimensional rank must be preallocated and the size must be equal to the number of spatial dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rank</em>&nbsp;</td><td>1D rank </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iproc</em>&nbsp;</td><td>Integer array whose elements are the number of MPI ranks along each dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ip</em>&nbsp;</td><td>Integer array whose elements are the rank of this process along each dimesion </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00176_source.html#l00027">27</a> of file <a class="el" href="a00176_source.html">MPIRanknD.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00033"></a>00033 {
<a name="l00034"></a>00034   <span class="keywordtype">int</span> i,term    = 1;
<a name="l00035"></a>00035   <span class="keywordflow">for</span> (i=0; i&lt;ndims; i++) term *= iproc[i];
<a name="l00036"></a>00036   <span class="keywordflow">for</span> (i=ndims-1; i&gt;=0; i--) {
<a name="l00037"></a>00037     term /= iproc[i];
<a name="l00038"></a>00038     ip[i] = rank/term;
<a name="l00039"></a>00039     rank -= ip[i]*term;
<a name="l00040"></a>00040   }
<a name="l00041"></a>00041   <span class="keywordflow">return</span>(0);
<a name="l00042"></a>00042 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad9bc49863d543b6251903e9150c46a9c"></a><!-- doxytag: member="mpivars.h::MPIGetFilename" ref="ad9bc49863d543b6251903e9150c46a9c" args="(char *, void *, char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPIGetFilename </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>filename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a unique filename given the rank of the process to let that process write to its own file</p>
<p>Get a string representing a filename indexed by the MPI rank: <em>filename</em> = <em><a class="el" href="a00031.html#a3c3f941ca00d3a46c402ac279bc0b44e">root.index</a></em>, where <em>index</em> is the string corresponding to the MPI rank. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>filename root </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>MPI communicator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>filename </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00167_source.html#l00020">20</a> of file <a class="el" href="a00167_source.html">MPIGetFilename.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00025"></a>00025 {
<a name="l00026"></a>00026   <span class="keywordtype">char</span>  tail[<a class="code" href="a00036.html#a51efea86a4d76d1259893f606b776573">_MAX_STRING_SIZE_</a>]=<span class="stringliteral">&quot;&quot;</span>;
<a name="l00027"></a>00027   <span class="keywordtype">int</span>   rank;
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#ifndef serial</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>  MPI_Comm  comm = *((MPI_Comm*)c);
<a name="l00031"></a>00031   MPI_Comm_rank(comm,&amp;rank);
<a name="l00032"></a>00032 <span class="preprocessor">#else</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>  rank = 0;
<a name="l00034"></a>00034 <span class="preprocessor">#endif</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036   <a class="code" href="a00167.html#a3e3ad5aed581d9ae563190c365dadc41">GetStringFromInteger</a>(rank,tail,4);
<a name="l00037"></a>00037   strcpy(filename,<span class="stringliteral">&quot;&quot;</span>);
<a name="l00038"></a>00038   strcat(filename,root);
<a name="l00039"></a>00039   strcat(filename,<span class="stringliteral">&quot;.&quot;</span> );
<a name="l00040"></a>00040   strcat(filename,tail);
<a name="l00041"></a>00041 
<a name="l00042"></a>00042   <span class="keywordflow">return</span>;
<a name="l00043"></a>00043 }
</pre></div></p>

</div>
</div>
</div>
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=10897352; 
var sc_invisible=1; 
var sc_security="83042f57"; 
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
target="_blank"><img class="statcounter"
src="//c.statcounter.com/10897352/0/83042f57/1/"
alt="website statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
