<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>HyPar: include/boundaryconditions.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>include/boundaryconditions.h File Reference</h1>
<p>Containts the structures and definitions for boundary condition implementation.  
<a href="#_details">More...</a></p>
<code>#include &lt;<a class="el" href="a00036_source.html">basic.h</a>&gt;</code><br/>

<p><a href="a00037_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">DomainBoundary</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure containing the variables and function pointers defining a boundary.  <a href="a00004.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a65ffa4253dee762c65092abcf04ecdee">_PERIODIC_</a>&nbsp;&nbsp;&nbsp;&quot;periodic&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a53da239cc00a2394faa0637dad4d0a0c">_EXTRAPOLATE_</a>&nbsp;&nbsp;&nbsp;&quot;extrapolate&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a7b8553c8fd765568f7355cf32b93b20d">_DIRICHLET_</a>&nbsp;&nbsp;&nbsp;&quot;dirichlet&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a5838171ba57a2dd67065aafce7ff97ac">_REFLECT_</a>&nbsp;&nbsp;&nbsp;&quot;reflect&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#ab02c004c9707df0589311375014dc666">_SPONGE_</a>&nbsp;&nbsp;&nbsp;&quot;sponge&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#affb6a9c452f92435e738bd59b9c98935">_NOSLIP_WALL_</a>&nbsp;&nbsp;&nbsp;&quot;noslip-wall&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#af3a9f3ba15bc914ed0a88295aee147e8">_SLIP_WALL_</a>&nbsp;&nbsp;&nbsp;&quot;slip-wall&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a1fb5767ea5e8c4f48969ff25eae1ddaf">_THERMAL_SLIP_WALL_</a>&nbsp;&nbsp;&nbsp;&quot;slip-wall&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#adba2024137894c96339af50efabe3771">_SUBSONIC_INFLOW_</a>&nbsp;&nbsp;&nbsp;&quot;subsonic-inflow&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#adeb38801d1b832ce3eee3ebc1eed6263">_SUBSONIC_OUTFLOW_</a>&nbsp;&nbsp;&nbsp;&quot;subsonic-outflow&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#aac7250bf34e60e7df688d3cf7355855c">_SUBSONIC_AMBIVALENT_</a>&nbsp;&nbsp;&nbsp;&quot;subsonic-ambivalent&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a5c9f9f3c97682664b0fe253e10863b57">_SUPERSONIC_INFLOW_</a>&nbsp;&nbsp;&nbsp;&quot;supersonic-inflow&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a5a9ba63c6c48e0831e379e03a72c0047">_SUPERSONIC_OUTFLOW_</a>&nbsp;&nbsp;&nbsp;&quot;supersonic-outflow&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a9b20b4f17d0f550f5da42946cc8a5b4a">_TURBULENT_SUPERSONIC_INFLOW_</a>&nbsp;&nbsp;&nbsp;&quot;turbulent-supersonic-inflow&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#af6add2fbe449fa25b80c01abd7564574">_NO_FLUX_BC_</a>&nbsp;&nbsp;&nbsp;&quot;numa-nfbc&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a6cd5a586de4ae1a3b73884d62f76bdee">_SW_SLIP_WALL_</a>&nbsp;&nbsp;&nbsp;&quot;shallow-water-slip-wall&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#ab8248be9e215df26dfce851b1acc54ec">_SW_NOSLIP_WALL_</a>&nbsp;&nbsp;&nbsp;&quot;shallow-water-noslip-wall&quot;</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#ac12085fd970427feca33543fd1257b15">BCInitialize</a> (void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#af38bba62aa7b0f51ee9123ced0c46f24">BCCleanup</a> (void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a760f1362e8f287b242b3cd869668f2e9">BCPeriodicU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#aec11d279de28af8bc36e9462485aedbd">BCExtrapolateU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#ad9d2689e44a644319a6cc72249c68e49">BCDirichletU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a9a0a6df7b555f4eea004e79de223abf8">BCReflectU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#ae8b2fd391e2c966afad4c4910eff0ffc">BCNoslipWallU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#aba3141eae84ed7f5b2cadefdcc207173">BCSlipWallU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a30077b675efd008f1cd3bc0e1f0692a3">BCThermalSlipWallU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a1fa2ad192d85d7f6e958f845d151af10">BCSubsonicInflowU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a59d7e501f46ad50d2649895a715fe370">BCSubsonicOutflowU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a83bc6c5b45955f8ebe750503f5987a29">BCSubsonicAmbivalentU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a51cb1555c54105533ae5668cf5ea8a68">BCSupersonicInflowU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#aeceb8d75046193135c6277bf1bf342bd">BCSupersonicOutflowU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#aad04621186800a19145dcf024fbccc3e">BCTurbulentSupersonicInflowU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#adb156eee1d509ee6500ffe20dce7811d">BCNoFluxU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a6904fb76cd1fe7638108e1ffdcf1a6ad">BCSWSlipWallU</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#aa45ae833314d982b2b6a23607a6237cf">BCPeriodicDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#ab57c71ca185a63df8ead47c95e4edcf6">BCExtrapolateDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#ac949632b08cc43923ffbbcf2b8709b5c">BCDirichletDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a0f35d7a8360f2d4753123c310b6a7e03">BCReflectDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a87c158d41f942f279dcb48785beadd79">BCNoslipWallDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#af5d89bbb4eba90663c3c30c02b663079">BCSlipWallDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a768e1128cb2a39574b8661602cc96562">BCThermalSlipWallDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a7de01f99b34e0a3e80b77792a5eca37c">BCSubsonicInflowDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a10fe02e6453d8b7240db5c3dce265163">BCSubsonicOutflowDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a96b73ed205d556b08dd5514c2905bf66">BCSubsonicAmbivalentDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a2538a6891effbefee21c5b12ab0d81d2">BCSupersonicInflowDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a82faba0d89e0acc186928eac58633c8d">BCSupersonicOutflowDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#af6c34fe934e480e03af70dcb3493fa32">BCTurbulentSupersonicInflowDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a25e802a3f547e50a24af84001d917e76">BCNoFluxDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a3413b894a0aeb980868260c11b5e9bb5">BCSWSlipWallDU</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a49368bf44f300143cd9ec18d10b37a23">BCSpongeSource</a> (void *, int, int, int, int *, double *, double *, double *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a88f1e5079fc6c8b753e77cc85c21cb5b">BCSpongeUDummy</a> (void *, void *, int, int, int *, int, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a22b20fb04eb1b36dcff22fbc58150f20">BCSpongeDUDummy</a> (void *, void *, int, int, int *, int, double *, double *, double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html#a6cc369236fbfe94bff52c55175cfaba7">BCReadTurbulentInflowData</a> (void *, void *, int, int, int *)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Containts the structures and definitions for boundary condition implementation. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Debojyoti Ghosh </dd></dl>

<p>Definition in file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a65ffa4253dee762c65092abcf04ecdee"></a><!-- doxytag: member="boundaryconditions.h::_PERIODIC_" ref="a65ffa4253dee762c65092abcf04ecdee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _PERIODIC_&nbsp;&nbsp;&nbsp;&quot;periodic&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Periodic boundary conditions </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00075.html#ae7c327565752b28cc8313423478efc92">BCPeriodicU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00009">9</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a53da239cc00a2394faa0637dad4d0a0c"></a><!-- doxytag: member="boundaryconditions.h::_EXTRAPOLATE_" ref="a53da239cc00a2394faa0637dad4d0a0c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _EXTRAPOLATE_&nbsp;&nbsp;&nbsp;&quot;extrapolate&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extrapolative boundary conditions (values at ghost cells are copied from interior) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00071.html#ae25dbd294ea08dc2b5c5bfcdaab0cdfc">BCExtrapolateU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00011">11</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7b8553c8fd765568f7355cf32b93b20d"></a><!-- doxytag: member="boundaryconditions.h::_DIRICHLET_" ref="a7b8553c8fd765568f7355cf32b93b20d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _DIRICHLET_&nbsp;&nbsp;&nbsp;&quot;dirichlet&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dirichlet boundary conditions (values at ghost cells specified through input) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00070.html#aff556c3ed9f4a947436d47c58ea5983e">BCDirichletU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00013">13</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5838171ba57a2dd67065aafce7ff97ac"></a><!-- doxytag: member="boundaryconditions.h::_REFLECT_" ref="a5838171ba57a2dd67065aafce7ff97ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _REFLECT_&nbsp;&nbsp;&nbsp;&quot;reflect&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reflective boundary conditions (values at ghost cells negative of interior) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00076.html#a262943d07ca8e576f79b36846a43e103">BCReflectU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00015">15</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab02c004c9707df0589311375014dc666"></a><!-- doxytag: member="boundaryconditions.h::_SPONGE_" ref="ab02c004c9707df0589311375014dc666" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SPONGE_&nbsp;&nbsp;&nbsp;&quot;sponge&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sponge boundary conditions </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00078.html#a2d82f4205eff408d6cd66cf08c2ed5d6">BCSpongeSource</a>, <a class="el" href="a00078.html#ac58466ec027b61b9f3b23cf2940041da">BCSpongeUDummy</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00017">17</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="affb6a9c452f92435e738bd59b9c98935"></a><!-- doxytag: member="boundaryconditions.h::_NOSLIP_WALL_" ref="affb6a9c452f92435e738bd59b9c98935" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _NOSLIP_WALL_&nbsp;&nbsp;&nbsp;&quot;noslip-wall&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Viscous wall boundary condition (specific to Navier-Stokes) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00074.html#a1384d5e7d1060dea6c26b2aa8988c47b">BCNoslipWallU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00021">21</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="af3a9f3ba15bc914ed0a88295aee147e8"></a><!-- doxytag: member="boundaryconditions.h::_SLIP_WALL_" ref="af3a9f3ba15bc914ed0a88295aee147e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SLIP_WALL_&nbsp;&nbsp;&nbsp;&quot;slip-wall&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inviscid wall boundary condition (specific to Euler/Navier-Stokes) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00077.html#abdeb4e91e1441a25130cb2d3a1be09b0">BCSlipWallU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00023">23</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1fb5767ea5e8c4f48969ff25eae1ddaf"></a><!-- doxytag: member="boundaryconditions.h::_THERMAL_SLIP_WALL_" ref="a1fb5767ea5e8c4f48969ff25eae1ddaf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _THERMAL_SLIP_WALL_&nbsp;&nbsp;&nbsp;&quot;slip-wall&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inviscid thermal wall boundary condition where wall temperature is specified (specific to Euler/Navier-Stokes) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00085.html#ad95232382b3a4969eb8e2212e00f032a">BCThermalSlipWallU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00025">25</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="adba2024137894c96339af50efabe3771"></a><!-- doxytag: member="boundaryconditions.h::_SUBSONIC_INFLOW_" ref="adba2024137894c96339af50efabe3771" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SUBSONIC_INFLOW_&nbsp;&nbsp;&nbsp;&quot;subsonic-inflow&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subsonic inflow boundary condition: density and velocity are specified in the input, pressure is extrapolated from the interior (specific to Euler/Navier-Stokes) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00080.html#a9c5eb47fb65476896445cc90ec945312">BCSubsonicInflowU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00027">27</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="adeb38801d1b832ce3eee3ebc1eed6263"></a><!-- doxytag: member="boundaryconditions.h::_SUBSONIC_OUTFLOW_" ref="adeb38801d1b832ce3eee3ebc1eed6263" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SUBSONIC_OUTFLOW_&nbsp;&nbsp;&nbsp;&quot;subsonic-outflow&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subsonic outflow boundary condition: pressure is specified in the input, density and velocity are extrapolated from the interior (specific to Euler/Navier-Stokes) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00081.html#aea51db89a0a00f1c9b8288f9ebc059c6">BCSubsonicOutflowU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00029">29</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac7250bf34e60e7df688d3cf7355855c"></a><!-- doxytag: member="boundaryconditions.h::_SUBSONIC_AMBIVALENT_" ref="aac7250bf34e60e7df688d3cf7355855c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SUBSONIC_AMBIVALENT_&nbsp;&nbsp;&nbsp;&quot;subsonic-ambivalent&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subsonic "ambivalent" boundary condition: (specific to Euler/Navier-Stokes) the velocity at the boundary is extrapolated from the interior, and based on that, either subsonic outflow or inflow boundary conditions are applied. Specify all flow quantities (density, velocity, and pressure) in the input; depending on whether it is inflow or outflow, the appropriate quantities will be used. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00079.html#aa06b35b07659fa413f72a90372e325d0">BCSubsonicAmbivalentU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00034">34</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5c9f9f3c97682664b0fe253e10863b57"></a><!-- doxytag: member="boundaryconditions.h::_SUPERSONIC_INFLOW_" ref="a5c9f9f3c97682664b0fe253e10863b57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SUPERSONIC_INFLOW_&nbsp;&nbsp;&nbsp;&quot;supersonic-inflow&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supersonic inflow boundary condition: density, velocity, and pressure are specified in the input (specific to Euler/Navier-Stokes) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00082.html#a27201c4605999bdb8b84e8e19426de85">BCSupersonicInflowU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00036">36</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5a9ba63c6c48e0831e379e03a72c0047"></a><!-- doxytag: member="boundaryconditions.h::_SUPERSONIC_OUTFLOW_" ref="a5a9ba63c6c48e0831e379e03a72c0047" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SUPERSONIC_OUTFLOW_&nbsp;&nbsp;&nbsp;&quot;supersonic-outflow&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supersonic outflow boundary condition: all flow quantities are extrapolated from the interior (specific to Euler/Navier-Stokes) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00083.html#a791e37fae3c9489d0fc039102c57409e">BCSupersonicOutflowU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00038">38</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9b20b4f17d0f550f5da42946cc8a5b4a"></a><!-- doxytag: member="boundaryconditions.h::_TURBULENT_SUPERSONIC_INFLOW_" ref="a9b20b4f17d0f550f5da42946cc8a5b4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _TURBULENT_SUPERSONIC_INFLOW_&nbsp;&nbsp;&nbsp;&quot;turbulent-supersonic-inflow&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Turbulent, supersonic inflow boundary condition: density, velocity, and pressure are specified in the input, along with turbulent fluctuations (specific to Euler/Navier-Stokes) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00086.html#aff45ce4055fde7a8f9579686e8e08d82">BCTurbulentSupersonicInflowU</a>, <a class="el" href="a00086.html#ae90485b7beacc863180d194634c9e6d5">BCReadTurbulentInflowData</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00040">40</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="af6add2fbe449fa25b80c01abd7564574"></a><!-- doxytag: member="boundaryconditions.h::_NO_FLUX_BC_" ref="af6add2fbe449fa25b80c01abd7564574" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _NO_FLUX_BC_&nbsp;&nbsp;&nbsp;&quot;numa-nfbc&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>No-flux boundary condition (specific to NUMA) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00073.html#a47f15d0ef1040bf42b53bd882d612b54">BCNoFluxU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00044">44</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6cd5a586de4ae1a3b73884d62f76bdee"></a><!-- doxytag: member="boundaryconditions.h::_SW_SLIP_WALL_" ref="a6cd5a586de4ae1a3b73884d62f76bdee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SW_SLIP_WALL_&nbsp;&nbsp;&nbsp;&quot;shallow-water-slip-wall&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Slip boundary condition (specific to shallow water equations) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00084.html#a7cffeb6ede7dbf886b8970fd0d584961">BCSWSlipWallU</a> </dd></dl>

<p>Definition at line <a class="el" href="a00037_source.html#l00048">48</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab8248be9e215df26dfce851b1acc54ec"></a><!-- doxytag: member="boundaryconditions.h::_SW_NOSLIP_WALL_" ref="ab8248be9e215df26dfce851b1acc54ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SW_NOSLIP_WALL_&nbsp;&nbsp;&nbsp;&quot;shallow-water-noslip-wall&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Viscous wall boundary condition (specific to shallow water equations) (not implemented yet) </p>

<p>Definition at line <a class="el" href="a00037_source.html#l00050">50</a> of file <a class="el" href="a00037_source.html">boundaryconditions.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac12085fd970427feca33543fd1257b15"></a><!-- doxytag: member="boundaryconditions.h::BCInitialize" ref="ac12085fd970427feca33543fd1257b15" args="(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCInitialize </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function to initialize the boundary conditions</p>
<p>Assign the function pointers for boundary condition application depending on the boundary type, for a given boundary object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00072_source.html#l00012">12</a> of file <a class="el" href="a00072_source.html">BCInitialize.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00013"></a>00013 {
<a name="l00014"></a>00014   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00015"></a>00015 
<a name="l00016"></a>00016   <span class="keywordflow">if</span>      (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a65ffa4253dee762c65092abcf04ecdee">_PERIODIC_</a>                    )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#a760f1362e8f287b242b3cd869668f2e9">BCPeriodicU</a>;
<a name="l00017"></a>00017   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a53da239cc00a2394faa0637dad4d0a0c">_EXTRAPOLATE_</a>                 )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#aec11d279de28af8bc36e9462485aedbd">BCExtrapolateU</a>;
<a name="l00018"></a>00018   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a7b8553c8fd765568f7355cf32b93b20d">_DIRICHLET_</a>                   )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#ad9d2689e44a644319a6cc72249c68e49">BCDirichletU</a>;  
<a name="l00019"></a>00019   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a5838171ba57a2dd67065aafce7ff97ac">_REFLECT_</a>                     )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#a9a0a6df7b555f4eea004e79de223abf8">BCReflectU</a>;    
<a name="l00020"></a>00020   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#ab02c004c9707df0589311375014dc666">_SPONGE_</a>                      )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#a88f1e5079fc6c8b753e77cc85c21cb5b">BCSpongeUDummy</a>;    
<a name="l00021"></a>00021   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#affb6a9c452f92435e738bd59b9c98935">_NOSLIP_WALL_</a>                 )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#ae8b2fd391e2c966afad4c4910eff0ffc">BCNoslipWallU</a>;    
<a name="l00022"></a>00022   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#af3a9f3ba15bc914ed0a88295aee147e8">_SLIP_WALL_</a>                   )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#aba3141eae84ed7f5b2cadefdcc207173">BCSlipWallU</a>;    
<a name="l00023"></a>00023   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a6cd5a586de4ae1a3b73884d62f76bdee">_SW_SLIP_WALL_</a>                )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#a6904fb76cd1fe7638108e1ffdcf1a6ad">BCSWSlipWallU</a>;    
<a name="l00024"></a>00024   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#adeb38801d1b832ce3eee3ebc1eed6263">_SUBSONIC_OUTFLOW_</a>            )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#a59d7e501f46ad50d2649895a715fe370">BCSubsonicOutflowU</a>;    
<a name="l00025"></a>00025   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#adba2024137894c96339af50efabe3771">_SUBSONIC_INFLOW_</a>             )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#a1fa2ad192d85d7f6e958f845d151af10">BCSubsonicInflowU</a>;    
<a name="l00026"></a>00026   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#aac7250bf34e60e7df688d3cf7355855c">_SUBSONIC_AMBIVALENT_</a>         )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#a83bc6c5b45955f8ebe750503f5987a29">BCSubsonicAmbivalentU</a>;    
<a name="l00027"></a>00027   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a5a9ba63c6c48e0831e379e03a72c0047">_SUPERSONIC_OUTFLOW_</a>          )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#aeceb8d75046193135c6277bf1bf342bd">BCSupersonicOutflowU</a>;    
<a name="l00028"></a>00028   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a5c9f9f3c97682664b0fe253e10863b57">_SUPERSONIC_INFLOW_</a>           )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#a51cb1555c54105533ae5668cf5ea8a68">BCSupersonicInflowU</a>;    
<a name="l00029"></a>00029   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a9b20b4f17d0f550f5da42946cc8a5b4a">_TURBULENT_SUPERSONIC_INFLOW_</a> )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#aad04621186800a19145dcf024fbccc3e">BCTurbulentSupersonicInflowU</a>;    
<a name="l00030"></a>00030   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#af6add2fbe449fa25b80c01abd7564574">_NO_FLUX_BC_</a>                  )) boundary-&gt;<a class="code" href="a00004.html#ad74c432793b0da4841b50ee718ed556e">BCFunctionU</a> = <a class="code" href="a00037.html#adb156eee1d509ee6500ffe20dce7811d">BCNoFluxU</a>;    
<a name="l00031"></a>00031   <span class="keywordflow">else</span> {
<a name="l00032"></a>00032     fprintf(stderr,<span class="stringliteral">&quot;Error in BCInitialize(): \&quot;%s\&quot; is not a supported boundary condition.\n&quot;</span>,
<a name="l00033"></a>00033             boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>);
<a name="l00034"></a>00034     <span class="keywordflow">return</span>(1);
<a name="l00035"></a>00035   }
<a name="l00036"></a>00036 
<a name="l00037"></a>00037   <span class="keywordflow">if</span>      (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a65ffa4253dee762c65092abcf04ecdee">_PERIODIC_</a>                    )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#aa45ae833314d982b2b6a23607a6237cf">BCPeriodicDU</a>;
<a name="l00038"></a>00038   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a53da239cc00a2394faa0637dad4d0a0c">_EXTRAPOLATE_</a>                 )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#ab57c71ca185a63df8ead47c95e4edcf6">BCExtrapolateDU</a>;
<a name="l00039"></a>00039   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a7b8553c8fd765568f7355cf32b93b20d">_DIRICHLET_</a>                   )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#ac949632b08cc43923ffbbcf2b8709b5c">BCDirichletDU</a>;  
<a name="l00040"></a>00040   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a5838171ba57a2dd67065aafce7ff97ac">_REFLECT_</a>                     )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#a0f35d7a8360f2d4753123c310b6a7e03">BCReflectDU</a>;    
<a name="l00041"></a>00041   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#ab02c004c9707df0589311375014dc666">_SPONGE_</a>                      )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#a22b20fb04eb1b36dcff22fbc58150f20">BCSpongeDUDummy</a>;    
<a name="l00042"></a>00042   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#affb6a9c452f92435e738bd59b9c98935">_NOSLIP_WALL_</a>                 )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#a87c158d41f942f279dcb48785beadd79">BCNoslipWallDU</a>;    
<a name="l00043"></a>00043   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#af3a9f3ba15bc914ed0a88295aee147e8">_SLIP_WALL_</a>                   )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#af5d89bbb4eba90663c3c30c02b663079">BCSlipWallDU</a>;    
<a name="l00044"></a>00044   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a6cd5a586de4ae1a3b73884d62f76bdee">_SW_SLIP_WALL_</a>                )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#a3413b894a0aeb980868260c11b5e9bb5">BCSWSlipWallDU</a>;    
<a name="l00045"></a>00045   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#adeb38801d1b832ce3eee3ebc1eed6263">_SUBSONIC_OUTFLOW_</a>            )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#a10fe02e6453d8b7240db5c3dce265163">BCSubsonicOutflowDU</a>;    
<a name="l00046"></a>00046   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#adba2024137894c96339af50efabe3771">_SUBSONIC_INFLOW_</a>             )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#a7de01f99b34e0a3e80b77792a5eca37c">BCSubsonicInflowDU</a>;    
<a name="l00047"></a>00047   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#aac7250bf34e60e7df688d3cf7355855c">_SUBSONIC_AMBIVALENT_</a>         )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#a96b73ed205d556b08dd5514c2905bf66">BCSubsonicAmbivalentDU</a>;    
<a name="l00048"></a>00048   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a5a9ba63c6c48e0831e379e03a72c0047">_SUPERSONIC_OUTFLOW_</a>          )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#a82faba0d89e0acc186928eac58633c8d">BCSupersonicOutflowDU</a>;    
<a name="l00049"></a>00049   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a5c9f9f3c97682664b0fe253e10863b57">_SUPERSONIC_INFLOW_</a>           )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#a2538a6891effbefee21c5b12ab0d81d2">BCSupersonicInflowDU</a>;    
<a name="l00050"></a>00050   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#a9b20b4f17d0f550f5da42946cc8a5b4a">_TURBULENT_SUPERSONIC_INFLOW_</a> )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#af6c34fe934e480e03af70dcb3493fa32">BCTurbulentSupersonicInflowDU</a>;    
<a name="l00051"></a>00051   <span class="keywordflow">else</span> if (!strcmp(boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>,<a class="code" href="a00037.html#af6add2fbe449fa25b80c01abd7564574">_NO_FLUX_BC_</a>                  )) boundary-&gt;<a class="code" href="a00004.html#a219c68200ac455cf2ff14786ffe72ade">BCFunctionDU</a> = <a class="code" href="a00037.html#a25e802a3f547e50a24af84001d917e76">BCNoFluxDU</a>;    
<a name="l00052"></a>00052   <span class="keywordflow">else</span> {
<a name="l00053"></a>00053     fprintf(stderr,<span class="stringliteral">&quot;Error in BCInitialize(): \&quot;%s\&quot; is not a supported boundary condition.\n&quot;</span>,
<a name="l00054"></a>00054             boundary-&gt;<a class="code" href="a00004.html#a430ec6bfcdd38ab8e86545e25bc22613">bctype</a>);
<a name="l00055"></a>00055     <span class="keywordflow">return</span>(1);
<a name="l00056"></a>00056   }
<a name="l00057"></a>00057 
<a name="l00058"></a>00058   <span class="keywordflow">return</span>(0);
<a name="l00059"></a>00059 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af38bba62aa7b0f51ee9123ced0c46f24"></a><!-- doxytag: member="boundaryconditions.h::BCCleanup" ref="af38bba62aa7b0f51ee9123ced0c46f24" args="(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCCleanup </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function to clean up boundary conditions-related variables and arrays</p>
<p>Cleans up a boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00069_source.html#l00010">10</a> of file <a class="el" href="a00069_source.html">BCCleanup.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00011"></a>00011 {
<a name="l00012"></a>00012   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00013"></a>00013   free(boundary-&gt;<a class="code" href="a00004.html#a1e51e79041d5a3dddffb503277703568">xmin</a>);
<a name="l00014"></a>00014   free(boundary-&gt;<a class="code" href="a00004.html#a7ea24a733beddff902459a07bf91ca67">xmax</a>);
<a name="l00015"></a>00015   free(boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>);
<a name="l00016"></a>00016   free(boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>);
<a name="l00017"></a>00017   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a6aa65431c39a8d8177f35c338ddb7a0e">DirichletValue</a>) free(boundary-&gt;<a class="code" href="a00004.html#a6aa65431c39a8d8177f35c338ddb7a0e">DirichletValue</a>);
<a name="l00018"></a>00018   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#af7eeb4ff3f7c8bc22e0786ddbe62f16d">SpongeValue</a>   ) free(boundary-&gt;<a class="code" href="a00004.html#af7eeb4ff3f7c8bc22e0786ddbe62f16d">SpongeValue</a>   );
<a name="l00019"></a>00019   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>  ) free(boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>  );
<a name="l00020"></a>00020   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#ac3b478217419275ad063182f69cb543d">UnsteadyDirichletSize</a>) free(boundary-&gt;<a class="code" href="a00004.html#ac3b478217419275ad063182f69cb543d">UnsteadyDirichletSize</a>);
<a name="l00021"></a>00021   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a48f59fc59e6a86d0b4aad842daea9106">UnsteadyDirichletData</a>) free(boundary-&gt;<a class="code" href="a00004.html#a48f59fc59e6a86d0b4aad842daea9106">UnsteadyDirichletData</a>);
<a name="l00022"></a>00022   <span class="keywordflow">return</span>(0);
<a name="l00023"></a>00023 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a760f1362e8f287b242b3cd869668f2e9"></a><!-- doxytag: member="boundaryconditions.h::BCPeriodicU" ref="a760f1362e8f287b242b3cd869668f2e9" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCPeriodicU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Periodic boundary conditions for the solution vector U</p>
<p>Applies periodic boundary conditions: Implemented by copying the solution from the other end of the domain into the physical boundary ghost points. <br/>
<br/>
 Note**: This function only acts if the the number of processors is 1 along the spatial dimension this boundary corresponds to. If there are more than 1 processors along this dimension, periodicity is handled by <a class="el" href="a00045.html#a60ace5964c051fa481e6a1e6f1ef75d7">MPIExchangeBoundariesnD()</a> to minimize communication. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00075_source.html#l00019">19</a> of file <a class="el" href="a00075_source.html">BCPeriodic.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00029"></a>00029 {
<a name="l00030"></a>00030   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00031"></a>00031   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>   *mpi      = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*)   m;
<a name="l00032"></a>00032 
<a name="l00033"></a>00033   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00034"></a>00034   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036   <span class="keywordflow">if</span> ((boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) &amp;&amp; (mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dim] == 1)) {
<a name="l00037"></a>00037     <span class="keywordtype">int</span> bounds[ndims], index1[ndims], index2[ndims];
<a name="l00038"></a>00038     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00039"></a>00039     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index1,ndims,0);
<a name="l00040"></a>00040     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index2,ndims,0);
<a name="l00041"></a>00041     <span class="keywordtype">int</span> done = 0;
<a name="l00042"></a>00042     <span class="keywordflow">while</span> (!done) {
<a name="l00043"></a>00043       <span class="keywordtype">int</span> p1 = 0, p2 = 0;
<a name="l00044"></a>00044       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index1,index2,ndims);
<a name="l00045"></a>00045       <span class="keywordflow">if</span> (face == 1) {
<a name="l00046"></a>00046         index2[dim] = index1[dim] + size[dim]-ghosts;
<a name="l00047"></a>00047         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,index1,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00048"></a>00048         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,index2,ghosts,p2);
<a name="l00049"></a>00049       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) {
<a name="l00050"></a>00050         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,index1,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00051"></a>00051         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,index1,ghosts,p2);
<a name="l00052"></a>00052       }
<a name="l00053"></a>00053       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((phi+nvars*p2),(phi+nvars*p1),nvars);
<a name="l00054"></a>00054       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,index1,done);
<a name="l00055"></a>00055     }
<a name="l00056"></a>00056   }
<a name="l00057"></a>00057   <span class="keywordflow">return</span>(0);
<a name="l00058"></a>00058 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aec11d279de28af8bc36e9462485aedbd"></a><!-- doxytag: member="boundaryconditions.h::BCExtrapolateU" ref="aec11d279de28af8bc36e9462485aedbd" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCExtrapolateU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>extrapolate boundary conditions for the solution vector U</p>
<p>Apply the extrapolative boundary condition: Values at the physical boundary ghost points are extrapolated from the interior points adjacent to the boundary </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00071_source.html#l00013">13</a> of file <a class="el" href="a00071_source.html">BCExtrapolate.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00023"></a>00023 {
<a name="l00024"></a>00024   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00025"></a>00025 
<a name="l00026"></a>00026   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00027"></a>00027   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00028"></a>00028 
<a name="l00029"></a>00029   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00030"></a>00030     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00031"></a>00031     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00032"></a>00032     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00033"></a>00033     <span class="keywordtype">int</span> done = 0;
<a name="l00034"></a>00034     <span class="keywordflow">while</span> (!done) {
<a name="l00035"></a>00035       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00036"></a>00036       <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00037"></a>00037       <span class="keywordflow">if</span> (face == 1)        indexi[dim] = ghosts-1-indexb[dim];
<a name="l00038"></a>00038       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1)  indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00039"></a>00039       <span class="keywordflow">else</span>                  <span class="keywordflow">return</span>(1);
<a name="l00040"></a>00040       <span class="keywordtype">int</span> p1,p2;
<a name="l00041"></a>00041       <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00042"></a>00042       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00043"></a>00043       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((phi+nvars*p2),(phi+nvars*p1),nvars);
<a name="l00044"></a>00044       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00045"></a>00045     }
<a name="l00046"></a>00046   }
<a name="l00047"></a>00047   <span class="keywordflow">return</span>(0);
<a name="l00048"></a>00048 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad9d2689e44a644319a6cc72249c68e49"></a><!-- doxytag: member="boundaryconditions.h::BCDirichletU" ref="ad9d2689e44a644319a6cc72249c68e49" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCDirichletU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dirichlet boundary conditions for the solution vector U</p>
<p>Applies (steady) Dirichlet boundary conditions for the solution: the ghost points at the physical boundaries are set to specified values </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00070_source.html#l00013">13</a> of file <a class="el" href="a00070_source.html">BCDirichlet.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00023"></a>00023 {
<a name="l00024"></a>00024   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00025"></a>00025 
<a name="l00026"></a>00026   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00027"></a>00027     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims];
<a name="l00028"></a>00028     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00029"></a>00029     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0); 
<a name="l00030"></a>00030     <span class="keywordtype">int</span> done = 0;
<a name="l00031"></a>00031     <span class="keywordflow">while</span> (!done) {
<a name="l00032"></a>00032       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size  ,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p);
<a name="l00033"></a>00033       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((boundary-&gt;<a class="code" href="a00004.html#a6aa65431c39a8d8177f35c338ddb7a0e">DirichletValue</a>),(phi+nvars*p),nvars);
<a name="l00034"></a>00034       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00035"></a>00035     }
<a name="l00036"></a>00036   }
<a name="l00037"></a>00037   <span class="keywordflow">return</span>(0);
<a name="l00038"></a>00038 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9a0a6df7b555f4eea004e79de223abf8"></a><!-- doxytag: member="boundaryconditions.h::BCReflectU" ref="a9a0a6df7b555f4eea004e79de223abf8" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCReflectU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reflection boundary conditions for the solution vector U</p>
<p>Applies the reflection boundary condition: The values at the physical boundary ghost points are set to the negative of the interior values adjacent to the boundary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00076_source.html#l00014">14</a> of file <a class="el" href="a00076_source.html">BCReflect.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00024"></a>00024 {
<a name="l00025"></a>00025   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00026"></a>00026 
<a name="l00027"></a>00027   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00028"></a>00028   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00029"></a>00029 
<a name="l00030"></a>00030   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00031"></a>00031     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00032"></a>00032     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00033"></a>00033     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00034"></a>00034     <span class="keywordtype">int</span> done = 0;
<a name="l00035"></a>00035     <span class="keywordflow">while</span> (!done) {
<a name="l00036"></a>00036       <span class="keywordtype">int</span> p1, p2;
<a name="l00037"></a>00037       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00038"></a>00038       <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00039"></a>00039       <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00040"></a>00040       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00041"></a>00041       <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00042"></a>00042       <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00043"></a>00043       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00044"></a>00044       <a class="code" href="a00034.html#a7d97d4914726fa7cca339356dae28473">_ArrayScaleCopy1D_</a>((phi+nvars*p2),(-1.0),(phi+nvars*p1),nvars);
<a name="l00045"></a>00045       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00046"></a>00046     }
<a name="l00047"></a>00047   }
<a name="l00048"></a>00048   <span class="keywordflow">return</span>(0);
<a name="l00049"></a>00049 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae8b2fd391e2c966afad4c4910eff0ffc"></a><!-- doxytag: member="boundaryconditions.h::BCNoslipWallU" ref="ae8b2fd391e2c966afad4c4910eff0ffc" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCNoslipWallU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>No-slip wall (viscous) boundary conditions for the solution vector U</p>
<p>Applies the no-slip wall boundary conditions: Used to simulate viscous walls. The density and pressure at the physical boundary ghost points are extrapolated from the interior, while the velocities are set such that the interpolated velocity at the boundary face is the specified wall velocity. This boundary condition is specific to the two and three dimensional Navier-Stokes systems (<a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00074_source.html#l00020">20</a> of file <a class="el" href="a00074_source.html">BCNoslipWall.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00030"></a>00030 {
<a name="l00031"></a>00031   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00032"></a>00032 
<a name="l00033"></a>00033   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00034"></a>00034   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036   <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00037"></a>00037 
<a name="l00038"></a>00038     <span class="comment">/* create a fake physics object */</span>
<a name="l00039"></a>00039     <a class="code" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a> physics; 
<a name="l00040"></a>00040     <span class="keywordtype">double</span> gamma;
<a name="l00041"></a>00041     gamma = physics.<a class="code" href="a00021.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00042"></a>00042     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00043"></a>00043 
<a name="l00044"></a>00044     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00045"></a>00045       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00046"></a>00046       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00047"></a>00047       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00048"></a>00048       <span class="keywordtype">int</span> done = 0;
<a name="l00049"></a>00049       <span class="keywordflow">while</span> (!done) {
<a name="l00050"></a>00050         <span class="keywordtype">int</span> p1, p2;
<a name="l00051"></a>00051         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00052"></a>00052         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00053"></a>00053         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00054"></a>00054         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00055"></a>00055         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00056"></a>00056         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00057"></a>00057         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00058"></a>00058         
<a name="l00059"></a>00059         <span class="comment">/* flow variables in the interior */</span>
<a name="l00060"></a>00060         <span class="keywordtype">double</span> rho, uvel, vvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00061"></a>00061         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00062"></a>00062         <a class="code" href="a00054.html#a90ce369a1f9d490ab6d392a996e5be4c">_NavierStokes2DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00063"></a>00063         <span class="comment">/* set the ghost point values */</span>
<a name="l00064"></a>00064         rho_gpt = rho;
<a name="l00065"></a>00065         pressure_gpt = pressure;
<a name="l00066"></a>00066         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0] - uvel;
<a name="l00067"></a>00067         vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1] - vvel;
<a name="l00068"></a>00068         energy_gpt = inv_gamma_m1*pressure_gpt
<a name="l00069"></a>00069                     + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00070"></a>00070 
<a name="l00071"></a>00071         phi[nvars*p1+0] = rho_gpt;
<a name="l00072"></a>00072         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00073"></a>00073         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00074"></a>00074         phi[nvars*p1+3] = energy_gpt;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00077"></a>00077       }
<a name="l00078"></a>00078     }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="comment">/* create a fake physics object */</span>
<a name="l00083"></a>00083     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics;
<a name="l00084"></a>00084     <span class="keywordtype">double</span> gamma;
<a name="l00085"></a>00085     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00086"></a>00086     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00089"></a>00089       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00090"></a>00090       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00091"></a>00091       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00092"></a>00092       <span class="keywordtype">int</span> done = 0;
<a name="l00093"></a>00093       <span class="keywordflow">while</span> (!done) {
<a name="l00094"></a>00094         <span class="keywordtype">int</span> p1, p2;
<a name="l00095"></a>00095         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00096"></a>00096         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00097"></a>00097         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00098"></a>00098         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00099"></a>00099         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00100"></a>00100         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00101"></a>00101         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00102"></a>00102         
<a name="l00103"></a>00103         <span class="comment">/* flow variables in the interior */</span>
<a name="l00104"></a>00104         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00105"></a>00105         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00106"></a>00106         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00107"></a>00107         <span class="comment">/* set the ghost point values */</span>
<a name="l00108"></a>00108         rho_gpt = rho;
<a name="l00109"></a>00109         pressure_gpt = pressure;
<a name="l00110"></a>00110         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0] - uvel;
<a name="l00111"></a>00111         vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1] - vvel;
<a name="l00112"></a>00112         wvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[2] - wvel;
<a name="l00113"></a>00113         energy_gpt = inv_gamma_m1*pressure_gpt
<a name="l00114"></a>00114                     + 0.5 * rho_gpt 
<a name="l00115"></a>00115                     * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117         phi[nvars*p1+0] = rho_gpt;
<a name="l00118"></a>00118         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00119"></a>00119         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00120"></a>00120         phi[nvars*p1+3] = rho_gpt * wvel_gpt;
<a name="l00121"></a>00121         phi[nvars*p1+4] = energy_gpt;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00124"></a>00124       }
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   }
<a name="l00128"></a>00128   <span class="keywordflow">return</span>(0);
<a name="l00129"></a>00129 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aba3141eae84ed7f5b2cadefdcc207173"></a><!-- doxytag: member="boundaryconditions.h::BCSlipWallU" ref="aba3141eae84ed7f5b2cadefdcc207173" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSlipWallU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Slip (inviscid) wall boundary conditions for the solution vector U</p>
<p>Applies the slip-wall boundary condition: This is specific to the two and three dimensional Euler and Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). It is used for simulating inviscid walls or symmetric boundaries. The pressure, density, and tangential velocity at the ghost points are extrapolated from the interior, while the normal velocity at the ghost points is set such that the interpolated value at the boundary face is equal to the specified wall velocity. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00077_source.html#l00022">22</a> of file <a class="el" href="a00077_source.html">BCSlipWall.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00032"></a>00032 {
<a name="l00033"></a>00033   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00036"></a>00036   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038   <span class="keywordflow">if</span> (ndims == 1) {
<a name="l00039"></a>00039 
<a name="l00040"></a>00040     <span class="comment">/* create a fake physics object */</span>
<a name="l00041"></a>00041     <a class="code" href="a00005.html" title="Structure containing variables and parameters specific to the 1D Euler equations...">Euler1D</a> physics; 
<a name="l00042"></a>00042     <span class="keywordtype">double</span> gamma; 
<a name="l00043"></a>00043     gamma = physics.<a class="code" href="a00005.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00044"></a>00044     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00047"></a>00047       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00048"></a>00048       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00049"></a>00049       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00050"></a>00050       <span class="keywordtype">int</span> done = 0;
<a name="l00051"></a>00051       <span class="keywordflow">while</span> (!done) {
<a name="l00052"></a>00052         <span class="keywordtype">int</span> p1, p2;
<a name="l00053"></a>00053         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00054"></a>00054         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00055"></a>00055         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00056"></a>00056         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00057"></a>00057         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00058"></a>00058         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00059"></a>00059         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00060"></a>00060         
<a name="l00061"></a>00061         <span class="comment">/* flow variables in the interior */</span>
<a name="l00062"></a>00062         <span class="keywordtype">double</span> rho, uvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00063"></a>00063         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, energy_gpt, pressure_gpt;
<a name="l00064"></a>00064         <a class="code" href="a00047.html#af35510fb1477577f57c57cc2a862b1e7">_Euler1DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,energy,pressure,(&amp;physics));
<a name="l00065"></a>00065         <span class="comment">/* set the ghost point values */</span>
<a name="l00066"></a>00066         rho_gpt = rho;
<a name="l00067"></a>00067         pressure_gpt = pressure;
<a name="l00068"></a>00068         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00069"></a>00069         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00070"></a>00070                     + 0.5 * rho_gpt * uvel_gpt*uvel_gpt;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072         phi[nvars*p1+0] = rho_gpt;
<a name="l00073"></a>00073         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00074"></a>00074         phi[nvars*p1+2] = energy_gpt;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00077"></a>00077       }
<a name="l00078"></a>00078     }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="comment">/* create a fake physics object */</span>
<a name="l00083"></a>00083     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00084"></a>00084     <span class="keywordtype">double</span> gamma; 
<a name="l00085"></a>00085     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00086"></a>00086     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00089"></a>00089       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00090"></a>00090       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00091"></a>00091       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00092"></a>00092       <span class="keywordtype">int</span> done = 0;
<a name="l00093"></a>00093       <span class="keywordflow">while</span> (!done) {
<a name="l00094"></a>00094         <span class="keywordtype">int</span> p1, p2;
<a name="l00095"></a>00095         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00096"></a>00096         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00097"></a>00097         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00098"></a>00098         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00099"></a>00099         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00100"></a>00100         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00101"></a>00101         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00102"></a>00102         
<a name="l00103"></a>00103         <span class="comment">/* flow variables in the interior */</span>
<a name="l00104"></a>00104         <span class="keywordtype">double</span> rho, uvel, vvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00105"></a>00105         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00106"></a>00106         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00107"></a>00107         <span class="comment">/* set the ghost point values */</span>
<a name="l00108"></a>00108         rho_gpt = rho;
<a name="l00109"></a>00109         pressure_gpt = pressure;
<a name="l00110"></a>00110         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00111"></a>00111           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00112"></a>00112           vvel_gpt = vvel;
<a name="l00113"></a>00113         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00114"></a>00114           uvel_gpt = uvel;
<a name="l00115"></a>00115           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00116"></a>00116         } <span class="keywordflow">else</span> {
<a name="l00117"></a>00117           uvel_gpt = 0.0;
<a name="l00118"></a>00118           vvel_gpt = 0.0;
<a name="l00119"></a>00119         }
<a name="l00120"></a>00120         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00121"></a>00121                     + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00122"></a>00122 
<a name="l00123"></a>00123         phi[nvars*p1+0] = rho_gpt;
<a name="l00124"></a>00124         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00125"></a>00125         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00126"></a>00126         phi[nvars*p1+3] = energy_gpt;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00129"></a>00129       }
<a name="l00130"></a>00130     }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     <span class="comment">/* create a fake physics object */</span>
<a name="l00135"></a>00135     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics; 
<a name="l00136"></a>00136     <span class="keywordtype">double</span> gamma; 
<a name="l00137"></a>00137     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00138"></a>00138     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00141"></a>00141       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00142"></a>00142       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00143"></a>00143       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00144"></a>00144       <span class="keywordtype">int</span> done = 0;
<a name="l00145"></a>00145       <span class="keywordflow">while</span> (!done) {
<a name="l00146"></a>00146         <span class="keywordtype">int</span> p1, p2;
<a name="l00147"></a>00147         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00148"></a>00148         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00149"></a>00149         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00150"></a>00150         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00151"></a>00151         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00152"></a>00152         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00153"></a>00153         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00154"></a>00154         
<a name="l00155"></a>00155         <span class="comment">/* flow variables in the interior */</span>
<a name="l00156"></a>00156         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, pressure;
<a name="l00157"></a>00157         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00158"></a>00158         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00159"></a>00159         <span class="comment">/* set the ghost point values */</span>
<a name="l00160"></a>00160         rho_gpt = rho;
<a name="l00161"></a>00161         pressure_gpt = pressure;
<a name="l00162"></a>00162         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00163"></a>00163           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00164"></a>00164           vvel_gpt = vvel;
<a name="l00165"></a>00165           wvel_gpt = wvel;
<a name="l00166"></a>00166         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00167"></a>00167           uvel_gpt = uvel;
<a name="l00168"></a>00168           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00169"></a>00169           wvel_gpt = wvel;
<a name="l00170"></a>00170         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>) {
<a name="l00171"></a>00171           uvel_gpt = uvel;
<a name="l00172"></a>00172           vvel_gpt = vvel;
<a name="l00173"></a>00173           wvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>] - wvel;
<a name="l00174"></a>00174         } <span class="keywordflow">else</span> {
<a name="l00175"></a>00175           uvel_gpt = 0.0;
<a name="l00176"></a>00176           vvel_gpt = 0.0;
<a name="l00177"></a>00177           wvel_gpt = 0.0;
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00180"></a>00180                     + 0.5 * rho_gpt 
<a name="l00181"></a>00181                     * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183         phi[nvars*p1+0] = rho_gpt;
<a name="l00184"></a>00184         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00185"></a>00185         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00186"></a>00186         phi[nvars*p1+3] = rho_gpt * wvel_gpt;
<a name="l00187"></a>00187         phi[nvars*p1+4] = energy_gpt;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00190"></a>00190       }
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   }
<a name="l00194"></a>00194   <span class="keywordflow">return</span>(0);
<a name="l00195"></a>00195 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a30077b675efd008f1cd3bc0e1f0692a3"></a><!-- doxytag: member="boundaryconditions.h::BCThermalSlipWallU" ref="a30077b675efd008f1cd3bc0e1f0692a3" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCThermalSlipWallU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Slip (inviscid) thermal wall boundary conditions for the solution vector U</p>
<p>Applies the thermal slip-wall boundary condition: This is specific to the two and three dimensional Euler and Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). It is used for simulating inviscid walls or symmetric boundaries, where the temperature is specified. The density and the tangential velocity at the ghost points are extrapolated for the interior. The normal velocity at the ghost points is set such that the interpolated velocity at the boundary face is the specified wall velocity. The pressure at the ghost points is set by multiplying the extrapolated density by the specified temperature.</p>
<p><b>Note:</b> It is assumed that the temperature already contains the gas constant factor, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>., <img class="formulaInl" alt="$ T = P/\rho$" src="form_100.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00085_source.html#l00026">26</a> of file <a class="el" href="a00085_source.html">BCThermalSlipWall.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00036"></a>00036 {
<a name="l00037"></a>00037   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00038"></a>00038 
<a name="l00039"></a>00039   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00040"></a>00040   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00041"></a>00041 
<a name="l00042"></a>00042   <span class="keywordflow">if</span> (ndims == 1) {
<a name="l00043"></a>00043 
<a name="l00044"></a>00044     <span class="comment">/* create a fake physics object */</span>
<a name="l00045"></a>00045     <a class="code" href="a00005.html" title="Structure containing variables and parameters specific to the 1D Euler equations...">Euler1D</a> physics; 
<a name="l00046"></a>00046     <span class="keywordtype">double</span> gamma; 
<a name="l00047"></a>00047     gamma = physics.<a class="code" href="a00005.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00048"></a>00048     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00051"></a>00051       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00052"></a>00052       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00053"></a>00053       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00054"></a>00054       <span class="keywordtype">int</span> done = 0;
<a name="l00055"></a>00055       <span class="keywordflow">while</span> (!done) {
<a name="l00056"></a>00056         <span class="keywordtype">int</span> p1, p2;
<a name="l00057"></a>00057         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00058"></a>00058         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00059"></a>00059         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00060"></a>00060         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00061"></a>00061         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00062"></a>00062         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00063"></a>00063         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00064"></a>00064         
<a name="l00065"></a>00065         <span class="comment">/* flow variables in the interior */</span>
<a name="l00066"></a>00066         <span class="keywordtype">double</span> rho, uvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00067"></a>00067         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, energy_gpt, pressure_gpt;
<a name="l00068"></a>00068         <a class="code" href="a00047.html#af35510fb1477577f57c57cc2a862b1e7">_Euler1DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,energy,pressure,(&amp;physics));
<a name="l00069"></a>00069         <span class="comment">/* set the ghost point values */</span>
<a name="l00070"></a>00070         rho_gpt = rho;
<a name="l00071"></a>00071         pressure_gpt = pressure;
<a name="l00072"></a>00072         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00073"></a>00073         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00074"></a>00074                     + 0.5 * rho_gpt * uvel_gpt*uvel_gpt;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         phi[nvars*p1+0] = rho_gpt;
<a name="l00077"></a>00077         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00078"></a>00078         phi[nvars*p1+2] = energy_gpt;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00081"></a>00081       }
<a name="l00082"></a>00082     }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00085"></a>00085 
<a name="l00086"></a>00086     <span class="comment">/* create a fake physics object */</span>
<a name="l00087"></a>00087     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00088"></a>00088     <span class="keywordtype">double</span> gamma; 
<a name="l00089"></a>00089     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00090"></a>00090     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00093"></a>00093       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00094"></a>00094       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00095"></a>00095       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00096"></a>00096       <span class="keywordtype">int</span> done = 0;
<a name="l00097"></a>00097       <span class="keywordflow">while</span> (!done) {
<a name="l00098"></a>00098         <span class="keywordtype">int</span> p1, p2;
<a name="l00099"></a>00099         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00100"></a>00100         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00101"></a>00101         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00102"></a>00102         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00103"></a>00103         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00104"></a>00104         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00105"></a>00105         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00106"></a>00106         
<a name="l00107"></a>00107         <span class="comment">/* flow variables in the interior */</span>
<a name="l00108"></a>00108         <span class="keywordtype">double</span> rho, uvel, vvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00109"></a>00109         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00110"></a>00110         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00111"></a>00111         <span class="comment">/* set the ghost point values */</span>
<a name="l00112"></a>00112         rho_gpt = rho;
<a name="l00113"></a>00113         pressure_gpt = pressure;
<a name="l00114"></a>00114         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00115"></a>00115           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00116"></a>00116           vvel_gpt = vvel;
<a name="l00117"></a>00117         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00118"></a>00118           uvel_gpt = uvel;
<a name="l00119"></a>00119           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00120"></a>00120         } <span class="keywordflow">else</span> {
<a name="l00121"></a>00121           uvel_gpt = 0.0;
<a name="l00122"></a>00122           vvel_gpt = 0.0;
<a name="l00123"></a>00123         }
<a name="l00124"></a>00124         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00125"></a>00125                     + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         phi[nvars*p1+0] = rho_gpt;
<a name="l00128"></a>00128         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00129"></a>00129         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00130"></a>00130         phi[nvars*p1+3] = energy_gpt;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00133"></a>00133       }
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135 
<a name="l00136"></a>00136   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     <span class="comment">/* create a fake physics object */</span>
<a name="l00139"></a>00139     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics; 
<a name="l00140"></a>00140     <span class="keywordtype">double</span> gamma; 
<a name="l00141"></a>00141     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00142"></a>00142     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00145"></a>00145       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00146"></a>00146       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00147"></a>00147       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00148"></a>00148       <span class="keywordtype">int</span> done = 0;
<a name="l00149"></a>00149       <span class="keywordflow">while</span> (!done) {
<a name="l00150"></a>00150         <span class="keywordtype">int</span> p1, p2;
<a name="l00151"></a>00151         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00152"></a>00152         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00153"></a>00153         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00154"></a>00154         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00155"></a>00155         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00156"></a>00156         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00157"></a>00157         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00158"></a>00158         
<a name="l00159"></a>00159         <span class="comment">/* flow variables in the interior */</span>
<a name="l00160"></a>00160         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, pressure;
<a name="l00161"></a>00161         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00162"></a>00162         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00163"></a>00163         <span class="comment">/* set the ghost point values */</span>
<a name="l00164"></a>00164         rho_gpt = rho;
<a name="l00165"></a>00165         pressure_gpt = pressure;
<a name="l00166"></a>00166         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00167"></a>00167           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00168"></a>00168           vvel_gpt = vvel;
<a name="l00169"></a>00169           wvel_gpt = wvel;
<a name="l00170"></a>00170         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00171"></a>00171           uvel_gpt = uvel;
<a name="l00172"></a>00172           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00173"></a>00173           wvel_gpt = wvel;
<a name="l00174"></a>00174         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>) {
<a name="l00175"></a>00175           uvel_gpt = uvel;
<a name="l00176"></a>00176           vvel_gpt = vvel;
<a name="l00177"></a>00177           wvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>] - wvel;
<a name="l00178"></a>00178         } <span class="keywordflow">else</span> {
<a name="l00179"></a>00179           uvel_gpt = 0.0;
<a name="l00180"></a>00180           vvel_gpt = 0.0;
<a name="l00181"></a>00181           wvel_gpt = 0.0;
<a name="l00182"></a>00182         }
<a name="l00183"></a>00183         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00184"></a>00184                     + 0.5 * rho_gpt 
<a name="l00185"></a>00185                     * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         phi[nvars*p1+0] = rho_gpt;
<a name="l00188"></a>00188         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00189"></a>00189         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00190"></a>00190         phi[nvars*p1+3] = rho_gpt * wvel_gpt;
<a name="l00191"></a>00191         phi[nvars*p1+4] = energy_gpt;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00194"></a>00194       }
<a name="l00195"></a>00195     }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   }
<a name="l00198"></a>00198   <span class="keywordflow">return</span>(0);
<a name="l00199"></a>00199 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1fa2ad192d85d7f6e958f845d151af10"></a><!-- doxytag: member="boundaryconditions.h::BCSubsonicInflowU" ref="a1fa2ad192d85d7f6e958f845d151af10" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSubsonicInflowU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subsonic inflow boundary conditions for the solution vector U</p>
<p>Applies the subsonic inflow boundary condition: The density and velocity at the physical boundary ghost points are specified, while the pressure is extrapolated from the interior of the domain. This boundary condition is specific to two and three dimension Euler and Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00080_source.html#l00020">20</a> of file <a class="el" href="a00080_source.html">BCSubsonicInflow.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00030"></a>00030 {
<a name="l00031"></a>00031   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00032"></a>00032 
<a name="l00033"></a>00033   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00034"></a>00034   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036   <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00037"></a>00037 
<a name="l00038"></a>00038     <span class="comment">/* create a fake physics object */</span>
<a name="l00039"></a>00039     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00040"></a>00040     <span class="keywordtype">double</span> gamma;
<a name="l00041"></a>00041     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00042"></a>00042     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00043"></a>00043 
<a name="l00044"></a>00044     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00045"></a>00045       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00046"></a>00046       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00047"></a>00047       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00048"></a>00048       <span class="keywordtype">int</span> done = 0;
<a name="l00049"></a>00049       <span class="keywordflow">while</span> (!done) {
<a name="l00050"></a>00050         <span class="keywordtype">int</span> p1, p2;
<a name="l00051"></a>00051         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00052"></a>00052         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00053"></a>00053         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00054"></a>00054         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00055"></a>00055         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00056"></a>00056         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00057"></a>00057         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00058"></a>00058         
<a name="l00059"></a>00059         <span class="comment">/* flow variables in the interior */</span>
<a name="l00060"></a>00060         <span class="keywordtype">double</span> rho, uvel, vvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00061"></a>00061         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00062"></a>00062         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00063"></a>00063         <span class="comment">/* set the ghost point values */</span>
<a name="l00064"></a>00064         rho_gpt = boundary-&gt;<a class="code" href="a00004.html#aa92ee9d8efc5ca49f4a83d8dabf0b15d">FlowDensity</a>;
<a name="l00065"></a>00065         pressure_gpt = pressure;
<a name="l00066"></a>00066         uvel_gpt = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0];
<a name="l00067"></a>00067         vvel_gpt = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1];
<a name="l00068"></a>00068         energy_gpt = inv_gamma_m1*pressure_gpt
<a name="l00069"></a>00069                     + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00070"></a>00070 
<a name="l00071"></a>00071         phi[nvars*p1+0] = rho_gpt;
<a name="l00072"></a>00072         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00073"></a>00073         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00074"></a>00074         phi[nvars*p1+3] = energy_gpt;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00077"></a>00077       }
<a name="l00078"></a>00078     }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="comment">/* create a fake physics object */</span>
<a name="l00083"></a>00083     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics;
<a name="l00084"></a>00084     <span class="keywordtype">double</span> gamma;
<a name="l00085"></a>00085     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00086"></a>00086     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00089"></a>00089       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00090"></a>00090       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00091"></a>00091       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00092"></a>00092       <span class="keywordtype">int</span> done = 0;
<a name="l00093"></a>00093       <span class="keywordflow">while</span> (!done) {
<a name="l00094"></a>00094         <span class="keywordtype">int</span> p1, p2;
<a name="l00095"></a>00095         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00096"></a>00096         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00097"></a>00097         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00098"></a>00098         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00099"></a>00099         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00100"></a>00100         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00101"></a>00101         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00102"></a>00102         
<a name="l00103"></a>00103         <span class="comment">/* flow variables in the interior */</span>
<a name="l00104"></a>00104         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00105"></a>00105         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00106"></a>00106         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00107"></a>00107         <span class="comment">/* set the ghost point values */</span>
<a name="l00108"></a>00108         rho_gpt = boundary-&gt;<a class="code" href="a00004.html#aa92ee9d8efc5ca49f4a83d8dabf0b15d">FlowDensity</a>;
<a name="l00109"></a>00109         pressure_gpt = pressure;
<a name="l00110"></a>00110         uvel_gpt = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0];
<a name="l00111"></a>00111         vvel_gpt = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1];
<a name="l00112"></a>00112         wvel_gpt = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[2];
<a name="l00113"></a>00113         energy_gpt = inv_gamma_m1*pressure_gpt
<a name="l00114"></a>00114                     + 0.5 * rho_gpt 
<a name="l00115"></a>00115                     * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117         phi[nvars*p1+0] = rho_gpt;
<a name="l00118"></a>00118         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00119"></a>00119         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00120"></a>00120         phi[nvars*p1+3] = rho_gpt * wvel_gpt;
<a name="l00121"></a>00121         phi[nvars*p1+4] = energy_gpt;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00124"></a>00124       }
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   }
<a name="l00128"></a>00128   <span class="keywordflow">return</span>(0);
<a name="l00129"></a>00129 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a59d7e501f46ad50d2649895a715fe370"></a><!-- doxytag: member="boundaryconditions.h::BCSubsonicOutflowU" ref="a59d7e501f46ad50d2649895a715fe370" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSubsonicOutflowU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subsonic outflow boundary conditions for the solution vector U</p>
<p>Applies the subsonic outflow boundary condition: The pressure at the physical boundary ghost points is specified, while the density and velocity are extrapolated from the interior. This boundary condition is specific to two and three dimensional Euler/ Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00081_source.html#l00019">19</a> of file <a class="el" href="a00081_source.html">BCSubsonicOutflow.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00029"></a>00029 {
<a name="l00030"></a>00030   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00031"></a>00031 
<a name="l00032"></a>00032   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00033"></a>00033   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035   <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00036"></a>00036 
<a name="l00037"></a>00037     <span class="comment">/* create a fake physics object */</span>
<a name="l00038"></a>00038     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00039"></a>00039     <span class="keywordtype">double</span> gamma;
<a name="l00040"></a>00040     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00041"></a>00041     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00042"></a>00042 
<a name="l00043"></a>00043     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00044"></a>00044       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00045"></a>00045       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00046"></a>00046       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00047"></a>00047       <span class="keywordtype">int</span> done = 0;
<a name="l00048"></a>00048       <span class="keywordflow">while</span> (!done) {
<a name="l00049"></a>00049         <span class="keywordtype">int</span> p1, p2;
<a name="l00050"></a>00050         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00051"></a>00051         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00052"></a>00052         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00053"></a>00053         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00054"></a>00054         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00055"></a>00055         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00056"></a>00056         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00057"></a>00057         
<a name="l00058"></a>00058         <span class="comment">/* flow variables in the interior */</span>
<a name="l00059"></a>00059         <span class="keywordtype">double</span> rho, uvel, vvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00060"></a>00060         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00061"></a>00061         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00062"></a>00062         <span class="comment">/* set the ghost point values */</span>
<a name="l00063"></a>00063         rho_gpt = rho;
<a name="l00064"></a>00064         pressure_gpt = pressure; <span class="comment">/* useless statement to avoid compiler warning */</span>
<a name="l00065"></a>00065         pressure_gpt = boundary-&gt;<a class="code" href="a00004.html#a0a3c5af6bdb8fbdb746fd4edb374bb18">FlowPressure</a>;
<a name="l00066"></a>00066         uvel_gpt = uvel;
<a name="l00067"></a>00067         vvel_gpt = vvel;
<a name="l00068"></a>00068         energy_gpt = inv_gamma_m1*pressure_gpt
<a name="l00069"></a>00069                     + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00070"></a>00070 
<a name="l00071"></a>00071         phi[nvars*p1+0] = rho_gpt;
<a name="l00072"></a>00072         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00073"></a>00073         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00074"></a>00074         phi[nvars*p1+3] = energy_gpt;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00077"></a>00077       }
<a name="l00078"></a>00078     }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="comment">/* create a fake physics object */</span>
<a name="l00083"></a>00083     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics;
<a name="l00084"></a>00084     <span class="keywordtype">double</span> gamma;
<a name="l00085"></a>00085     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00086"></a>00086     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00089"></a>00089       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00090"></a>00090       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00091"></a>00091       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00092"></a>00092       <span class="keywordtype">int</span> done = 0;
<a name="l00093"></a>00093       <span class="keywordflow">while</span> (!done) {
<a name="l00094"></a>00094         <span class="keywordtype">int</span> p1, p2;
<a name="l00095"></a>00095         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00096"></a>00096         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00097"></a>00097         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00098"></a>00098         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00099"></a>00099         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00100"></a>00100         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00101"></a>00101         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00102"></a>00102         
<a name="l00103"></a>00103         <span class="comment">/* flow variables in the interior */</span>
<a name="l00104"></a>00104         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00105"></a>00105         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00106"></a>00106         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00107"></a>00107         <span class="comment">/* set the ghost point values */</span>
<a name="l00108"></a>00108         rho_gpt = rho;
<a name="l00109"></a>00109         pressure_gpt = pressure; <span class="comment">/* useless statement to avoid compiler warning */</span>
<a name="l00110"></a>00110         pressure_gpt = boundary-&gt;<a class="code" href="a00004.html#a0a3c5af6bdb8fbdb746fd4edb374bb18">FlowPressure</a>;
<a name="l00111"></a>00111         uvel_gpt = uvel;
<a name="l00112"></a>00112         vvel_gpt = vvel;
<a name="l00113"></a>00113         wvel_gpt = wvel;
<a name="l00114"></a>00114         energy_gpt = inv_gamma_m1*pressure_gpt
<a name="l00115"></a>00115                     + 0.5 * rho_gpt 
<a name="l00116"></a>00116                     * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118         phi[nvars*p1+0] = rho_gpt;
<a name="l00119"></a>00119         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00120"></a>00120         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00121"></a>00121         phi[nvars*p1+3] = rho_gpt * wvel_gpt;
<a name="l00122"></a>00122         phi[nvars*p1+4] = energy_gpt;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00125"></a>00125       }
<a name="l00126"></a>00126     }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128   }
<a name="l00129"></a>00129   <span class="keywordflow">return</span>(0);
<a name="l00130"></a>00130 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a83bc6c5b45955f8ebe750503f5987a29"></a><!-- doxytag: member="boundaryconditions.h::BCSubsonicAmbivalentU" ref="a83bc6c5b45955f8ebe750503f5987a29" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSubsonicAmbivalentU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subsonic "ambivalent" boundary conditions for the solution vector U</p>
<p>Applies the subsonic "ambivalent" boundary condition: The velocity at the boundary face is extrapolated from the interior and its dot product with the boundary normal (pointing into the domain) is computed. + If it is positive, subsonic inflow boundary conditions are applied: the density and velocity at the physical boundary ghost points are specified, while the pressure is extrapolated from the interior of the domain. + If it is negative, subsonic outflow boundary conditions are applied: the pressure at the physical boundary ghost points is specified, while the density and velocity are extrapolated from the interior.</p>
<p>This boundary condition is specific to two and three dimension Euler and Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00079_source.html#l00028">28</a> of file <a class="el" href="a00079_source.html">BCSubsonicAmbivalent.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00038"></a>00038 {
<a name="l00039"></a>00039   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00042"></a>00042   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044   <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <span class="comment">/* create a fake physics object */</span>
<a name="l00047"></a>00047     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00048"></a>00048     <span class="keywordtype">double</span> gamma;
<a name="l00049"></a>00049     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00050"></a>00050     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00051"></a>00051 
<a name="l00052"></a>00052     <span class="comment">/* boundary normal (pointing into the domain) */</span>
<a name="l00053"></a>00053     <span class="keywordtype">double</span> nx, ny;
<a name="l00054"></a>00054     <span class="keywordflow">if</span> (dim == 0) {
<a name="l00055"></a>00055       nx = 1.0;
<a name="l00056"></a>00056       ny = 0.0;
<a name="l00057"></a>00057     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == 1) {
<a name="l00058"></a>00058       nx = 0.0;
<a name="l00059"></a>00059       ny = 1.0;
<a name="l00060"></a>00060     }
<a name="l00061"></a>00061     nx *= (double) face;
<a name="l00062"></a>00062     ny *= (double) face;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00065"></a>00065       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims], indexj[ndims];
<a name="l00066"></a>00066       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00067"></a>00067       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00068"></a>00068       <span class="keywordtype">int</span> done = 0;
<a name="l00069"></a>00069       <span class="keywordflow">while</span> (!done) {
<a name="l00070"></a>00070         <span class="keywordtype">int</span> p1, p2;
<a name="l00071"></a>00071         <span class="keywordtype">double</span> rho, uvel, vvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073         <span class="comment">/* compute boundary face velocity  - 2nd order */</span>
<a name="l00074"></a>00074         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00075"></a>00075         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00076"></a>00076         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexi,indexj,ndims);
<a name="l00077"></a>00077         <span class="keywordflow">if</span> (face ==  1) {
<a name="l00078"></a>00078           indexi[dim] = 0;
<a name="l00079"></a>00079           indexj[dim] = indexi[dim] + 1;
<a name="l00080"></a>00080         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) {
<a name="l00081"></a>00081           indexi[dim] = size[dim]-1;
<a name="l00082"></a>00082           indexj[dim] = indexi[dim] - 1;
<a name="l00083"></a>00083         }
<a name="l00084"></a>00084         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p1);
<a name="l00085"></a>00085         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexj,ghosts,p2);
<a name="l00086"></a>00086         <span class="keywordtype">double</span> uvel1, uvel2, uvelb,
<a name="l00087"></a>00087                vvel1, vvel2, vvelb;
<a name="l00088"></a>00088         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi+nvars*p1),rho,uvel1,vvel1,energy,pressure,(&amp;physics));
<a name="l00089"></a>00089         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi+nvars*p2),rho,uvel2,vvel2,energy,pressure,(&amp;physics));
<a name="l00090"></a>00090         uvelb = 1.5*uvel1 - 0.5*uvel2;
<a name="l00091"></a>00091         vvelb = 1.5*vvel1 - 0.5*vvel2;
<a name="l00092"></a>00092         <span class="keywordtype">double</span> vel_normal = uvelb*nx + vvelb*ny;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00095"></a>00095         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00096"></a>00096         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00097"></a>00097         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00098"></a>00098         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00099"></a>00099         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00100"></a>00100         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00101"></a>00101         
<a name="l00102"></a>00102         <span class="comment">/* flow variables in the interior */</span>
<a name="l00103"></a>00103         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         <span class="comment">/* set the ghost point values */</span>
<a name="l00106"></a>00106         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00107"></a>00107         <span class="keywordflow">if</span> (vel_normal &gt; 0) {
<a name="l00108"></a>00108           <span class="comment">/* inflow */</span>
<a name="l00109"></a>00109           rho_gpt = boundary-&gt;<a class="code" href="a00004.html#aa92ee9d8efc5ca49f4a83d8dabf0b15d">FlowDensity</a>;
<a name="l00110"></a>00110           pressure_gpt = pressure;
<a name="l00111"></a>00111           uvel_gpt = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0];
<a name="l00112"></a>00112           vvel_gpt = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1];
<a name="l00113"></a>00113         } <span class="keywordflow">else</span> {
<a name="l00114"></a>00114           <span class="comment">/* outflow */</span>
<a name="l00115"></a>00115           rho_gpt = rho;
<a name="l00116"></a>00116           pressure_gpt = boundary-&gt;<a class="code" href="a00004.html#a0a3c5af6bdb8fbdb746fd4edb374bb18">FlowPressure</a>;
<a name="l00117"></a>00117           uvel_gpt = uvel;
<a name="l00118"></a>00118           vvel_gpt = vvel;
<a name="l00119"></a>00119         }
<a name="l00120"></a>00120         energy_gpt = inv_gamma_m1*pressure_gpt
<a name="l00121"></a>00121                     + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00122"></a>00122 
<a name="l00123"></a>00123         phi[nvars*p1+0] = rho_gpt;
<a name="l00124"></a>00124         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00125"></a>00125         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00126"></a>00126         phi[nvars*p1+3] = energy_gpt;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00129"></a>00129       }
<a name="l00130"></a>00130     }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     <span class="comment">/* create a fake physics object */</span>
<a name="l00135"></a>00135     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics;
<a name="l00136"></a>00136     <span class="keywordtype">double</span> gamma;
<a name="l00137"></a>00137     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00138"></a>00138     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140     <span class="comment">/* boundary normal (pointing into the domain) */</span>
<a name="l00141"></a>00141     <span class="keywordtype">double</span> nx, ny, nz;
<a name="l00142"></a>00142     <span class="keywordflow">if</span> (dim == 0) {
<a name="l00143"></a>00143       nx = 1.0;
<a name="l00144"></a>00144       ny = 0.0;
<a name="l00145"></a>00145       nz = 0.0;
<a name="l00146"></a>00146     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == 1) {
<a name="l00147"></a>00147       nx = 0.0;
<a name="l00148"></a>00148       ny = 1.0;
<a name="l00149"></a>00149       nz = 0.0;
<a name="l00150"></a>00150     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == 2) {
<a name="l00151"></a>00151       nx = 0.0;
<a name="l00152"></a>00152       ny = 0.0;
<a name="l00153"></a>00153       nz = 1.0;
<a name="l00154"></a>00154     }
<a name="l00155"></a>00155     nx *= (double) face;
<a name="l00156"></a>00156     ny *= (double) face;
<a name="l00157"></a>00157     nz *= (double) face;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00160"></a>00160       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims], indexj[ndims];
<a name="l00161"></a>00161       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00162"></a>00162       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00163"></a>00163       <span class="keywordtype">int</span> done = 0;
<a name="l00164"></a>00164       <span class="keywordflow">while</span> (!done) {
<a name="l00165"></a>00165         <span class="keywordtype">int</span> p1, p2;
<a name="l00166"></a>00166         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, pressure;
<a name="l00167"></a>00167 
<a name="l00168"></a>00168         <span class="comment">/* compute boundary face velocity  - 2nd order */</span>
<a name="l00169"></a>00169         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00170"></a>00170         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00171"></a>00171         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexi,indexj,ndims);
<a name="l00172"></a>00172         <span class="keywordflow">if</span> (face ==  1) {
<a name="l00173"></a>00173           indexi[dim] = 0;
<a name="l00174"></a>00174           indexj[dim] = indexi[dim] + 1;
<a name="l00175"></a>00175         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) {
<a name="l00176"></a>00176           indexi[dim] = size[dim]-1;
<a name="l00177"></a>00177           indexj[dim] = indexi[dim] - 1;
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p1);
<a name="l00180"></a>00180         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexj,ghosts,p2);
<a name="l00181"></a>00181         <span class="keywordtype">double</span> uvel1, uvel2, uvelb,
<a name="l00182"></a>00182                vvel1, vvel2, vvelb,
<a name="l00183"></a>00183                wvel1, wvel2, wvelb;
<a name="l00184"></a>00184         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi+nvars*p1),rho,uvel1,vvel1,wvel1,energy,pressure,(&amp;physics));
<a name="l00185"></a>00185         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi+nvars*p2),rho,uvel2,vvel2,wvel2,energy,pressure,(&amp;physics));
<a name="l00186"></a>00186         uvelb = 1.5*uvel1 - 0.5*uvel2;
<a name="l00187"></a>00187         vvelb = 1.5*vvel1 - 0.5*vvel2;
<a name="l00188"></a>00188         wvelb = 1.5*wvel1 - 0.5*wvel2;
<a name="l00189"></a>00189         <span class="keywordtype">double</span> vel_normal = uvelb*nx + vvelb*ny + wvelb*nz;
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00192"></a>00192         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00193"></a>00193         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00194"></a>00194         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00195"></a>00195         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00196"></a>00196         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00197"></a>00197         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00198"></a>00198         
<a name="l00199"></a>00199         <span class="comment">/* flow variables in the interior */</span>
<a name="l00200"></a>00200         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="comment">/* set the ghost point values */</span>
<a name="l00203"></a>00203         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00204"></a>00204         <span class="keywordflow">if</span> (vel_normal &gt; 0) {
<a name="l00205"></a>00205           <span class="comment">/* inflow */</span>
<a name="l00206"></a>00206           rho_gpt = boundary-&gt;<a class="code" href="a00004.html#aa92ee9d8efc5ca49f4a83d8dabf0b15d">FlowDensity</a>;
<a name="l00207"></a>00207           pressure_gpt = pressure;
<a name="l00208"></a>00208           uvel_gpt = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0];
<a name="l00209"></a>00209           vvel_gpt = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1];
<a name="l00210"></a>00210           wvel_gpt = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[2];
<a name="l00211"></a>00211         } <span class="keywordflow">else</span> {
<a name="l00212"></a>00212           <span class="comment">/* outflow */</span>
<a name="l00213"></a>00213           rho_gpt = rho;
<a name="l00214"></a>00214           pressure_gpt = boundary-&gt;<a class="code" href="a00004.html#a0a3c5af6bdb8fbdb746fd4edb374bb18">FlowPressure</a>;
<a name="l00215"></a>00215           uvel_gpt = uvel;
<a name="l00216"></a>00216           vvel_gpt = vvel;
<a name="l00217"></a>00217           wvel_gpt = wvel;
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219         energy_gpt = inv_gamma_m1*pressure_gpt
<a name="l00220"></a>00220                     + 0.5 * rho_gpt 
<a name="l00221"></a>00221                     * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00222"></a>00222 
<a name="l00223"></a>00223         phi[nvars*p1+0] = rho_gpt;
<a name="l00224"></a>00224         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00225"></a>00225         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00226"></a>00226         phi[nvars*p1+3] = rho_gpt * wvel_gpt;
<a name="l00227"></a>00227         phi[nvars*p1+4] = energy_gpt;
<a name="l00228"></a>00228 
<a name="l00229"></a>00229         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00230"></a>00230       }
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233   }
<a name="l00234"></a>00234   <span class="keywordflow">return</span>(0);
<a name="l00235"></a>00235 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a51cb1555c54105533ae5668cf5ea8a68"></a><!-- doxytag: member="boundaryconditions.h::BCSupersonicInflowU" ref="a51cb1555c54105533ae5668cf5ea8a68" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSupersonicInflowU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supersonic inflow boundary conditions for the solution vector U</p>
<p>Applies the supersonic (steady) inflow boundary condition: All the flow variables (density, pressure, velocity) are specified at the physical boundary ghost points, since it is supersonic inflow. This boundary condition is specific to two and three dimensional Euler/Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). <br/>
<br/>
 Note: the Dirichlet boundary condition (<a class="el" href="a00037.html#a7b8553c8fd765568f7355cf32b93b20d">_DIRICHLET_</a>) could be used as well for supersonic inflow; however the specified Dirichlet state should be in terms of the conserved variables, while the specified supersonic inflow state here is in terms of the flow variables. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00082_source.html#l00024">24</a> of file <a class="el" href="a00082_source.html">BCSupersonicInflow.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00034"></a>00034 {
<a name="l00035"></a>00035   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00036"></a>00036 
<a name="l00037"></a>00037   <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00038"></a>00038 
<a name="l00039"></a>00039     <span class="keywordtype">double</span> gamma;
<a name="l00040"></a>00040     gamma = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00041"></a>00041     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00042"></a>00042 
<a name="l00043"></a>00043     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00044"></a>00044       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims];
<a name="l00045"></a>00045       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00046"></a>00046       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00047"></a>00047       <span class="keywordtype">int</span> done = 0;
<a name="l00048"></a>00048       <span class="keywordflow">while</span> (!done) {
<a name="l00049"></a>00049         <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00050"></a>00050         
<a name="l00051"></a>00051         <span class="comment">/* set the ghost point values */</span>
<a name="l00052"></a>00052         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00053"></a>00053         rho_gpt      = boundary-&gt;<a class="code" href="a00004.html#aa92ee9d8efc5ca49f4a83d8dabf0b15d">FlowDensity</a>;
<a name="l00054"></a>00054         pressure_gpt = boundary-&gt;<a class="code" href="a00004.html#a0a3c5af6bdb8fbdb746fd4edb374bb18">FlowPressure</a>;
<a name="l00055"></a>00055         uvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0];
<a name="l00056"></a>00056         vvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1];
<a name="l00057"></a>00057         energy_gpt   = inv_gamma_m1*pressure_gpt
<a name="l00058"></a>00058                        + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00059"></a>00059 
<a name="l00060"></a>00060         phi[nvars*p1+0] = rho_gpt;
<a name="l00061"></a>00061         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00062"></a>00062         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00063"></a>00063         phi[nvars*p1+3] = energy_gpt;
<a name="l00064"></a>00064 
<a name="l00065"></a>00065         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00066"></a>00066       }
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00070"></a>00070 
<a name="l00071"></a>00071     <span class="keywordtype">double</span> gamma;
<a name="l00072"></a>00072     gamma = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00073"></a>00073     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00074"></a>00074 
<a name="l00075"></a>00075     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00076"></a>00076       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims];
<a name="l00077"></a>00077       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00078"></a>00078       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00079"></a>00079       <span class="keywordtype">int</span> done = 0;
<a name="l00080"></a>00080       <span class="keywordflow">while</span> (!done) {
<a name="l00081"></a>00081         <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00082"></a>00082         
<a name="l00083"></a>00083         <span class="comment">/* set the ghost point values */</span>
<a name="l00084"></a>00084         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00085"></a>00085         rho_gpt      = boundary-&gt;<a class="code" href="a00004.html#aa92ee9d8efc5ca49f4a83d8dabf0b15d">FlowDensity</a>;
<a name="l00086"></a>00086         pressure_gpt = boundary-&gt;<a class="code" href="a00004.html#a0a3c5af6bdb8fbdb746fd4edb374bb18">FlowPressure</a>;
<a name="l00087"></a>00087         uvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0];
<a name="l00088"></a>00088         vvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1];
<a name="l00089"></a>00089         wvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[2];
<a name="l00090"></a>00090         energy_gpt   = inv_gamma_m1*pressure_gpt
<a name="l00091"></a>00091                        + 0.5 * rho_gpt 
<a name="l00092"></a>00092                        * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00093"></a>00093 
<a name="l00094"></a>00094         phi[nvars*p1+0] = rho_gpt;
<a name="l00095"></a>00095         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00096"></a>00096         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00097"></a>00097         phi[nvars*p1+3] = rho_gpt * wvel_gpt;
<a name="l00098"></a>00098         phi[nvars*p1+4] = energy_gpt;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00101"></a>00101       }
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   }
<a name="l00105"></a>00105   <span class="keywordflow">return</span>(0);
<a name="l00106"></a>00106 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aeceb8d75046193135c6277bf1bf342bd"></a><!-- doxytag: member="boundaryconditions.h::BCSupersonicOutflowU" ref="aeceb8d75046193135c6277bf1bf342bd" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSupersonicOutflowU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supersonic outflow boundary conditions for the solution vector U</p>
<p>Applies the supersonic outflow boundary condition: All flow variables (density, pressure, velocity) are extrapolated from the interior since the outflow is supersonic. This boundary condition is specific to two and three dimensional Euler/Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). <br/>
<br/>
 Note: The extrapolate boundary condition (<a class="el" href="a00037.html#a53da239cc00a2394faa0637dad4d0a0c">_EXTRAPOLATE_</a>) can be used as well for this boundary. I am not entirely sure why I wrote the code for this boundary in such a complicated fashion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00083_source.html#l00024">24</a> of file <a class="el" href="a00083_source.html">BCSupersonicOutflow.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00034"></a>00034 {
<a name="l00035"></a>00035   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00036"></a>00036 
<a name="l00037"></a>00037   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00038"></a>00038   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00039"></a>00039 
<a name="l00040"></a>00040   <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00041"></a>00041 
<a name="l00042"></a>00042     <span class="comment">/* create a fake physics object */</span>
<a name="l00043"></a>00043     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00044"></a>00044     <span class="keywordtype">double</span> gamma;
<a name="l00045"></a>00045     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00046"></a>00046     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00047"></a>00047 
<a name="l00048"></a>00048     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00049"></a>00049       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00050"></a>00050       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00051"></a>00051       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00052"></a>00052       <span class="keywordtype">int</span> done = 0;
<a name="l00053"></a>00053       <span class="keywordflow">while</span> (!done) {
<a name="l00054"></a>00054         <span class="keywordtype">int</span> p1, p2;
<a name="l00055"></a>00055         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00056"></a>00056         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00057"></a>00057         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00058"></a>00058         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00059"></a>00059         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00060"></a>00060         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00061"></a>00061         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00062"></a>00062         
<a name="l00063"></a>00063         <span class="comment">/* flow variables in the interior */</span>
<a name="l00064"></a>00064         <span class="keywordtype">double</span> rho, uvel, vvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00065"></a>00065         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00066"></a>00066         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00067"></a>00067         <span class="comment">/* set the ghost point values */</span>
<a name="l00068"></a>00068         rho_gpt       = rho;
<a name="l00069"></a>00069         pressure_gpt  = pressure;
<a name="l00070"></a>00070         uvel_gpt      = uvel;
<a name="l00071"></a>00071         vvel_gpt      = vvel;
<a name="l00072"></a>00072         energy_gpt    = inv_gamma_m1*pressure_gpt
<a name="l00073"></a>00073                         + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00074"></a>00074 
<a name="l00075"></a>00075         phi[nvars*p1+0] = rho_gpt;
<a name="l00076"></a>00076         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00077"></a>00077         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00078"></a>00078         phi[nvars*p1+3] = energy_gpt;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00081"></a>00081       }
<a name="l00082"></a>00082     }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00085"></a>00085 
<a name="l00086"></a>00086     <span class="comment">/* create a fake physics object */</span>
<a name="l00087"></a>00087     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics;
<a name="l00088"></a>00088     <span class="keywordtype">double</span> gamma;
<a name="l00089"></a>00089     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00090"></a>00090     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00093"></a>00093       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00094"></a>00094       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00095"></a>00095       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00096"></a>00096       <span class="keywordtype">int</span> done = 0;
<a name="l00097"></a>00097       <span class="keywordflow">while</span> (!done) {
<a name="l00098"></a>00098         <span class="keywordtype">int</span> p1, p2;
<a name="l00099"></a>00099         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00100"></a>00100         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00101"></a>00101         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00102"></a>00102         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00103"></a>00103         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00104"></a>00104         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00105"></a>00105         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00106"></a>00106         
<a name="l00107"></a>00107         <span class="comment">/* flow variables in the interior */</span>
<a name="l00108"></a>00108         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00109"></a>00109         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00110"></a>00110         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi+nvars*p2),rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00111"></a>00111         <span class="comment">/* set the ghost point values */</span>
<a name="l00112"></a>00112         rho_gpt       = rho;
<a name="l00113"></a>00113         pressure_gpt  = pressure;
<a name="l00114"></a>00114         uvel_gpt      = uvel;
<a name="l00115"></a>00115         vvel_gpt      = vvel;
<a name="l00116"></a>00116         wvel_gpt      = wvel;
<a name="l00117"></a>00117         energy_gpt    = inv_gamma_m1*pressure_gpt
<a name="l00118"></a>00118                         + 0.5 * rho_gpt 
<a name="l00119"></a>00119                         * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121         phi[nvars*p1+0] = rho_gpt;
<a name="l00122"></a>00122         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00123"></a>00123         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00124"></a>00124         phi[nvars*p1+3] = rho_gpt * wvel_gpt;
<a name="l00125"></a>00125         phi[nvars*p1+4] = energy_gpt;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00128"></a>00128       }
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131   }
<a name="l00132"></a>00132   <span class="keywordflow">return</span>(0);
<a name="l00133"></a>00133 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aad04621186800a19145dcf024fbccc3e"></a><!-- doxytag: member="boundaryconditions.h::BCTurbulentSupersonicInflowU" ref="aad04621186800a19145dcf024fbccc3e" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCTurbulentSupersonicInflowU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Turbulent Supersonic inflow boundary conditions for the solution vector U</p>
<p>Applies the turbulent supersonic inflow boundary condition: The inflow consists of a mean supersonic inflow on which turbulent flow fluctuations are added. This boundary condition is specific to the 3D Navier-Stokes system (<a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). <br/>
<br/>
 Note: Some parts of the code may be hardcoded for use with the shock-turbulence interaction problem (for which this boundary condition was written). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00086_source.html#l00021">21</a> of file <a class="el" href="a00086_source.html">BCTurbulentSupersonicInflow.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00031"></a>00031 {
<a name="l00032"></a>00032   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00033"></a>00033 
<a name="l00034"></a>00034   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036   <span class="keywordtype">double</span> *inflow_data = boundary-&gt;<a class="code" href="a00004.html#a48f59fc59e6a86d0b4aad842daea9106">UnsteadyDirichletData</a>;
<a name="l00037"></a>00037   <span class="keywordtype">int</span>    *inflow_size = boundary-&gt;<a class="code" href="a00004.html#ac3b478217419275ad063182f69cb543d">UnsteadyDirichletSize</a>;
<a name="l00038"></a>00038 
<a name="l00039"></a>00039   <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00040"></a>00040 
<a name="l00041"></a>00041     <span class="comment">/* create a fake physics object */</span>
<a name="l00042"></a>00042     <span class="keywordtype">double</span> gamma;
<a name="l00043"></a>00043     gamma = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00044"></a>00044     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00047"></a>00047       <span class="comment">/* the following bit is hardcoded for the inflow data</span>
<a name="l00048"></a>00048 <span class="comment">       * representing fluctuations in a domain of length 2pi */</span>
<a name="l00049"></a>00049       <span class="keywordtype">double</span>  xt = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[dim] * waqt;
<a name="l00050"></a>00050       <span class="keywordtype">int</span>     N  = inflow_size[dim];
<a name="l00051"></a>00051       <span class="keywordtype">double</span>  L  = 2.0 * (4.0*atan(1.0));
<a name="l00052"></a>00052       <span class="keywordtype">int</span>     it = ((int) ((xt/L) * ((double)N))) % N;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims];
<a name="l00055"></a>00055       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00056"></a>00056       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00057"></a>00057       <span class="keywordtype">int</span> done = 0;
<a name="l00058"></a>00058       <span class="keywordflow">while</span> (!done) {
<a name="l00059"></a>00059         <span class="keywordtype">int</span> p1; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00060"></a>00060         
<a name="l00061"></a>00061         <span class="comment">/* set the ghost point values - mean flow */</span>
<a name="l00062"></a>00062         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00063"></a>00063         rho_gpt      = boundary-&gt;<a class="code" href="a00004.html#aa92ee9d8efc5ca49f4a83d8dabf0b15d">FlowDensity</a>;
<a name="l00064"></a>00064         pressure_gpt = boundary-&gt;<a class="code" href="a00004.html#a0a3c5af6bdb8fbdb746fd4edb374bb18">FlowPressure</a>;
<a name="l00065"></a>00065         uvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0];
<a name="l00066"></a>00066         vvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1];
<a name="l00067"></a>00067         wvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[2];
<a name="l00068"></a>00068 
<a name="l00069"></a>00069         <span class="comment">/* calculate the turbulent fluctuations */</span>
<a name="l00070"></a>00070         <span class="keywordtype">double</span> duvel , dvvel , dwvel ;
<a name="l00071"></a>00071         <span class="keywordtype">int</span> index1[ndims]; <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,index1,ndims);
<a name="l00072"></a>00072         index1[dim] = it;
<a name="l00073"></a>00073         <span class="keywordtype">int</span> q; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,inflow_size,index1,0,q);
<a name="l00074"></a>00074         duvel = inflow_data[q*nvars+1];
<a name="l00075"></a>00075         dvvel = inflow_data[q*nvars+2];
<a name="l00076"></a>00076         dwvel = inflow_data[q*nvars+3];
<a name="l00077"></a>00077 
<a name="l00078"></a>00078         <span class="comment">/* add the turbulent fluctuations to the velocity field */</span>
<a name="l00079"></a>00079         uvel_gpt      += duvel;
<a name="l00080"></a>00080         vvel_gpt      += dvvel;
<a name="l00081"></a>00081         wvel_gpt      += dwvel;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083         <span class="comment">/* set the ghost point values */</span>
<a name="l00084"></a>00084         energy_gpt   = inv_gamma_m1*pressure_gpt
<a name="l00085"></a>00085                        + 0.5 * rho_gpt 
<a name="l00086"></a>00086                        * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00087"></a>00087         phi[nvars*p1+0] = rho_gpt;
<a name="l00088"></a>00088         phi[nvars*p1+1] = rho_gpt * uvel_gpt;
<a name="l00089"></a>00089         phi[nvars*p1+2] = rho_gpt * vvel_gpt;
<a name="l00090"></a>00090         phi[nvars*p1+3] = rho_gpt * wvel_gpt;
<a name="l00091"></a>00091         phi[nvars*p1+4] = energy_gpt;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00094"></a>00094       }
<a name="l00095"></a>00095     }
<a name="l00096"></a>00096 
<a name="l00097"></a>00097   }
<a name="l00098"></a>00098   <span class="keywordflow">return</span>(0);
<a name="l00099"></a>00099 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adb156eee1d509ee6500ffe20dce7811d"></a><!-- doxytag: member="boundaryconditions.h::BCNoFluxU" ref="adb156eee1d509ee6500ffe20dce7811d" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCNoFluxU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>No-Flux (inviscid wall) boundary conditions for the solution vector U</p>
<p>Applies the no-flux boundary conditions: This boundary condition is specific to the NUMA 2D/3D (<a class="el" href="a00023.html">Numa2D</a>, <a class="el" href="a00024.html">Numa3D</a>). Used for simulating inviscid walls or symmetry boundaries. It's equivalent to the slip-wall BC of the Euler/Navier- Stokes system.<br/>
<br/>
 The density, potential temperature, and tangential velocity are extrapolated, while the normal velocity at the ghost point is set to the negative of that in the interior (to enforce zero-normal velocity at the boundary face). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00073_source.html#l00022">22</a> of file <a class="el" href="a00073_source.html">BCNoFlux.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00032"></a>00032 {
<a name="l00033"></a>00033   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00036"></a>00036   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00039"></a>00039     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00040"></a>00040     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a> (bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00041"></a>00041     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>   (indexb,ndims,0);
<a name="l00042"></a>00042     <span class="keywordtype">int</span> done = 0;
<a name="l00043"></a>00043     <span class="keywordflow">while</span> (!done) {
<a name="l00044"></a>00044       <span class="keywordtype">int</span> p1, p2;
<a name="l00045"></a>00045       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a> (indexb,indexi,ndims);
<a name="l00046"></a>00046       <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>  (indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00047"></a>00047       <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00048"></a>00048       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00049"></a>00049       <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00050"></a>00050       <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>  (ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00051"></a>00051       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>    (ndims,size,indexi,ghosts,p2);
<a name="l00052"></a>00052       
<a name="l00053"></a>00053       <span class="keywordflow">if</span> (nvars == 4) {
<a name="l00054"></a>00054         phi[nvars*p1+0] = phi[nvars*p2+0];
<a name="l00055"></a>00055         phi[nvars*p1+1] = (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a> ? -phi[nvars*p2+1] : phi[nvars*p2+1] );
<a name="l00056"></a>00056         phi[nvars*p1+2] = (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a> ? -phi[nvars*p2+2] : phi[nvars*p2+2] );
<a name="l00057"></a>00057         phi[nvars*p1+3] = phi[nvars*p2+3];
<a name="l00058"></a>00058       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nvars == 5) {
<a name="l00059"></a>00059         phi[nvars*p1+0] = phi[nvars*p2+0];
<a name="l00060"></a>00060         phi[nvars*p1+1] = (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a> ? -phi[nvars*p2+1] : phi[nvars*p2+1] );
<a name="l00061"></a>00061         phi[nvars*p1+2] = (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a> ? -phi[nvars*p2+2] : phi[nvars*p2+2] );
<a name="l00062"></a>00062         phi[nvars*p1+3] = (dim == <a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a> ? -phi[nvars*p2+3] : phi[nvars*p2+3] );
<a name="l00063"></a>00063         phi[nvars*p1+4] = phi[nvars*p2+4];
<a name="l00064"></a>00064       }
<a name="l00065"></a>00065 
<a name="l00066"></a>00066       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068   }
<a name="l00069"></a>00069   <span class="keywordflow">return</span>(0);
<a name="l00070"></a>00070 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6904fb76cd1fe7638108e1ffdcf1a6ad"></a><!-- doxytag: member="boundaryconditions.h::BCSWSlipWallU" ref="a6904fb76cd1fe7638108e1ffdcf1a6ad" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSWSlipWallU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Slip (inviscid) wall boundary conditions for the solution vector U</p>
<p>Applies the slip-wall boundary condition: This is specific to the one and two dimenstional shallow water equations (<a class="el" href="a00026.html" title="Structure containing variables and parameters specific to the 1D Shallow Water equations...">ShallowWater1D</a>, <a class="el" href="a00027.html" title="Structure containing variables and parameters specific to the 2D Shallow Water equations...">ShallowWater2D</a>). It is used for simulating inviscid walls or symmetric boundaries. The height, and tangential velocity at the ghost points are extrapolated from the interior, while the normal velocity at the ghost points is set such that the interpolated value at the boundary face is equal to the specified wall velocity. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00084_source.html#l00021">21</a> of file <a class="el" href="a00084_source.html">BCSWSlipWall.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00031"></a>00031 {
<a name="l00032"></a>00032   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00033"></a>00033 
<a name="l00034"></a>00034   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00035"></a>00035   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00036"></a>00036 
<a name="l00037"></a>00037   <span class="keywordflow">if</span> (ndims == 1) {
<a name="l00038"></a>00038 
<a name="l00039"></a>00039     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00040"></a>00040       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00041"></a>00041       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00042"></a>00042       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00043"></a>00043       <span class="keywordtype">int</span> done = 0;
<a name="l00044"></a>00044       <span class="keywordflow">while</span> (!done) {
<a name="l00045"></a>00045         <span class="keywordtype">int</span> p1, p2;
<a name="l00046"></a>00046         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00047"></a>00047         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00048"></a>00048         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00049"></a>00049         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00050"></a>00050         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00051"></a>00051         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00052"></a>00052         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00053"></a>00053         
<a name="l00054"></a>00054         <span class="comment">/* flow variables in the interior */</span>
<a name="l00055"></a>00055         <span class="keywordtype">double</span> h, uvel;
<a name="l00056"></a>00056         <span class="keywordtype">double</span> h_gpt, uvel_gpt;
<a name="l00057"></a>00057         <a class="code" href="a00058.html#ab6d0702f0bacbdb3f2644bd1f60938c0">_ShallowWater1DGetFlowVar_</a>((phi+nvars*p2),h,uvel);
<a name="l00058"></a>00058         <span class="comment">/* set the ghost point values */</span>
<a name="l00059"></a>00059         h_gpt = h;
<a name="l00060"></a>00060         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062         phi[nvars*p1+0] = h_gpt;
<a name="l00063"></a>00063         phi[nvars*p1+1] = h_gpt * uvel_gpt;
<a name="l00064"></a>00064 
<a name="l00065"></a>00065         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00066"></a>00066       }
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00070"></a>00070 
<a name="l00071"></a>00071     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00072"></a>00072       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00073"></a>00073       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00074"></a>00074       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00075"></a>00075       <span class="keywordtype">int</span> done = 0;
<a name="l00076"></a>00076       <span class="keywordflow">while</span> (!done) {
<a name="l00077"></a>00077         <span class="keywordtype">int</span> p1, p2;
<a name="l00078"></a>00078         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00079"></a>00079         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00080"></a>00080         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00081"></a>00081         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00082"></a>00082         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00083"></a>00083         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00084"></a>00084         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00085"></a>00085         
<a name="l00086"></a>00086         <span class="comment">/* flow variables in the interior */</span>
<a name="l00087"></a>00087         <span class="keywordtype">double</span> h, uvel, vvel;
<a name="l00088"></a>00088         <span class="keywordtype">double</span> h_gpt, uvel_gpt, vvel_gpt;
<a name="l00089"></a>00089         <a class="code" href="a00059.html#a66b88d6a05555a192a0e455ed99341a4">_ShallowWater2DGetFlowVar_</a>((phi+nvars*p2),h,uvel,vvel);
<a name="l00090"></a>00090         <span class="comment">/* set the ghost point values */</span>
<a name="l00091"></a>00091         h_gpt = h;
<a name="l00092"></a>00092         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00093"></a>00093           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00094"></a>00094           vvel_gpt = vvel;
<a name="l00095"></a>00095         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00096"></a>00096           uvel_gpt = uvel;
<a name="l00097"></a>00097           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00098"></a>00098         } <span class="keywordflow">else</span> {
<a name="l00099"></a>00099           uvel_gpt = 0.0;
<a name="l00100"></a>00100           vvel_gpt = 0.0;
<a name="l00101"></a>00101         }
<a name="l00102"></a>00102 
<a name="l00103"></a>00103         phi[nvars*p1+0] = h_gpt;
<a name="l00104"></a>00104         phi[nvars*p1+1] = h_gpt * uvel_gpt;
<a name="l00105"></a>00105         phi[nvars*p1+2] = h_gpt * vvel_gpt;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00108"></a>00108       }
<a name="l00109"></a>00109     }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111   }
<a name="l00112"></a>00112   <span class="keywordflow">return</span>(0);
<a name="l00113"></a>00113 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa45ae833314d982b2b6a23607a6237cf"></a><!-- doxytag: member="boundaryconditions.h::BCPeriodicDU" ref="aa45ae833314d982b2b6a23607a6237cf" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCPeriodicDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Periodic boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies periodic boundary conditions to the delta-solution: Implemented by copying the solution from the other end of the domain into the physical boundary ghost points. <br/>
<br/>
 Note**: This function only acts if the the number of processors is 1 along the spatial dimension this boundary corresponds to. If there are more than 1 processors along this dimension, periodicity is handled by <a class="el" href="a00045.html#a60ace5964c051fa481e6a1e6f1ef75d7">MPIExchangeBoundariesnD()</a> to minimize communication. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00075_source.html#l00068">68</a> of file <a class="el" href="a00075_source.html">BCPeriodic.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00076"></a>00076                                                                                       {\bf U}\f$.*/
<a name="l00077"></a>00077                   <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00078"></a>00078                   <span class="keywordtype">double</span>  waqt      
<a name="l00079"></a>00079                 )
<a name="l00080"></a>00080 {
<a name="l00081"></a>00081   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00082"></a>00082   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>   *mpi      = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*)   m;
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00085"></a>00085   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00086"></a>00086 
<a name="l00087"></a>00087   <span class="keywordflow">if</span> ((boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) &amp;&amp; (mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dim] == 1)) {
<a name="l00088"></a>00088     <span class="keywordtype">int</span> bounds[ndims], index1[ndims], index2[ndims];
<a name="l00089"></a>00089     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00090"></a>00090     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index1,ndims,0);
<a name="l00091"></a>00091     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index2,ndims,0);
<a name="l00092"></a>00092     <span class="keywordtype">int</span> done = 0;
<a name="l00093"></a>00093     <span class="keywordflow">while</span> (!done) {
<a name="l00094"></a>00094       <span class="keywordtype">int</span> p1 = 0, p2 = 0;
<a name="l00095"></a>00095       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index1,index2,ndims);
<a name="l00096"></a>00096       <span class="keywordflow">if</span> (face == 1) {
<a name="l00097"></a>00097         index2[dim] = index1[dim] + size[dim]-ghosts;
<a name="l00098"></a>00098         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,index1,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00099"></a>00099         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,index2,ghosts,p2);
<a name="l00100"></a>00100       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) {
<a name="l00101"></a>00101         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,index1,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00102"></a>00102         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,index1,ghosts,p2);
<a name="l00103"></a>00103       }
<a name="l00104"></a>00104       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((phi+nvars*p2),(phi+nvars*p1),nvars);
<a name="l00105"></a>00105       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,index1,done);
<a name="l00106"></a>00106     }
<a name="l00107"></a>00107   }
<a name="l00108"></a>00108   <span class="keywordflow">return</span>(0);
<a name="l00109"></a>00109 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab57c71ca185a63df8ead47c95e4edcf6"></a><!-- doxytag: member="boundaryconditions.h::BCExtrapolateDU" ref="ab57c71ca185a63df8ead47c95e4edcf6" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCExtrapolateDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>extrapolate boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Apply the extrapolative boundary condition: Values at the physical boundary ghost points are extrapolated from the interior points adjacent to the boundary. This function implements this boundary condition on the delta-solution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00071_source.html#l00053">53</a> of file <a class="el" href="a00071_source.html">BCExtrapolate.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00061"></a>00061                                                                                           {\bf U}\f$.*/
<a name="l00062"></a>00062                       <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00063"></a>00063                       <span class="keywordtype">double</span>  waqt      
<a name="l00064"></a>00064                    )
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00069"></a>00069   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00070"></a>00070 
<a name="l00071"></a>00071   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00072"></a>00072     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00073"></a>00073     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00074"></a>00074     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00075"></a>00075     <span class="keywordtype">int</span> done = 0;
<a name="l00076"></a>00076     <span class="keywordflow">while</span> (!done) {
<a name="l00077"></a>00077       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00078"></a>00078       <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00079"></a>00079       <span class="keywordflow">if</span> (face == 1)        indexi[dim] = 0;
<a name="l00080"></a>00080       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1)  indexi[dim] = size[dim]-1;
<a name="l00081"></a>00081       <span class="keywordflow">else</span>                  <span class="keywordflow">return</span>(1);
<a name="l00082"></a>00082       <span class="keywordtype">int</span> p1,p2;
<a name="l00083"></a>00083       <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00084"></a>00084       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00085"></a>00085       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((phi+nvars*p2),(phi+nvars*p1),nvars);
<a name="l00086"></a>00086       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00087"></a>00087     }
<a name="l00088"></a>00088   }
<a name="l00089"></a>00089   <span class="keywordflow">return</span>(0);
<a name="l00090"></a>00090 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac949632b08cc43923ffbbcf2b8709b5c"></a><!-- doxytag: member="boundaryconditions.h::BCDirichletDU" ref="ac949632b08cc43923ffbbcf2b8709b5c" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCDirichletDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dirichlet boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies (steady) Dirichlet boundary conditions for the delta-solution: the ghost points at the physical boundaries are set to zero (since the change in the steady Dirichlet boundary state is zero </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00070_source.html#l00042">42</a> of file <a class="el" href="a00070_source.html">BCDirichlet.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00050"></a>00050                                                                                         {\bf U}\f$.*/
<a name="l00051"></a>00051                     <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00052"></a>00052                     <span class="keywordtype">double</span>  waqt      
<a name="l00053"></a>00053                  )
<a name="l00054"></a>00054 {
<a name="l00055"></a>00055   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00056"></a>00056 
<a name="l00057"></a>00057   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00058"></a>00058     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims];
<a name="l00059"></a>00059     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00060"></a>00060     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0); 
<a name="l00061"></a>00061     <span class="keywordtype">int</span> done = 0;
<a name="l00062"></a>00062     <span class="keywordflow">while</span> (!done) {
<a name="l00063"></a>00063       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size  ,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p);
<a name="l00064"></a>00064       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>((phi+nvars*p),nvars,0.0);
<a name="l00065"></a>00065       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00066"></a>00066     }
<a name="l00067"></a>00067   }
<a name="l00068"></a>00068   <span class="keywordflow">return</span>(0);
<a name="l00069"></a>00069 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0f35d7a8360f2d4753123c310b6a7e03"></a><!-- doxytag: member="boundaryconditions.h::BCReflectDU" ref="a0f35d7a8360f2d4753123c310b6a7e03" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCReflectDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reflection boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies the reflection boundary condition on the delta-solution: The values at the physical boundary ghost points are set to the negative of the interior values adjacent to the boundary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00076_source.html#l00055">55</a> of file <a class="el" href="a00076_source.html">BCReflect.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00063"></a>00063                                                                                      {\bf U}\f$.*/
<a name="l00064"></a>00064                  <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00065"></a>00065                  <span class="keywordtype">double</span>  waqt      
<a name="l00066"></a>00066                )
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00071"></a>00071   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00074"></a>00074     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00075"></a>00075     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00076"></a>00076     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00077"></a>00077     <span class="keywordtype">int</span> done = 0;
<a name="l00078"></a>00078     <span class="keywordflow">while</span> (!done) {
<a name="l00079"></a>00079       <span class="keywordtype">int</span> p1, p2;
<a name="l00080"></a>00080       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00081"></a>00081       <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00082"></a>00082       <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00083"></a>00083       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00084"></a>00084       <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00085"></a>00085       <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00086"></a>00086       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00087"></a>00087       <a class="code" href="a00034.html#a7d97d4914726fa7cca339356dae28473">_ArrayScaleCopy1D_</a>((phi+nvars*p2),(-1.0),(phi+nvars*p1),nvars);
<a name="l00088"></a>00088       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00089"></a>00089     }
<a name="l00090"></a>00090   }
<a name="l00091"></a>00091   <span class="keywordflow">return</span>(0);
<a name="l00092"></a>00092 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a87c158d41f942f279dcb48785beadd79"></a><!-- doxytag: member="boundaryconditions.h::BCNoslipWallDU" ref="a87c158d41f942f279dcb48785beadd79" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCNoslipWallDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>No-slip wall (viscous) boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies the no-slip wall boundary conditions to the delta-solution: Used to simulate viscous walls. The density and pressure at the physical boundary ghost points are extrapolated from the interior, while the velocities are set such that the interpolated velocity at the boundary face is the specified wall velocity. This boundary condition is specific to the two and three dimensional Navier-Stokes systems (<a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). <br/>
<br/>
 The delta-solution is added to the reference solution; the above treatment is applied to this solution and the reference solution; and then the reference solution is subtracted to find the appropriate delta-solution values for the ghost points. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00074_source.html#l00142">142</a> of file <a class="el" href="a00074_source.html">BCNoslipWall.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00150"></a>00150                                                                                         {\bf U}\f$.*/
<a name="l00151"></a>00151                     <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00152"></a>00152                     <span class="keywordtype">double</span>  waqt      
<a name="l00153"></a>00153                   )
<a name="l00154"></a>00154 {
<a name="l00155"></a>00155   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00158"></a>00158   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00159"></a>00159   <span class="keywordtype">int</span> v;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     <span class="comment">/* create a fake physics object */</span>
<a name="l00164"></a>00164     <a class="code" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a> physics; 
<a name="l00165"></a>00165     <span class="keywordtype">double</span> gamma; 
<a name="l00166"></a>00166     gamma = physics.<a class="code" href="a00021.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00167"></a>00167     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00170"></a>00170       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00171"></a>00171       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00172"></a>00172       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00173"></a>00173       <span class="keywordtype">int</span> done = 0;
<a name="l00174"></a>00174       <span class="keywordflow">while</span> (!done) {
<a name="l00175"></a>00175         <span class="keywordtype">int</span> p1, p2;
<a name="l00176"></a>00176         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00177"></a>00177         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00178"></a>00178         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00179"></a>00179         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00180"></a>00180         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00181"></a>00181         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00182"></a>00182         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00185"></a>00185         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00186"></a>00186         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00187"></a>00187         
<a name="l00188"></a>00188         <span class="comment">/* flow variables in the interior */</span>
<a name="l00189"></a>00189         <span class="keywordtype">double</span> rho , uvel , vvel , energy , <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a> ;
<a name="l00190"></a>00190         <span class="keywordtype">double</span> rho0, uvel0, vvel0, energy0, pressure0;
<a name="l00191"></a>00191         <a class="code" href="a00054.html#a90ce369a1f9d490ab6d392a996e5be4c">_NavierStokes2DGetFlowVar_</a>(phi_total,rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00192"></a>00192         <a class="code" href="a00054.html#a90ce369a1f9d490ab6d392a996e5be4c">_NavierStokes2DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,energy0,pressure0,(&amp;physics));
<a name="l00193"></a>00193         <span class="comment">/* set the ghost point values */</span>
<a name="l00194"></a>00194         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00195"></a>00195         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00196"></a>00196         <span class="comment">/* ghost point values of the total flow variables */</span>
<a name="l00197"></a>00197         rho_gpt = rho;
<a name="l00198"></a>00198         pressure_gpt = pressure;
<a name="l00199"></a>00199         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00200"></a>00200         vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00201"></a>00201         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00202"></a>00202                     + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00203"></a>00203         <span class="comment">/* ghost point value of the reference flow variables */</span>
<a name="l00204"></a>00204         rho0_gpt = rho0;
<a name="l00205"></a>00205         pressure0_gpt = pressure0;
<a name="l00206"></a>00206         uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00207"></a>00207         vvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel0;
<a name="l00208"></a>00208         energy0_gpt = inv_gamma_m1*pressure0_gpt 
<a name="l00209"></a>00209                     + 0.5 * rho0_gpt * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt);
<a name="l00210"></a>00210 
<a name="l00211"></a>00211         phi[nvars*p1+0] = rho_gpt             - rho0_gpt;
<a name="l00212"></a>00212         phi[nvars*p1+1] = rho_gpt * uvel_gpt  - rho0_gpt * uvel0_gpt;
<a name="l00213"></a>00213         phi[nvars*p1+2] = rho_gpt * vvel_gpt  - rho0_gpt * vvel0_gpt;
<a name="l00214"></a>00214         phi[nvars*p1+3] = energy_gpt          - energy0_gpt;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00217"></a>00217       }
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00221"></a>00221 
<a name="l00222"></a>00222     <span class="comment">/* create a fake physics object */</span>
<a name="l00223"></a>00223     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics; 
<a name="l00224"></a>00224     <span class="keywordtype">double</span> gamma; 
<a name="l00225"></a>00225     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00226"></a>00226     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00229"></a>00229       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00230"></a>00230       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00231"></a>00231       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00232"></a>00232       <span class="keywordtype">int</span> done = 0;
<a name="l00233"></a>00233       <span class="keywordflow">while</span> (!done) {
<a name="l00234"></a>00234         <span class="keywordtype">int</span> p1, p2;
<a name="l00235"></a>00235         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00236"></a>00236         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00237"></a>00237         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00238"></a>00238         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00239"></a>00239         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00240"></a>00240         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00241"></a>00241         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00242"></a>00242         
<a name="l00243"></a>00243         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00244"></a>00244         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00245"></a>00245         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00246"></a>00246         
<a name="l00247"></a>00247         <span class="comment">/* flow variables in the interior */</span>
<a name="l00248"></a>00248         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, pressure;
<a name="l00249"></a>00249         <span class="keywordtype">double</span> rho0, uvel0, vvel0, wvel0, energy0, pressure0;
<a name="l00250"></a>00250         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>(phi_total,rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00251"></a>00251         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,wvel0,energy0,pressure0,(&amp;physics));
<a name="l00252"></a>00252         <span class="comment">/* set the ghost point values */</span>
<a name="l00253"></a>00253         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00254"></a>00254         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, wvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00255"></a>00255         <span class="comment">/* setting the ghost point values for the total flow variables */</span>
<a name="l00256"></a>00256         rho_gpt = rho;
<a name="l00257"></a>00257         pressure_gpt = pressure;
<a name="l00258"></a>00258         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00259"></a>00259         vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00260"></a>00260         wvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>] - wvel;
<a name="l00261"></a>00261         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00262"></a>00262                     + 0.5 * rho_gpt 
<a name="l00263"></a>00263                     * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00264"></a>00264         <span class="comment">/* setting the ghost point values for the reference flow variables */</span>
<a name="l00265"></a>00265         rho0_gpt = rho0;
<a name="l00266"></a>00266         pressure0_gpt = pressure0;
<a name="l00267"></a>00267         uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00268"></a>00268         vvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel0;
<a name="l00269"></a>00269         wvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>] - wvel0;
<a name="l00270"></a>00270         energy0_gpt = inv_gamma_m1*pressure0_gpt 
<a name="l00271"></a>00271                     + 0.5 * rho0_gpt 
<a name="l00272"></a>00272                     * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt + wvel0_gpt*wvel0_gpt);
<a name="l00273"></a>00273 
<a name="l00274"></a>00274         phi[nvars*p1+0] = rho_gpt            - rho0_gpt;
<a name="l00275"></a>00275         phi[nvars*p1+1] = rho_gpt * uvel_gpt - rho0_gpt * uvel0_gpt;
<a name="l00276"></a>00276         phi[nvars*p1+2] = rho_gpt * vvel_gpt - rho0_gpt * vvel0_gpt;
<a name="l00277"></a>00277         phi[nvars*p1+3] = rho_gpt * wvel_gpt - rho0_gpt * wvel0_gpt;
<a name="l00278"></a>00278         phi[nvars*p1+4] = energy_gpt         - energy0_gpt;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00281"></a>00281       }
<a name="l00282"></a>00282     }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   }
<a name="l00285"></a>00285   <span class="keywordflow">return</span>(0);
<a name="l00286"></a>00286 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af5d89bbb4eba90663c3c30c02b663079"></a><!-- doxytag: member="boundaryconditions.h::BCSlipWallDU" ref="af5d89bbb4eba90663c3c30c02b663079" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSlipWallDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Slip (inviscid) wall boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies the slip-wall boundary condition to the delta-solution: This is specific to the two and three dimensional Euler and Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). It is used for simulating inviscid walls or symmetric boundaries. The pressure, density, and tangential velocity at the ghost points are extrapolated from the interior, while the normal velocity at the ghost points is set such that the interpolated value at the boundary face is equal to the specified wall velocity. <br/>
<br/>
 The above treatment is applied on the delta-solution added to the reference solution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00077_source.html#l00206">206</a> of file <a class="el" href="a00077_source.html">BCSlipWall.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00214"></a>00214                                                                                      {\bf U}\f$.*/
<a name="l00215"></a>00215                  <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00216"></a>00216                  <span class="keywordtype">double</span>  waqt      
<a name="l00217"></a>00217                 )
<a name="l00218"></a>00218 {
<a name="l00219"></a>00219   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00222"></a>00222   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00223"></a>00223   <span class="keywordtype">int</span> v;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225   <span class="keywordflow">if</span> (ndims == 1) {
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     <span class="comment">/* create a fake physics object */</span>
<a name="l00228"></a>00228     <a class="code" href="a00005.html" title="Structure containing variables and parameters specific to the 1D Euler equations...">Euler1D</a> physics; 
<a name="l00229"></a>00229     <span class="keywordtype">double</span> gamma; 
<a name="l00230"></a>00230     gamma = physics.<a class="code" href="a00005.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00231"></a>00231     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00234"></a>00234       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00235"></a>00235       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00236"></a>00236       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00237"></a>00237       <span class="keywordtype">int</span> done = 0;
<a name="l00238"></a>00238       <span class="keywordflow">while</span> (!done) {
<a name="l00239"></a>00239         <span class="keywordtype">int</span> p1, p2;
<a name="l00240"></a>00240         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00241"></a>00241         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00242"></a>00242         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00243"></a>00243         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00244"></a>00244         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00245"></a>00245         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00246"></a>00246         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00247"></a>00247 
<a name="l00248"></a>00248         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00249"></a>00249         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00250"></a>00250         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00251"></a>00251         
<a name="l00252"></a>00252         <span class="comment">/* flow variables in the interior */</span>
<a name="l00253"></a>00253         <span class="keywordtype">double</span> rho , uvel , energy , <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a> ;
<a name="l00254"></a>00254         <span class="keywordtype">double</span> rho0, uvel0, energy0, pressure0;
<a name="l00255"></a>00255         <a class="code" href="a00047.html#af35510fb1477577f57c57cc2a862b1e7">_Euler1DGetFlowVar_</a>(phi_total,rho,uvel,energy,pressure,(&amp;physics));
<a name="l00256"></a>00256         <a class="code" href="a00047.html#af35510fb1477577f57c57cc2a862b1e7">_Euler1DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,energy0,pressure0,(&amp;physics));
<a name="l00257"></a>00257         <span class="comment">/* set the ghost point values */</span>
<a name="l00258"></a>00258         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, energy_gpt, pressure_gpt;
<a name="l00259"></a>00259         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00260"></a>00260         <span class="comment">/* ghost point values of the total flow variables */</span>
<a name="l00261"></a>00261         rho_gpt = rho;
<a name="l00262"></a>00262         pressure_gpt = pressure;
<a name="l00263"></a>00263         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00264"></a>00264         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00265"></a>00265                     + 0.5 * rho_gpt * uvel_gpt*uvel_gpt;
<a name="l00266"></a>00266         <span class="comment">/* ghost point value of the reference flow variables */</span>
<a name="l00267"></a>00267         rho0_gpt = rho0;
<a name="l00268"></a>00268         pressure0_gpt = pressure0;
<a name="l00269"></a>00269         uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00270"></a>00270         energy0_gpt = inv_gamma_m1*pressure0_gpt 
<a name="l00271"></a>00271                     + 0.5 * rho0_gpt * uvel0_gpt*uvel0_gpt;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273         phi[nvars*p1+0] = rho_gpt             - rho0_gpt;
<a name="l00274"></a>00274         phi[nvars*p1+1] = rho_gpt * uvel_gpt  - rho0_gpt * uvel0_gpt;
<a name="l00275"></a>00275         phi[nvars*p1+2] = energy_gpt          - energy0_gpt;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00278"></a>00278       }
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="comment">/* create a fake physics object */</span>
<a name="l00284"></a>00284     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00285"></a>00285     <span class="keywordtype">double</span> gamma; 
<a name="l00286"></a>00286     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00287"></a>00287     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00290"></a>00290       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00291"></a>00291       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00292"></a>00292       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00293"></a>00293       <span class="keywordtype">int</span> done = 0;
<a name="l00294"></a>00294       <span class="keywordflow">while</span> (!done) {
<a name="l00295"></a>00295         <span class="keywordtype">int</span> p1, p2;
<a name="l00296"></a>00296         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00297"></a>00297         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00298"></a>00298         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00299"></a>00299         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00300"></a>00300         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00301"></a>00301         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00302"></a>00302         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00303"></a>00303 
<a name="l00304"></a>00304         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00305"></a>00305         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00306"></a>00306         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00307"></a>00307         
<a name="l00308"></a>00308         <span class="comment">/* flow variables in the interior */</span>
<a name="l00309"></a>00309         <span class="keywordtype">double</span> rho , uvel , vvel , energy , pressure ;
<a name="l00310"></a>00310         <span class="keywordtype">double</span> rho0, uvel0, vvel0, energy0, pressure0;
<a name="l00311"></a>00311         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>(phi_total,rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00312"></a>00312         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,energy0,pressure0,(&amp;physics));
<a name="l00313"></a>00313         <span class="comment">/* set the ghost point values */</span>
<a name="l00314"></a>00314         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00315"></a>00315         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00316"></a>00316         <span class="comment">/* ghost point values of the total flow variables */</span>
<a name="l00317"></a>00317         rho_gpt = rho;
<a name="l00318"></a>00318         pressure_gpt = pressure;
<a name="l00319"></a>00319         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00320"></a>00320           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00321"></a>00321           vvel_gpt = vvel;
<a name="l00322"></a>00322         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00323"></a>00323           uvel_gpt = uvel;
<a name="l00324"></a>00324           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00325"></a>00325         } <span class="keywordflow">else</span> {
<a name="l00326"></a>00326           uvel_gpt = 0.0;
<a name="l00327"></a>00327           vvel_gpt = 0.0;
<a name="l00328"></a>00328         }
<a name="l00329"></a>00329         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00330"></a>00330                     + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00331"></a>00331         <span class="comment">/* ghost point value of the reference flow variables */</span>
<a name="l00332"></a>00332         rho0_gpt = rho0;
<a name="l00333"></a>00333         pressure0_gpt = pressure0;
<a name="l00334"></a>00334         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00335"></a>00335           uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00336"></a>00336           vvel0_gpt = vvel0;
<a name="l00337"></a>00337         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00338"></a>00338           uvel0_gpt = uvel0;
<a name="l00339"></a>00339           vvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel0;
<a name="l00340"></a>00340         } <span class="keywordflow">else</span> {
<a name="l00341"></a>00341           uvel0_gpt = 0.0;
<a name="l00342"></a>00342           vvel0_gpt = 0.0;
<a name="l00343"></a>00343         }
<a name="l00344"></a>00344         energy0_gpt = inv_gamma_m1*pressure0_gpt 
<a name="l00345"></a>00345                     + 0.5 * rho0_gpt * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         phi[nvars*p1+0] = rho_gpt             - rho0_gpt;
<a name="l00348"></a>00348         phi[nvars*p1+1] = rho_gpt * uvel_gpt  - rho0_gpt * uvel0_gpt;
<a name="l00349"></a>00349         phi[nvars*p1+2] = rho_gpt * vvel_gpt  - rho0_gpt * vvel0_gpt;
<a name="l00350"></a>00350         phi[nvars*p1+3] = energy_gpt          - energy0_gpt;
<a name="l00351"></a>00351 
<a name="l00352"></a>00352         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00353"></a>00353       }
<a name="l00354"></a>00354     }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00357"></a>00357 
<a name="l00358"></a>00358     <span class="comment">/* create a fake physics object */</span>
<a name="l00359"></a>00359     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics; 
<a name="l00360"></a>00360     <span class="keywordtype">double</span> gamma; 
<a name="l00361"></a>00361     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00362"></a>00362     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00365"></a>00365       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00366"></a>00366       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00367"></a>00367       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00368"></a>00368       <span class="keywordtype">int</span> done = 0;
<a name="l00369"></a>00369       <span class="keywordflow">while</span> (!done) {
<a name="l00370"></a>00370         <span class="keywordtype">int</span> p1, p2;
<a name="l00371"></a>00371         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00372"></a>00372         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00373"></a>00373         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00374"></a>00374         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00375"></a>00375         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00376"></a>00376         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00377"></a>00377         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00378"></a>00378         
<a name="l00379"></a>00379         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00380"></a>00380         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00381"></a>00381         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00382"></a>00382         
<a name="l00383"></a>00383         <span class="comment">/* flow variables in the interior */</span>
<a name="l00384"></a>00384         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, pressure;
<a name="l00385"></a>00385         <span class="keywordtype">double</span> rho0, uvel0, vvel0, wvel0, energy0, pressure0;
<a name="l00386"></a>00386         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>(phi_total,rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00387"></a>00387         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,wvel0,energy0,pressure0,(&amp;physics));
<a name="l00388"></a>00388         <span class="comment">/* set the ghost point values */</span>
<a name="l00389"></a>00389         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00390"></a>00390         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, wvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00391"></a>00391         <span class="comment">/* setting the ghost point values for the total flow variables */</span>
<a name="l00392"></a>00392         rho_gpt = rho;
<a name="l00393"></a>00393         pressure_gpt = pressure;
<a name="l00394"></a>00394         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00395"></a>00395           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00396"></a>00396           vvel_gpt = vvel;
<a name="l00397"></a>00397           wvel_gpt = wvel;
<a name="l00398"></a>00398         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00399"></a>00399           uvel_gpt = uvel;
<a name="l00400"></a>00400           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00401"></a>00401           wvel_gpt = wvel;
<a name="l00402"></a>00402         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>) {
<a name="l00403"></a>00403           uvel_gpt = uvel;
<a name="l00404"></a>00404           vvel_gpt = vvel;
<a name="l00405"></a>00405           wvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>] - wvel;
<a name="l00406"></a>00406         } <span class="keywordflow">else</span> {
<a name="l00407"></a>00407           uvel_gpt = 0.0;
<a name="l00408"></a>00408           vvel_gpt = 0.0;
<a name="l00409"></a>00409           wvel_gpt = 0.0;
<a name="l00410"></a>00410         }
<a name="l00411"></a>00411         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00412"></a>00412                     + 0.5 * rho_gpt 
<a name="l00413"></a>00413                     * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00414"></a>00414         <span class="comment">/* setting the ghost point values for the reference flow variables */</span>
<a name="l00415"></a>00415         rho0_gpt = rho0;
<a name="l00416"></a>00416         pressure0_gpt = pressure0;
<a name="l00417"></a>00417         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00418"></a>00418           uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00419"></a>00419           vvel0_gpt = vvel0;
<a name="l00420"></a>00420           wvel0_gpt = wvel0;
<a name="l00421"></a>00421         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00422"></a>00422           uvel0_gpt = uvel0;
<a name="l00423"></a>00423           vvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel0;
<a name="l00424"></a>00424           wvel0_gpt = wvel0;
<a name="l00425"></a>00425         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>) {
<a name="l00426"></a>00426           uvel0_gpt = uvel0;
<a name="l00427"></a>00427           vvel0_gpt = vvel0;
<a name="l00428"></a>00428           wvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>] - wvel0;
<a name="l00429"></a>00429         } <span class="keywordflow">else</span> {
<a name="l00430"></a>00430           uvel0_gpt = 0.0;
<a name="l00431"></a>00431           vvel0_gpt = 0.0;
<a name="l00432"></a>00432           wvel0_gpt = 0.0;
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434         energy0_gpt = inv_gamma_m1*pressure0_gpt 
<a name="l00435"></a>00435                     + 0.5 * rho0_gpt 
<a name="l00436"></a>00436                     * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt + wvel0_gpt*wvel0_gpt);
<a name="l00437"></a>00437 
<a name="l00438"></a>00438         phi[nvars*p1+0] = rho_gpt            - rho0_gpt;
<a name="l00439"></a>00439         phi[nvars*p1+1] = rho_gpt * uvel_gpt - rho0_gpt * uvel0_gpt;
<a name="l00440"></a>00440         phi[nvars*p1+2] = rho_gpt * vvel_gpt - rho0_gpt * vvel0_gpt;
<a name="l00441"></a>00441         phi[nvars*p1+3] = rho_gpt * wvel_gpt - rho0_gpt * wvel0_gpt;
<a name="l00442"></a>00442         phi[nvars*p1+4] = energy_gpt         - energy0_gpt;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00445"></a>00445       }
<a name="l00446"></a>00446     }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   }
<a name="l00449"></a>00449   <span class="keywordflow">return</span>(0);
<a name="l00450"></a>00450 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a768e1128cb2a39574b8661602cc96562"></a><!-- doxytag: member="boundaryconditions.h::BCThermalSlipWallDU" ref="a768e1128cb2a39574b8661602cc96562" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCThermalSlipWallDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Slip (inviscid) thermal wall boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies the slip-wall boundary condition to the delta-solution: This is specific to the two and three dimensional Euler and Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). It is used for simulating inviscid walls or symmetric boundaries. The pressure, density, and tangential velocity at the ghost points are extrapolated from the interior, while the normal velocity at the ghost points is set such that the interpolated value at the boundary face is equal to the specified wall velocity. <br/>
<br/>
 The above treatment is applied on the delta-solution added to the reference solution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00085_source.html#l00210">210</a> of file <a class="el" href="a00085_source.html">BCThermalSlipWall.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00218"></a>00218                                                                                              {\bf U}\f$.*/
<a name="l00219"></a>00219                          <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00220"></a>00220                          <span class="keywordtype">double</span>  waqt      
<a name="l00221"></a>00221                        )
<a name="l00222"></a>00222 {
<a name="l00223"></a>00223   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00226"></a>00226   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00227"></a>00227   <span class="keywordtype">int</span> v;
<a name="l00228"></a>00228 
<a name="l00229"></a>00229   <span class="keywordflow">if</span> (ndims == 1) {
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     <span class="comment">/* create a fake physics object */</span>
<a name="l00232"></a>00232     <a class="code" href="a00005.html" title="Structure containing variables and parameters specific to the 1D Euler equations...">Euler1D</a> physics; 
<a name="l00233"></a>00233     <span class="keywordtype">double</span> gamma; 
<a name="l00234"></a>00234     gamma = physics.<a class="code" href="a00005.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00235"></a>00235     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00238"></a>00238       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00239"></a>00239       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00240"></a>00240       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00241"></a>00241       <span class="keywordtype">int</span> done = 0;
<a name="l00242"></a>00242       <span class="keywordflow">while</span> (!done) {
<a name="l00243"></a>00243         <span class="keywordtype">int</span> p1, p2;
<a name="l00244"></a>00244         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00245"></a>00245         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00246"></a>00246         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00247"></a>00247         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00248"></a>00248         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00249"></a>00249         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00250"></a>00250         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00253"></a>00253         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00254"></a>00254         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00255"></a>00255         
<a name="l00256"></a>00256         <span class="comment">/* flow variables in the interior */</span>
<a name="l00257"></a>00257         <span class="keywordtype">double</span> rho , uvel , energy , <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a> ;
<a name="l00258"></a>00258         <span class="keywordtype">double</span> rho0, uvel0, energy0, pressure0;
<a name="l00259"></a>00259         <a class="code" href="a00047.html#af35510fb1477577f57c57cc2a862b1e7">_Euler1DGetFlowVar_</a>(phi_total,rho,uvel,energy,pressure,(&amp;physics));
<a name="l00260"></a>00260         <a class="code" href="a00047.html#af35510fb1477577f57c57cc2a862b1e7">_Euler1DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,energy0,pressure0,(&amp;physics));
<a name="l00261"></a>00261         <span class="comment">/* set the ghost point values */</span>
<a name="l00262"></a>00262         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, energy_gpt, pressure_gpt;
<a name="l00263"></a>00263         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00264"></a>00264         <span class="comment">/* ghost point values of the total flow variables */</span>
<a name="l00265"></a>00265         rho_gpt = rho;
<a name="l00266"></a>00266         pressure_gpt = pressure;
<a name="l00267"></a>00267         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00268"></a>00268         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00269"></a>00269                     + 0.5 * rho_gpt * uvel_gpt*uvel_gpt;
<a name="l00270"></a>00270         <span class="comment">/* ghost point value of the reference flow variables */</span>
<a name="l00271"></a>00271         rho0_gpt = rho0;
<a name="l00272"></a>00272         pressure0_gpt = pressure0;
<a name="l00273"></a>00273         uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00274"></a>00274         energy0_gpt = inv_gamma_m1*pressure0_gpt 
<a name="l00275"></a>00275                     + 0.5 * rho0_gpt * uvel0_gpt*uvel0_gpt;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277         phi[nvars*p1+0] = rho_gpt             - rho0_gpt;
<a name="l00278"></a>00278         phi[nvars*p1+1] = rho_gpt * uvel_gpt  - rho0_gpt * uvel0_gpt;
<a name="l00279"></a>00279         phi[nvars*p1+2] = energy_gpt          - energy0_gpt;
<a name="l00280"></a>00280 
<a name="l00281"></a>00281         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00282"></a>00282       }
<a name="l00283"></a>00283     }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00286"></a>00286 
<a name="l00287"></a>00287     <span class="comment">/* create a fake physics object */</span>
<a name="l00288"></a>00288     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00289"></a>00289     <span class="keywordtype">double</span> gamma; 
<a name="l00290"></a>00290     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00291"></a>00291     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00294"></a>00294       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00295"></a>00295       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00296"></a>00296       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00297"></a>00297       <span class="keywordtype">int</span> done = 0;
<a name="l00298"></a>00298       <span class="keywordflow">while</span> (!done) {
<a name="l00299"></a>00299         <span class="keywordtype">int</span> p1, p2;
<a name="l00300"></a>00300         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00301"></a>00301         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00302"></a>00302         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00303"></a>00303         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00304"></a>00304         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00305"></a>00305         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00306"></a>00306         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00309"></a>00309         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00310"></a>00310         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00311"></a>00311         
<a name="l00312"></a>00312         <span class="comment">/* flow variables in the interior */</span>
<a name="l00313"></a>00313         <span class="keywordtype">double</span> rho , uvel , vvel , energy , pressure ;
<a name="l00314"></a>00314         <span class="keywordtype">double</span> rho0, uvel0, vvel0, energy0, pressure0;
<a name="l00315"></a>00315         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>(phi_total,rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00316"></a>00316         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,energy0,pressure0,(&amp;physics));
<a name="l00317"></a>00317         <span class="comment">/* set the ghost point values */</span>
<a name="l00318"></a>00318         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00319"></a>00319         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00320"></a>00320         <span class="comment">/* ghost point values of the total flow variables */</span>
<a name="l00321"></a>00321         rho_gpt = rho;
<a name="l00322"></a>00322         pressure_gpt = pressure;
<a name="l00323"></a>00323         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00324"></a>00324           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00325"></a>00325           vvel_gpt = vvel;
<a name="l00326"></a>00326         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00327"></a>00327           uvel_gpt = uvel;
<a name="l00328"></a>00328           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00329"></a>00329         } <span class="keywordflow">else</span> {
<a name="l00330"></a>00330           uvel_gpt = 0.0;
<a name="l00331"></a>00331           vvel_gpt = 0.0;
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00334"></a>00334                     + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00335"></a>00335         <span class="comment">/* ghost point value of the reference flow variables */</span>
<a name="l00336"></a>00336         rho0_gpt = rho0;
<a name="l00337"></a>00337         pressure0_gpt = pressure0;
<a name="l00338"></a>00338         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00339"></a>00339           uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00340"></a>00340           vvel0_gpt = vvel0;
<a name="l00341"></a>00341         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00342"></a>00342           uvel0_gpt = uvel0;
<a name="l00343"></a>00343           vvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel0;
<a name="l00344"></a>00344         } <span class="keywordflow">else</span> {
<a name="l00345"></a>00345           uvel0_gpt = 0.0;
<a name="l00346"></a>00346           vvel0_gpt = 0.0;
<a name="l00347"></a>00347         }
<a name="l00348"></a>00348         energy0_gpt = inv_gamma_m1*pressure0_gpt 
<a name="l00349"></a>00349                     + 0.5 * rho0_gpt * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt);
<a name="l00350"></a>00350 
<a name="l00351"></a>00351         phi[nvars*p1+0] = rho_gpt             - rho0_gpt;
<a name="l00352"></a>00352         phi[nvars*p1+1] = rho_gpt * uvel_gpt  - rho0_gpt * uvel0_gpt;
<a name="l00353"></a>00353         phi[nvars*p1+2] = rho_gpt * vvel_gpt  - rho0_gpt * vvel0_gpt;
<a name="l00354"></a>00354         phi[nvars*p1+3] = energy_gpt          - energy0_gpt;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00357"></a>00357       }
<a name="l00358"></a>00358     }
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00361"></a>00361 
<a name="l00362"></a>00362     <span class="comment">/* create a fake physics object */</span>
<a name="l00363"></a>00363     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics; 
<a name="l00364"></a>00364     <span class="keywordtype">double</span> gamma; 
<a name="l00365"></a>00365     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00366"></a>00366     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00369"></a>00369       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00370"></a>00370       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00371"></a>00371       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00372"></a>00372       <span class="keywordtype">int</span> done = 0;
<a name="l00373"></a>00373       <span class="keywordflow">while</span> (!done) {
<a name="l00374"></a>00374         <span class="keywordtype">int</span> p1, p2;
<a name="l00375"></a>00375         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00376"></a>00376         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00377"></a>00377         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00378"></a>00378         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00379"></a>00379         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00380"></a>00380         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00381"></a>00381         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00382"></a>00382         
<a name="l00383"></a>00383         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00384"></a>00384         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00385"></a>00385         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00386"></a>00386         
<a name="l00387"></a>00387         <span class="comment">/* flow variables in the interior */</span>
<a name="l00388"></a>00388         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, pressure;
<a name="l00389"></a>00389         <span class="keywordtype">double</span> rho0, uvel0, vvel0, wvel0, energy0, pressure0;
<a name="l00390"></a>00390         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>(phi_total,rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00391"></a>00391         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,wvel0,energy0,pressure0,(&amp;physics));
<a name="l00392"></a>00392         <span class="comment">/* set the ghost point values */</span>
<a name="l00393"></a>00393         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00394"></a>00394         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, wvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00395"></a>00395         <span class="comment">/* setting the ghost point values for the total flow variables */</span>
<a name="l00396"></a>00396         rho_gpt = rho;
<a name="l00397"></a>00397         pressure_gpt = pressure;
<a name="l00398"></a>00398         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00399"></a>00399           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00400"></a>00400           vvel_gpt = vvel;
<a name="l00401"></a>00401           wvel_gpt = wvel;
<a name="l00402"></a>00402         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00403"></a>00403           uvel_gpt = uvel;
<a name="l00404"></a>00404           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00405"></a>00405           wvel_gpt = wvel;
<a name="l00406"></a>00406         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>) {
<a name="l00407"></a>00407           uvel_gpt = uvel;
<a name="l00408"></a>00408           vvel_gpt = vvel;
<a name="l00409"></a>00409           wvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>] - wvel;
<a name="l00410"></a>00410         } <span class="keywordflow">else</span> {
<a name="l00411"></a>00411           uvel_gpt = 0.0;
<a name="l00412"></a>00412           vvel_gpt = 0.0;
<a name="l00413"></a>00413           wvel_gpt = 0.0;
<a name="l00414"></a>00414         }
<a name="l00415"></a>00415         energy_gpt = inv_gamma_m1*pressure_gpt 
<a name="l00416"></a>00416                     + 0.5 * rho_gpt 
<a name="l00417"></a>00417                     * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00418"></a>00418         <span class="comment">/* setting the ghost point values for the reference flow variables */</span>
<a name="l00419"></a>00419         rho0_gpt = rho0;
<a name="l00420"></a>00420         pressure0_gpt = pressure0;
<a name="l00421"></a>00421         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00422"></a>00422           uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00423"></a>00423           vvel0_gpt = vvel0;
<a name="l00424"></a>00424           wvel0_gpt = wvel0;
<a name="l00425"></a>00425         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00426"></a>00426           uvel0_gpt = uvel0;
<a name="l00427"></a>00427           vvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel0;
<a name="l00428"></a>00428           wvel0_gpt = wvel0;
<a name="l00429"></a>00429         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>) {
<a name="l00430"></a>00430           uvel0_gpt = uvel0;
<a name="l00431"></a>00431           vvel0_gpt = vvel0;
<a name="l00432"></a>00432           wvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00055.html#a227beecac6bef022707512c15d39e30b">_ZDIR_</a>] - wvel0;
<a name="l00433"></a>00433         } <span class="keywordflow">else</span> {
<a name="l00434"></a>00434           uvel0_gpt = 0.0;
<a name="l00435"></a>00435           vvel0_gpt = 0.0;
<a name="l00436"></a>00436           wvel0_gpt = 0.0;
<a name="l00437"></a>00437         }
<a name="l00438"></a>00438         energy0_gpt = inv_gamma_m1*pressure0_gpt 
<a name="l00439"></a>00439                     + 0.5 * rho0_gpt 
<a name="l00440"></a>00440                     * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt + wvel0_gpt*wvel0_gpt);
<a name="l00441"></a>00441 
<a name="l00442"></a>00442         phi[nvars*p1+0] = rho_gpt            - rho0_gpt;
<a name="l00443"></a>00443         phi[nvars*p1+1] = rho_gpt * uvel_gpt - rho0_gpt * uvel0_gpt;
<a name="l00444"></a>00444         phi[nvars*p1+2] = rho_gpt * vvel_gpt - rho0_gpt * vvel0_gpt;
<a name="l00445"></a>00445         phi[nvars*p1+3] = rho_gpt * wvel_gpt - rho0_gpt * wvel0_gpt;
<a name="l00446"></a>00446         phi[nvars*p1+4] = energy_gpt         - energy0_gpt;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00449"></a>00449       }
<a name="l00450"></a>00450     }
<a name="l00451"></a>00451 
<a name="l00452"></a>00452   }
<a name="l00453"></a>00453   <span class="keywordflow">return</span>(0);
<a name="l00454"></a>00454 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7de01f99b34e0a3e80b77792a5eca37c"></a><!-- doxytag: member="boundaryconditions.h::BCSubsonicInflowDU" ref="a7de01f99b34e0a3e80b77792a5eca37c" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSubsonicInflowDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subsonic inflow boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies the subsonic inflow boundary condition to the delta-solution: The density and velocity at the physical boundary ghost points are specified, while the pressure is extrapolated from the interior of the domain. This boundary condition is specific to two and three dimension Euler and Navier- Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). <br/>
<br/>
 The delta-solution is added to the reference solution, and the above treatment is applied to this total solution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00080_source.html#l00140">140</a> of file <a class="el" href="a00080_source.html">BCSubsonicInflow.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00148"></a>00148                                                                                             {\bf U}\f$.*/
<a name="l00149"></a>00149                         <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00150"></a>00150                         <span class="keywordtype">double</span>  waqt      
<a name="l00151"></a>00151                       )
<a name="l00152"></a>00152 {
<a name="l00153"></a>00153   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00156"></a>00156   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00157"></a>00157   <span class="keywordtype">int</span> v;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159   <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00160"></a>00160 
<a name="l00161"></a>00161     <span class="comment">/* create a fake physics object */</span>
<a name="l00162"></a>00162     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00163"></a>00163     <span class="keywordtype">double</span> gamma;
<a name="l00164"></a>00164     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00165"></a>00165     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00168"></a>00168       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00169"></a>00169       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00170"></a>00170       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00171"></a>00171       <span class="keywordtype">int</span> done = 0;
<a name="l00172"></a>00172       <span class="keywordflow">while</span> (!done) {
<a name="l00173"></a>00173         <span class="keywordtype">int</span> p1, p2;
<a name="l00174"></a>00174         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00175"></a>00175         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00176"></a>00176         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00177"></a>00177         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00178"></a>00178         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00179"></a>00179         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00180"></a>00180         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00181"></a>00181         
<a name="l00182"></a>00182         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00183"></a>00183         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00184"></a>00184         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00185"></a>00185 
<a name="l00186"></a>00186         <span class="comment">/* flow variables in the interior */</span>
<a name="l00187"></a>00187         <span class="keywordtype">double</span> rho, uvel, vvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00188"></a>00188         <span class="keywordtype">double</span> rho0, uvel0, vvel0, energy0, pressure0;
<a name="l00189"></a>00189         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>(phi_total,rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00190"></a>00190         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,energy0,pressure0,(&amp;physics));
<a name="l00191"></a>00191         <span class="comment">/* set the ghost point values */</span>
<a name="l00192"></a>00192         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00193"></a>00193         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00194"></a>00194         <span class="comment">/* setting the ghost point values of the total flow variables */</span>
<a name="l00195"></a>00195         rho_gpt      = boundary-&gt;<a class="code" href="a00004.html#aa92ee9d8efc5ca49f4a83d8dabf0b15d">FlowDensity</a>;
<a name="l00196"></a>00196         pressure_gpt = pressure;
<a name="l00197"></a>00197         uvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0];
<a name="l00198"></a>00198         vvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1];
<a name="l00199"></a>00199         energy_gpt   = inv_gamma_m1*pressure_gpt
<a name="l00200"></a>00200                        + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00201"></a>00201         <span class="comment">/* setting the ghost point values of the reference flow variables */</span>
<a name="l00202"></a>00202         rho0_gpt      = boundary-&gt;<a class="code" href="a00004.html#aa92ee9d8efc5ca49f4a83d8dabf0b15d">FlowDensity</a>;
<a name="l00203"></a>00203         pressure0_gpt = pressure0;
<a name="l00204"></a>00204         uvel0_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0];
<a name="l00205"></a>00205         vvel0_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1];
<a name="l00206"></a>00206         energy0_gpt   = inv_gamma_m1*pressure0_gpt
<a name="l00207"></a>00207                        + 0.5 * rho0_gpt * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt);
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         phi[nvars*p1+0] = rho_gpt            - rho0_gpt;
<a name="l00210"></a>00210         phi[nvars*p1+1] = rho_gpt * uvel_gpt - rho0_gpt * uvel0_gpt;
<a name="l00211"></a>00211         phi[nvars*p1+2] = rho_gpt * vvel_gpt - rho0_gpt * vvel0_gpt;
<a name="l00212"></a>00212         phi[nvars*p1+3] = energy_gpt         - energy0_gpt;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00215"></a>00215       }
<a name="l00216"></a>00216     }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     <span class="comment">/* create a fake physics object */</span>
<a name="l00221"></a>00221     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics;
<a name="l00222"></a>00222     <span class="keywordtype">double</span> gamma;
<a name="l00223"></a>00223     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00224"></a>00224     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00227"></a>00227       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00228"></a>00228       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00229"></a>00229       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00230"></a>00230       <span class="keywordtype">int</span> done = 0;
<a name="l00231"></a>00231       <span class="keywordflow">while</span> (!done) {
<a name="l00232"></a>00232         <span class="keywordtype">int</span> p1, p2;
<a name="l00233"></a>00233         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00234"></a>00234         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00235"></a>00235         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00236"></a>00236         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00237"></a>00237         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00238"></a>00238         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00239"></a>00239         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00240"></a>00240         
<a name="l00241"></a>00241         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00242"></a>00242         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00243"></a>00243         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00244"></a>00244 
<a name="l00245"></a>00245         <span class="comment">/* flow variables in the interior */</span>
<a name="l00246"></a>00246         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, pressure;
<a name="l00247"></a>00247         <span class="keywordtype">double</span> rho0, uvel0, vvel0, wvel0, energy0, pressure0;
<a name="l00248"></a>00248         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>(phi_total,rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00249"></a>00249         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,wvel0,energy0,pressure0,(&amp;physics));
<a name="l00250"></a>00250         <span class="comment">/* set the ghost point values */</span>
<a name="l00251"></a>00251         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00252"></a>00252         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, wvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00253"></a>00253         <span class="comment">/* setting the ghost point values of the total flow variables */</span>
<a name="l00254"></a>00254         rho_gpt      = boundary-&gt;<a class="code" href="a00004.html#aa92ee9d8efc5ca49f4a83d8dabf0b15d">FlowDensity</a>;
<a name="l00255"></a>00255         pressure_gpt = pressure;
<a name="l00256"></a>00256         uvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0];
<a name="l00257"></a>00257         vvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1];
<a name="l00258"></a>00258         wvel_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[2];
<a name="l00259"></a>00259         energy_gpt   = inv_gamma_m1*pressure_gpt
<a name="l00260"></a>00260                        + 0.5 * rho_gpt 
<a name="l00261"></a>00261                        * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00262"></a>00262         <span class="comment">/* setting the ghost point values of the reference flow variables */</span>
<a name="l00263"></a>00263         rho0_gpt      = boundary-&gt;<a class="code" href="a00004.html#aa92ee9d8efc5ca49f4a83d8dabf0b15d">FlowDensity</a>;
<a name="l00264"></a>00264         pressure0_gpt = pressure0;
<a name="l00265"></a>00265         uvel0_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[0];
<a name="l00266"></a>00266         vvel0_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[1];
<a name="l00267"></a>00267         wvel0_gpt     = boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[2];
<a name="l00268"></a>00268         energy0_gpt   = inv_gamma_m1*pressure0_gpt
<a name="l00269"></a>00269                        + 0.5 * rho0_gpt 
<a name="l00270"></a>00270                        * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt + wvel0_gpt*wvel0_gpt);
<a name="l00271"></a>00271 
<a name="l00272"></a>00272         phi[nvars*p1+0] = rho_gpt            - rho0_gpt;
<a name="l00273"></a>00273         phi[nvars*p1+1] = rho_gpt * uvel_gpt - rho0_gpt * uvel0_gpt;
<a name="l00274"></a>00274         phi[nvars*p1+2] = rho_gpt * vvel_gpt - rho0_gpt * vvel0_gpt;
<a name="l00275"></a>00275         phi[nvars*p1+3] = rho_gpt * wvel_gpt - rho0_gpt * wvel0_gpt;
<a name="l00276"></a>00276         phi[nvars*p1+4] = energy_gpt         - energy0_gpt;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00279"></a>00279       }
<a name="l00280"></a>00280     }
<a name="l00281"></a>00281 
<a name="l00282"></a>00282   }
<a name="l00283"></a>00283   <span class="keywordflow">return</span>(0);
<a name="l00284"></a>00284 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a10fe02e6453d8b7240db5c3dce265163"></a><!-- doxytag: member="boundaryconditions.h::BCSubsonicOutflowDU" ref="a10fe02e6453d8b7240db5c3dce265163" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSubsonicOutflowDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subsonic outflow boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies the subsonic outflow boundary condition to the delta-solution: The pressure at the physical boundary ghost points is specified, while the density and velocity are extrapolated from the interior. This boundary condition is specific to two and three dimensional Euler/Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). <br/>
<br/>
 The delta-solution is added to the reference solution, and the above treatment is applied to this total solution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00081_source.html#l00141">141</a> of file <a class="el" href="a00081_source.html">BCSubsonicOutflow.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00149"></a>00149                                                                                             {\bf U}\f$.*/
<a name="l00150"></a>00150                         <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00151"></a>00151                         <span class="keywordtype">double</span>  waqt      
<a name="l00152"></a>00152                        )
<a name="l00153"></a>00153 {
<a name="l00154"></a>00154   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00157"></a>00157   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00158"></a>00158   <span class="keywordtype">int</span> v;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00161"></a>00161 
<a name="l00162"></a>00162     <span class="comment">/* create a fake physics object */</span>
<a name="l00163"></a>00163     <a class="code" href="a00006.html">Euler2D</a> physics; 
<a name="l00164"></a>00164     <span class="keywordtype">double</span> gamma;
<a name="l00165"></a>00165     gamma = physics.<a class="code" href="a00006.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00166"></a>00166     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00169"></a>00169       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00170"></a>00170       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00171"></a>00171       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00172"></a>00172       <span class="keywordtype">int</span> done = 0;
<a name="l00173"></a>00173       <span class="keywordflow">while</span> (!done) {
<a name="l00174"></a>00174         <span class="keywordtype">int</span> p1, p2;
<a name="l00175"></a>00175         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00176"></a>00176         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00177"></a>00177         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00178"></a>00178         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00179"></a>00179         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00180"></a>00180         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00181"></a>00181         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00182"></a>00182         
<a name="l00183"></a>00183         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00184"></a>00184         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00185"></a>00185         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         <span class="comment">/* flow variables in the interior */</span>
<a name="l00188"></a>00188         <span class="keywordtype">double</span> rho, uvel, vvel, energy, <a class="code" href="a00032.html#a58d87a94271c7f86a36fafc7117fe0b0">pressure</a>;
<a name="l00189"></a>00189         <span class="keywordtype">double</span> rho0, uvel0, vvel0, energy0, pressure0;
<a name="l00190"></a>00190         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>(phi_total,rho,uvel,vvel,energy,pressure,(&amp;physics));
<a name="l00191"></a>00191         <a class="code" href="a00048.html#afff338b9964cae67fd9b3f4dc224e77b">_Euler2DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,energy0,pressure0,(&amp;physics));
<a name="l00192"></a>00192         <span class="comment">/* set the ghost point values */</span>
<a name="l00193"></a>00193         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, energy_gpt, pressure_gpt;
<a name="l00194"></a>00194         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00195"></a>00195         <span class="comment">/* setting the ghost point values of the total flow variables */</span>
<a name="l00196"></a>00196         rho_gpt      = rho;
<a name="l00197"></a>00197         pressure_gpt = pressure; <span class="comment">/* useless statement to avoid compiler warning */</span>
<a name="l00198"></a>00198         pressure_gpt = boundary-&gt;<a class="code" href="a00004.html#a0a3c5af6bdb8fbdb746fd4edb374bb18">FlowPressure</a>;
<a name="l00199"></a>00199         uvel_gpt     = uvel;
<a name="l00200"></a>00200         vvel_gpt     = vvel;
<a name="l00201"></a>00201         energy_gpt   = inv_gamma_m1*pressure_gpt
<a name="l00202"></a>00202                        + 0.5 * rho_gpt * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt);
<a name="l00203"></a>00203         <span class="comment">/* setting the ghost point values of the reference flow variables */</span>
<a name="l00204"></a>00204         rho0_gpt      = rho0;
<a name="l00205"></a>00205         pressure0_gpt = pressure0; <span class="comment">/* useless statement to avoid compiler warning */</span>
<a name="l00206"></a>00206         pressure0_gpt = boundary-&gt;<a class="code" href="a00004.html#a0a3c5af6bdb8fbdb746fd4edb374bb18">FlowPressure</a>;
<a name="l00207"></a>00207         uvel0_gpt     = uvel0;
<a name="l00208"></a>00208         vvel0_gpt     = vvel0;
<a name="l00209"></a>00209         energy0_gpt   = inv_gamma_m1*pressure0_gpt
<a name="l00210"></a>00210                        + 0.5 * rho0_gpt * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt);
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         phi[nvars*p1+0] = rho_gpt            - rho0_gpt;
<a name="l00213"></a>00213         phi[nvars*p1+1] = rho_gpt * uvel_gpt - rho0_gpt * uvel0_gpt;
<a name="l00214"></a>00214         phi[nvars*p1+2] = rho_gpt * vvel_gpt - rho0_gpt * vvel0_gpt;
<a name="l00215"></a>00215         phi[nvars*p1+3] = energy_gpt         - energy0_gpt;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00218"></a>00218       }
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 3) {
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="comment">/* create a fake physics object */</span>
<a name="l00224"></a>00224     <a class="code" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a> physics;
<a name="l00225"></a>00225     <span class="keywordtype">double</span> gamma;
<a name="l00226"></a>00226     gamma = physics.<a class="code" href="a00022.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a> = boundary-&gt;<a class="code" href="a00004.html#a72f9e01745b3a8203067ab84aefc9aea">gamma</a>;
<a name="l00227"></a>00227     <span class="keywordtype">double</span> inv_gamma_m1 = 1.0/(gamma-1.0);
<a name="l00228"></a>00228 
<a name="l00229"></a>00229     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00230"></a>00230       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00231"></a>00231       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00232"></a>00232       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00233"></a>00233       <span class="keywordtype">int</span> done = 0;
<a name="l00234"></a>00234       <span class="keywordflow">while</span> (!done) {
<a name="l00235"></a>00235         <span class="keywordtype">int</span> p1, p2;
<a name="l00236"></a>00236         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00237"></a>00237         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00238"></a>00238         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00239"></a>00239         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00240"></a>00240         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00241"></a>00241         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00242"></a>00242         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00243"></a>00243         
<a name="l00244"></a>00244         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00245"></a>00245         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00246"></a>00246         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00247"></a>00247 
<a name="l00248"></a>00248         <span class="comment">/* flow variables in the interior */</span>
<a name="l00249"></a>00249         <span class="keywordtype">double</span> rho, uvel, vvel, wvel, energy, pressure;
<a name="l00250"></a>00250         <span class="keywordtype">double</span> rho0, uvel0, vvel0, wvel0, energy0, pressure0;
<a name="l00251"></a>00251         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>(phi_total,rho,uvel,vvel,wvel,energy,pressure,(&amp;physics));
<a name="l00252"></a>00252         <a class="code" href="a00055.html#a47cfbfdecf13cd3336cc049cfe93ed45">_NavierStokes3DGetFlowVar_</a>((phi_ref+nvars*p2),rho0,uvel0,vvel0,wvel0,energy0,pressure0,(&amp;physics));
<a name="l00253"></a>00253         <span class="comment">/* set the ghost point values */</span>
<a name="l00254"></a>00254         <span class="keywordtype">double</span> rho_gpt, uvel_gpt, vvel_gpt, wvel_gpt, energy_gpt, pressure_gpt;
<a name="l00255"></a>00255         <span class="keywordtype">double</span> rho0_gpt, uvel0_gpt, vvel0_gpt, wvel0_gpt, energy0_gpt, pressure0_gpt;
<a name="l00256"></a>00256         <span class="comment">/* setting the ghost point values of the total flow variables */</span>
<a name="l00257"></a>00257         rho_gpt      = rho;
<a name="l00258"></a>00258         pressure_gpt = pressure; <span class="comment">/* useless statement to avoid compiler warning */</span>
<a name="l00259"></a>00259         pressure_gpt = boundary-&gt;<a class="code" href="a00004.html#a0a3c5af6bdb8fbdb746fd4edb374bb18">FlowPressure</a>;
<a name="l00260"></a>00260         uvel_gpt     = uvel;
<a name="l00261"></a>00261         vvel_gpt     = vvel;
<a name="l00262"></a>00262         wvel_gpt     = wvel;
<a name="l00263"></a>00263         energy_gpt   = inv_gamma_m1*pressure_gpt
<a name="l00264"></a>00264                        + 0.5 * rho_gpt 
<a name="l00265"></a>00265                        * (uvel_gpt*uvel_gpt + vvel_gpt*vvel_gpt + wvel_gpt*wvel_gpt);
<a name="l00266"></a>00266         <span class="comment">/* setting the ghost point values of the reference flow variables */</span>
<a name="l00267"></a>00267         rho0_gpt      = rho0;
<a name="l00268"></a>00268         pressure0_gpt = pressure0; <span class="comment">/* useless statement to avoid compiler warning */</span>
<a name="l00269"></a>00269         pressure0_gpt = boundary-&gt;<a class="code" href="a00004.html#a0a3c5af6bdb8fbdb746fd4edb374bb18">FlowPressure</a>;
<a name="l00270"></a>00270         uvel0_gpt     = uvel0;
<a name="l00271"></a>00271         vvel0_gpt     = vvel0;
<a name="l00272"></a>00272         wvel0_gpt     = wvel0;
<a name="l00273"></a>00273         energy0_gpt   = inv_gamma_m1*pressure0_gpt
<a name="l00274"></a>00274                        + 0.5 * rho0_gpt 
<a name="l00275"></a>00275                        * (uvel0_gpt*uvel0_gpt + vvel0_gpt*vvel0_gpt + wvel0_gpt*wvel0_gpt);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277         phi[nvars*p1+0] = rho_gpt            - rho0_gpt;
<a name="l00278"></a>00278         phi[nvars*p1+1] = rho_gpt * uvel_gpt - rho0_gpt * uvel0_gpt;
<a name="l00279"></a>00279         phi[nvars*p1+2] = rho_gpt * vvel_gpt - rho0_gpt * vvel0_gpt;
<a name="l00280"></a>00280         phi[nvars*p1+3] = rho_gpt * wvel_gpt - rho0_gpt * wvel0_gpt;
<a name="l00281"></a>00281         phi[nvars*p1+4] = energy_gpt         - energy0_gpt;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00284"></a>00284       }
<a name="l00285"></a>00285     }
<a name="l00286"></a>00286 
<a name="l00287"></a>00287   }
<a name="l00288"></a>00288   <span class="keywordflow">return</span>(0);
<a name="l00289"></a>00289 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a96b73ed205d556b08dd5514c2905bf66"></a><!-- doxytag: member="boundaryconditions.h::BCSubsonicAmbivalentDU" ref="a96b73ed205d556b08dd5514c2905bf66" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSubsonicAmbivalentDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subsonic "ambivalent" boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Not implemented </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00079_source.html#l00238">238</a> of file <a class="el" href="a00079_source.html">BCSubsonicAmbivalent.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00246"></a>00246                                                                                             {\bf U}\f$.*/
<a name="l00247"></a>00247                         <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00248"></a>00248                         <span class="keywordtype">double</span>  waqt      
<a name="l00249"></a>00249                       )
<a name="l00250"></a>00250 {
<a name="l00251"></a>00251   printf(<span class="stringliteral">&quot;ERROR: BCSubsonicAmbivalentDU() not implemented!\n&quot;</span>);
<a name="l00252"></a>00252   <span class="keywordflow">return</span>(0);
<a name="l00253"></a>00253 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2538a6891effbefee21c5b12ab0d81d2"></a><!-- doxytag: member="boundaryconditions.h::BCSupersonicInflowDU" ref="a2538a6891effbefee21c5b12ab0d81d2" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSupersonicInflowDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supersonic inflow boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies the supersonic (steady) inflow boundary condition to the delta-solution: Sets the physical boundary ghost point values for the delta-solution as zero, since inflow is steady. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00082_source.html#l00112">112</a> of file <a class="el" href="a00082_source.html">BCSupersonicInflow.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00120"></a>00120                                                                                               {\bf U}\f$.*/
<a name="l00121"></a>00121                           <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00122"></a>00122                           <span class="keywordtype">double</span>  waqt      
<a name="l00123"></a>00123                         )
<a name="l00124"></a>00124 {
<a name="l00125"></a>00125   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00126"></a>00126   <span class="keywordtype">int</span>             v;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00129"></a>00129     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims];
<a name="l00130"></a>00130     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00131"></a>00131     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0); 
<a name="l00132"></a>00132     <span class="keywordtype">int</span> done = 0;
<a name="l00133"></a>00133     <span class="keywordflow">while</span> (!done) {
<a name="l00134"></a>00134       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size  ,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p);
<a name="l00135"></a>00135       <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi[nvars*p+v] = 0.0;
<a name="l00136"></a>00136       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138   }
<a name="l00139"></a>00139   <span class="keywordflow">return</span>(0);
<a name="l00140"></a>00140 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a82faba0d89e0acc186928eac58633c8d"></a><!-- doxytag: member="boundaryconditions.h::BCSupersonicOutflowDU" ref="a82faba0d89e0acc186928eac58633c8d" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSupersonicOutflowDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supersonic outflow boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies the supersonic outflow boundary condition to the delta-solution: All flow variables are extrapolated from the interior since the outflow is supersonic. This boundary condition is specific to two and three dimensional Euler/Navier-Stokes systems (<a class="el" href="a00006.html">Euler2D</a>, <a class="el" href="a00021.html" title="Structure containing variables and parameters specific to the 2D Navier Stokes equations...">NavierStokes2D</a>, <a class="el" href="a00022.html" title="Structure containing variables and parameters specific to the 3D Navier Stokes equations...">NavierStokes3D</a>). <br/>
<br/>
 Note: The code here is identical to <a class="el" href="a00037.html#ab57c71ca185a63df8ead47c95e4edcf6">BCExtrapolateDU()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00083_source.html#l00143">143</a> of file <a class="el" href="a00083_source.html">BCSupersonicOutflow.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00151"></a>00151                                                                                               {\bf U}\f$.*/
<a name="l00152"></a>00152                           <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00153"></a>00153                           <span class="keywordtype">double</span>  waqt      
<a name="l00154"></a>00154                          )
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00159"></a>00159   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00162"></a>00162     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00163"></a>00163     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00164"></a>00164     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00165"></a>00165     <span class="keywordtype">int</span> done = 0;
<a name="l00166"></a>00166     <span class="keywordflow">while</span> (!done) {
<a name="l00167"></a>00167       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00168"></a>00168       <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00169"></a>00169       <span class="keywordflow">if</span> (face == 1)        indexi[dim] = 0;
<a name="l00170"></a>00170       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1)  indexi[dim] = size[dim]-1;
<a name="l00171"></a>00171       <span class="keywordflow">else</span>                  <span class="keywordflow">return</span>(1);
<a name="l00172"></a>00172       <span class="keywordtype">int</span> p1,p2;
<a name="l00173"></a>00173       <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00174"></a>00174       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00175"></a>00175       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((phi+nvars*p2),(phi+nvars*p1),nvars);
<a name="l00176"></a>00176       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178   }
<a name="l00179"></a>00179   <span class="keywordflow">return</span>(0);
<a name="l00180"></a>00180 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af6c34fe934e480e03af70dcb3493fa32"></a><!-- doxytag: member="boundaryconditions.h::BCTurbulentSupersonicInflowDU" ref="af6c34fe934e480e03af70dcb3493fa32" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCTurbulentSupersonicInflowDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Turbulent Supersonic inflow boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies the turbulent supersonic inflow boundary condition to the delta-solution: In reality, this function just sets the ghost values of the delta-solution to zero, because these functions were written for the shock-turbulence interaction problem and implicit time-integration was not used. Hence this function was never used! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00086_source.html#l00106">106</a> of file <a class="el" href="a00086_source.html">BCTurbulentSupersonicInflow.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00114"></a>00114                                                                                                       {\bf U}\f$.*/
<a name="l00115"></a>00115                                   <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00116"></a>00116                                   <span class="keywordtype">double</span>  waqt      
<a name="l00117"></a>00117                                  )
<a name="l00118"></a>00118 {
<a name="l00119"></a>00119   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00120"></a>00120   <span class="keywordtype">int</span>             v;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00123"></a>00123     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims];
<a name="l00124"></a>00124     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00125"></a>00125     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0); 
<a name="l00126"></a>00126     <span class="keywordtype">int</span> done = 0;
<a name="l00127"></a>00127     <span class="keywordflow">while</span> (!done) {
<a name="l00128"></a>00128       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size  ,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p);
<a name="l00129"></a>00129       <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi[nvars*p+v] = 0.0;
<a name="l00130"></a>00130       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00131"></a>00131     }
<a name="l00132"></a>00132   }
<a name="l00133"></a>00133   <span class="keywordflow">return</span>(0);
<a name="l00134"></a>00134 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a25e802a3f547e50a24af84001d917e76"></a><!-- doxytag: member="boundaryconditions.h::BCNoFluxDU" ref="a25e802a3f547e50a24af84001d917e76" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCNoFluxDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>No-Flux ((inviscid wall) boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies the no-flux boundary conditions to the delta-solution by setting the physical boundary ghost point delta-solution values to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00073_source.html#l00075">75</a> of file <a class="el" href="a00073_source.html">BCNoFlux.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00083"></a>00083                                                                                     {\bf U}\f$.*/
<a name="l00084"></a>00084                 <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00085"></a>00085                 <span class="keywordtype">double</span>  waqt      
<a name="l00086"></a>00086               )
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00091"></a>00091   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00094"></a>00094     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00095"></a>00095     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a> (bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00096"></a>00096     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>   (indexb,ndims,0);
<a name="l00097"></a>00097     <span class="keywordtype">int</span> done = 0;
<a name="l00098"></a>00098     <span class="keywordflow">while</span> (!done) {
<a name="l00099"></a>00099       <span class="keywordtype">int</span> p1, p2;
<a name="l00100"></a>00100       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a> (indexb,indexi,ndims);
<a name="l00101"></a>00101       <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>  (indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00102"></a>00102       <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00103"></a>00103       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00104"></a>00104       <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00105"></a>00105       <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>  (ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00106"></a>00106       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>    (ndims,size,indexi,ghosts,p2);
<a name="l00107"></a>00107       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>   ((phi+nvars*p1),nvars,0.0);
<a name="l00108"></a>00108       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00109"></a>00109     }
<a name="l00110"></a>00110   }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   <span class="keywordflow">return</span>(0);
<a name="l00113"></a>00113 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3413b894a0aeb980868260c11b5e9bb5"></a><!-- doxytag: member="boundaryconditions.h::BCSWSlipWallDU" ref="a3413b894a0aeb980868260c11b5e9bb5" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSWSlipWallDU </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Slip (inviscid) wall boundary conditions for the "delta-solution" vector dU (for use in implicit time-integration)</p>
<p>Applies the slip-wall boundary condition to the delta-solution: This is specific to the one and two dimensional shallow water equations (<a class="el" href="a00026.html" title="Structure containing variables and parameters specific to the 1D Shallow Water equations...">ShallowWater1D</a>, <a class="el" href="a00027.html" title="Structure containing variables and parameters specific to the 2D Shallow Water equations...">ShallowWater2D</a>). It is used for simulating inviscid walls or symmetric boundaries. The height, and tangential velocity at the ghost points are extrapolated from the interior, while the normal velocity at the ghost points is set such that the interpolated value at the boundary face is equal to the specified wall velocity. <br/>
<br/>
 The above treatment is applied on the delta-solution added to the reference solution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00084_source.html#l00124">124</a> of file <a class="el" href="a00084_source.html">BCSWSlipWall.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00132"></a>00132                                                                                      {\bf U}\f$.*/
<a name="l00133"></a>00133                  <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00134"></a>00134                  <span class="keywordtype">double</span>  waqt      
<a name="l00135"></a>00135                 )
<a name="l00136"></a>00136 {
<a name="l00137"></a>00137   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139   <span class="keywordtype">int</span> dim   = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00140"></a>00140   <span class="keywordtype">int</span> face  = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00141"></a>00141   <span class="keywordtype">int</span> v;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143   <span class="keywordflow">if</span> (ndims == 1) {
<a name="l00144"></a>00144 
<a name="l00145"></a>00145     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00146"></a>00146       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00147"></a>00147       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00148"></a>00148       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00149"></a>00149       <span class="keywordtype">int</span> done = 0;
<a name="l00150"></a>00150       <span class="keywordflow">while</span> (!done) {
<a name="l00151"></a>00151         <span class="keywordtype">int</span> p1, p2;
<a name="l00152"></a>00152         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00153"></a>00153         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00154"></a>00154         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00155"></a>00155         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00156"></a>00156         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00157"></a>00157         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00158"></a>00158         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00161"></a>00161         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00162"></a>00162         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00163"></a>00163         
<a name="l00164"></a>00164         <span class="comment">/* flow variables in the interior */</span>
<a name="l00165"></a>00165         <span class="keywordtype">double</span> h , uvel;
<a name="l00166"></a>00166         <span class="keywordtype">double</span> h0, uvel0;
<a name="l00167"></a>00167         <a class="code" href="a00058.html#ab6d0702f0bacbdb3f2644bd1f60938c0">_ShallowWater1DGetFlowVar_</a>(phi_total,h,uvel);
<a name="l00168"></a>00168         <a class="code" href="a00058.html#ab6d0702f0bacbdb3f2644bd1f60938c0">_ShallowWater1DGetFlowVar_</a>((phi_ref+nvars*p2),h0,uvel0);
<a name="l00169"></a>00169         <span class="comment">/* set the ghost point values */</span>
<a name="l00170"></a>00170         <span class="keywordtype">double</span> h_gpt, uvel_gpt;
<a name="l00171"></a>00171         <span class="keywordtype">double</span> h0_gpt, uvel0_gpt;
<a name="l00172"></a>00172         <span class="comment">/* ghost point values of the total flow variables */</span>
<a name="l00173"></a>00173         h_gpt = h;
<a name="l00174"></a>00174         uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00175"></a>00175         <span class="comment">/* ghost point value of the reference flow variables */</span>
<a name="l00176"></a>00176         h0_gpt = h0;
<a name="l00177"></a>00177         uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00178"></a>00178 
<a name="l00179"></a>00179         phi[nvars*p1+0] = h_gpt             - h0_gpt;
<a name="l00180"></a>00180         phi[nvars*p1+1] = h_gpt * uvel_gpt  - h0_gpt * uvel0_gpt;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00183"></a>00183       }
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ndims == 2) {
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00189"></a>00189       <span class="keywordtype">int</span> bounds[ndims], indexb[ndims], indexi[ndims];
<a name="l00190"></a>00190       <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00191"></a>00191       <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0);
<a name="l00192"></a>00192       <span class="keywordtype">int</span> done = 0;
<a name="l00193"></a>00193       <span class="keywordflow">while</span> (!done) {
<a name="l00194"></a>00194         <span class="keywordtype">int</span> p1, p2;
<a name="l00195"></a>00195         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(indexb,indexi,ndims);
<a name="l00196"></a>00196         <a class="code" href="a00034.html#a98a3bb5fda2fcafb70a6288d100a0924">_ArrayAdd1D_</a>(indexi,indexi,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00197"></a>00197         <span class="keywordflow">if</span>      (face ==  1) indexi[dim] = ghosts-1-indexb[dim];
<a name="l00198"></a>00198         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face == -1) indexi[dim] = size[dim]-indexb[dim]-1;
<a name="l00199"></a>00199         <span class="keywordflow">else</span> <span class="keywordflow">return</span>(1);
<a name="l00200"></a>00200         <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p1);
<a name="l00201"></a>00201         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,size,indexi,ghosts,p2);
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         <span class="comment">/* flow in the interior is phi + phi_ref (since phi is DU) */</span>
<a name="l00204"></a>00204         <span class="keywordtype">double</span> phi_total[nvars]; 
<a name="l00205"></a>00205         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) phi_total[v] = phi[nvars*p2+v]+phi_ref[nvars*p2+v];
<a name="l00206"></a>00206         
<a name="l00207"></a>00207         <span class="comment">/* flow variables in the interior */</span>
<a name="l00208"></a>00208         <span class="keywordtype">double</span> h , uvel , vvel;
<a name="l00209"></a>00209         <span class="keywordtype">double</span> h0, uvel0, vvel0;
<a name="l00210"></a>00210         <a class="code" href="a00059.html#a66b88d6a05555a192a0e455ed99341a4">_ShallowWater2DGetFlowVar_</a>(phi_total,h,uvel,vvel);
<a name="l00211"></a>00211         <a class="code" href="a00059.html#a66b88d6a05555a192a0e455ed99341a4">_ShallowWater2DGetFlowVar_</a>((phi_ref+nvars*p2),h0,uvel0,vvel0);
<a name="l00212"></a>00212         <span class="comment">/* set the ghost point values */</span>
<a name="l00213"></a>00213         <span class="keywordtype">double</span> h_gpt, uvel_gpt, vvel_gpt;
<a name="l00214"></a>00214         <span class="keywordtype">double</span> h0_gpt, uvel0_gpt, vvel0_gpt;
<a name="l00215"></a>00215         <span class="comment">/* ghost point values of the total flow variables */</span>
<a name="l00216"></a>00216         h_gpt = h;
<a name="l00217"></a>00217         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00218"></a>00218           uvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel;
<a name="l00219"></a>00219           vvel_gpt = vvel;
<a name="l00220"></a>00220         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00221"></a>00221           uvel_gpt = uvel;
<a name="l00222"></a>00222           vvel_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel;
<a name="l00223"></a>00223         } <span class="keywordflow">else</span> {
<a name="l00224"></a>00224           uvel_gpt = 0.0;
<a name="l00225"></a>00225           vvel_gpt = 0.0;
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227         <span class="comment">/* ghost point value of the reference flow variables */</span>
<a name="l00228"></a>00228         h0_gpt = h0;
<a name="l00229"></a>00229         <span class="keywordflow">if</span> (dim == <a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>) {
<a name="l00230"></a>00230           uvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00047.html#a6a44057228e5f4b86e1c4d04b2a28977">_XDIR_</a>] - uvel0;
<a name="l00231"></a>00231           vvel0_gpt = vvel0;
<a name="l00232"></a>00232         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == <a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>) {
<a name="l00233"></a>00233           uvel0_gpt = uvel0;
<a name="l00234"></a>00234           vvel0_gpt = 2.0*boundary-&gt;<a class="code" href="a00004.html#a0d0d92fab642e1d02a9de254e73a3f21">FlowVelocity</a>[<a class="code" href="a00048.html#a7fd32e06617f4489079bc50ce9bfc00c">_YDIR_</a>] - vvel0;
<a name="l00235"></a>00235         } <span class="keywordflow">else</span> {
<a name="l00236"></a>00236           uvel0_gpt = 0.0;
<a name="l00237"></a>00237           vvel0_gpt = 0.0;
<a name="l00238"></a>00238         }
<a name="l00239"></a>00239 
<a name="l00240"></a>00240         phi[nvars*p1+0] = h_gpt             - h0_gpt;
<a name="l00241"></a>00241         phi[nvars*p1+1] = h_gpt * uvel_gpt  - h0_gpt * uvel0_gpt;
<a name="l00242"></a>00242         phi[nvars*p1+2] = h_gpt * vvel_gpt  - h0_gpt * vvel0_gpt;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244         <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00245"></a>00245       }
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248   }
<a name="l00249"></a>00249   <span class="keywordflow">return</span>(0);
<a name="l00250"></a>00250 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a49368bf44f300143cd9ec18d10b37a23"></a><!-- doxytag: member="boundaryconditions.h::BCSpongeSource" ref="a49368bf44f300143cd9ec18d10b37a23" args="(void *, int, int, int, int *, double *, double *, double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSpongeSource </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>a special BC enforcement - an absorbent sponge - enforced through a source term</p>
<p>Applies the sponge boundary condition: This function computes the source term required to apply a sponge boundary condition that gradually relaxes the solution to a specified state. This boundary condition is different from other boundary conditions in the sense that it is applied at interior grid points (but within the defined sponge zone). <br/>
<br/>
 The source term for the sponge is computed as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} {\bf S}_i &amp;= \sigma_i \left( {\bf U}_i - {\bf U}_{\rm ref} \right),\\ \sigma_i &amp;= \frac {x_i - x_{\rm start}} {x_{\rm end} - x_{\rm start}} \end{align}" src="form_94.png"/>
</p>
<p> where <img class="formulaInl" alt="$i$" src="form_95.png"/> is the grid index along the spatial dimension of the sponge, <img class="formulaInl" alt="${\bf U}_{\rm ref}$" src="form_96.png"/> is the specified state to which the solution is relaxed, and <img class="formulaInl" alt="$x_i$" src="form_97.png"/>, <img class="formulaInl" alt="$x_{\rm start}$" src="form_98.png"/>, and <img class="formulaInl" alt="$x_{\rm end}$" src="form_99.png"/> are the spatial coordinates of the grid point, sponge start, and sponge end, respectively, along the spatial dimension of the sponge. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>grid</em>&nbsp;</td><td>1D array with the spatial coordinates of the grid points, one dimension after the other </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Source term to which the sponge term is added </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00078_source.html#l00026">26</a> of file <a class="el" href="a00078_source.html">BCSponge.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00036"></a>00036 {
<a name="l00037"></a>00037   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00038"></a>00038   <span class="keywordtype">int</span>            dim       = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00039"></a>00039   <span class="keywordtype">int</span>            face      = boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00040"></a>00040   <span class="keywordtype">double</span>         *uref     = boundary-&gt;<a class="code" href="a00004.html#af7eeb4ff3f7c8bc22e0786ddbe62f16d">SpongeValue</a>;
<a name="l00041"></a>00041   <span class="keywordtype">double</span>         *xmin     = boundary-&gt;<a class="code" href="a00004.html#a1e51e79041d5a3dddffb503277703568">xmin</a>;
<a name="l00042"></a>00042   <span class="keywordtype">double</span>         *xmax     = boundary-&gt;<a class="code" href="a00004.html#a7ea24a733beddff902459a07bf91ca67">xmax</a>;
<a name="l00043"></a>00043   <span class="keywordtype">int</span>            v;
<a name="l00044"></a>00044 
<a name="l00045"></a>00045   <span class="keywordflow">if</span> (boundary-&gt;<a class="code" href="a00004.html#a2eec7e4ee612d5edc985ba81453346e1">on_this_proc</a>) {
<a name="l00046"></a>00046     <span class="keywordtype">int</span> bounds[ndims], indexb[ndims];
<a name="l00047"></a>00047     <a class="code" href="a00034.html#ab49d0f261ea751a17d6beca0504daf78">_ArraySubtract1D_</a>(bounds,boundary-&gt;<a class="code" href="a00004.html#a7602de5ebb1b59ec35217e78a35a531e">ie</a>,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ndims);
<a name="l00048"></a>00048     <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(indexb,ndims,0); 
<a name="l00049"></a>00049     <span class="keywordtype">int</span> done = 0;
<a name="l00050"></a>00050     <span class="keywordflow">while</span> (!done) {
<a name="l00051"></a>00051       <span class="keywordtype">int</span> i = indexb[dim] + boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>[dim];
<a name="l00052"></a>00052       <span class="keywordtype">double</span> x, xstart, xend;
<a name="l00053"></a>00053       <a class="code" href="a00036.html#a9aa9bad8531d6733731a850ccc471a42">_GetCoordinate_</a>(dim,i,size,ghosts,grid,x);
<a name="l00054"></a>00054       xstart = xmin[dim];
<a name="l00055"></a>00055       xend   = xmax[dim];
<a name="l00056"></a>00056       <span class="comment">/* calculate sigma */</span>
<a name="l00057"></a>00057       <span class="keywordtype">double</span> sigma;
<a name="l00058"></a>00058       <span class="keywordflow">if</span> (face &gt; 0) sigma = (x - xstart) / (xend - xstart);
<a name="l00059"></a>00059       <span class="keywordflow">else</span>          sigma = (x - xend  ) / (xstart - xend);
<a name="l00060"></a>00060       <span class="comment">/* add to the source term */</span>
<a name="l00061"></a>00061       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#a0739cb538f4d301fad3b45059ddd0738">_ArrayIndex1DWO_</a>(ndims,size,indexb,boundary-&gt;<a class="code" href="a00004.html#a481013ba007a99a4237cde5eeb3c9a29">is</a>,ghosts,p);
<a name="l00062"></a>00062       <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) source[nvars*p+v] -= (sigma * (u[nvars*p+v]-uref[v]));
<a name="l00063"></a>00063       <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds,indexb,done);
<a name="l00064"></a>00064     }
<a name="l00065"></a>00065   }
<a name="l00066"></a>00066   <span class="keywordflow">return</span>(0);
<a name="l00067"></a>00067 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a88f1e5079fc6c8b753e77cc85c21cb5b"></a><!-- doxytag: member="boundaryconditions.h::BCSpongeUDummy" ref="a88f1e5079fc6c8b753e77cc85c21cb5b" args="(void *, void *, int, int, int *, int, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSpongeUDummy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>dummy function that get called during applying BCs - they don't do anything</p>
<p>Dummy function to ensure consistency with the overall boundary condition implementation. The actual sponge boundary condition is implemented by <a class="el" href="a00037.html#a49368bf44f300143cd9ec18d10b37a23">BCSpongeSource()</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00078_source.html#l00073">73</a> of file <a class="el" href="a00078_source.html">BCSponge.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00083"></a>00083 {
<a name="l00084"></a>00084   <span class="keywordflow">return</span>(0);
<a name="l00085"></a>00085 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a22b20fb04eb1b36dcff22fbc58150f20"></a><!-- doxytag: member="boundaryconditions.h::BCSpongeDUDummy" ref="a22b20fb04eb1b36dcff22fbc58150f20" args="(void *, void *, int, int, int *, int, double *, double *, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCSpongeDUDummy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>phi_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>waqt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>dummy function that get called during applying BCs - they don't do anything</p>
<p>Dummy function to ensure consistency with the overall boundary condition implementation. The actual sponge boundary condition is implemented by <a class="el" href="a00037.html#a49368bf44f300143cd9ec18d10b37a23">BCSpongeSource()</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Boundary object of type <a class="el" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndims</em>&nbsp;</td><td>Number of spatial dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvars</em>&nbsp;</td><td>Number of variables/DoFs per grid point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Integer array with the number of grid points in each spatial dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghosts</em>&nbsp;</td><td>Number of ghost points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi</em>&nbsp;</td><td>The solution array on which to apply the boundary condition - Note that this is a delta-solution <img class="formulaInl" alt="$\Delta {\bf U}$" src="form_93.png"/>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phi_ref</em>&nbsp;</td><td>Reference solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waqt</em>&nbsp;</td><td>Current solution time </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00078_source.html#l00091">91</a> of file <a class="el" href="a00078_source.html">BCSponge.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00099"></a>00099                                                                                         {\bf U}\f$.*/
<a name="l00100"></a>00100                     <span class="keywordtype">double</span>  *phi_ref, 
<a name="l00101"></a>00101                     <span class="keywordtype">double</span>  waqt      
<a name="l00102"></a>00102                    )
<a name="l00103"></a>00103 {
<a name="l00104"></a>00104   <span class="keywordflow">return</span>(0);
<a name="l00105"></a>00105 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6cc369236fbfe94bff52c55175cfaba7"></a><!-- doxytag: member="boundaryconditions.h::BCReadTurbulentInflowData" ref="a6cc369236fbfe94bff52c55175cfaba7" args="(void *, void *, int, int, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BCReadTurbulentInflowData </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>DomainSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function to read in unsteady boundary data for turbulent inflow</p>
<p>Read in the turbulent inflow data: The turbulent inflow data needs to be provided as a binary file. For parallel runs, only rank 0 reads the file, and then distributes the data to the other processors. <br/>
<br/>
 This function needs to be better documented. </p>

<p>Definition at line <a class="el" href="a00086_source.html#l00142">142</a> of file <a class="el" href="a00086_source.html">BCTurbulentSupersonicInflow.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00143"></a>00143 {
<a name="l00144"></a>00144   <a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a> *boundary = (<a class="code" href="a00004.html" title="Structure containing the variables and function pointers defining a boundary.">DomainBoundary</a>*) b;
<a name="l00145"></a>00145   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>   *mpi      = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*)   m;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147   <span class="keywordtype">char</span>    *filename     = boundary-&gt;<a class="code" href="a00004.html#a81c76294457e5d469798d16ab027c9a2">UnsteadyDirichletFilename</a>;
<a name="l00148"></a>00148   <span class="keywordtype">int</span>     *inflow_size  = NULL;
<a name="l00149"></a>00149   <span class="keywordtype">double</span>  *inflow_data  = NULL;
<a name="l00150"></a>00150   <span class="keywordtype">double</span>  *buffer       = NULL;
<a name="l00151"></a>00151   
<a name="l00152"></a>00152   <span class="keywordtype">int</span> dim = boundary-&gt;<a class="code" href="a00004.html#a70b5e28b5bc3d1b63a7435c5fe50b837">dim</a>;
<a name="l00153"></a>00153   <span class="keywordtype">int</span> face= boundary-&gt;<a class="code" href="a00004.html#a9582c650f117a06449b5ee368b6762ef">face</a>;
<a name="l00154"></a>00154   <span class="keywordtype">int</span> d;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   <span class="keywordflow">if</span> (!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) {
<a name="l00157"></a>00157 
<a name="l00158"></a>00158     printf(<span class="stringliteral">&quot;Reading turbulent inflow boundary data from %s.\n&quot;</span>,filename);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     FILE *in;
<a name="l00161"></a>00161     <span class="keywordtype">int</span>  ferr;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     <span class="comment">/* calculate the number of processors that sit on unsteady boundary */</span>
<a name="l00164"></a>00164     <span class="keywordtype">int</span> nproc = 1;
<a name="l00165"></a>00165     <span class="keywordflow">for</span> (d=0; d&lt;ndims; d++) nproc *= mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[d]; nproc /= mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dim];
<a name="l00166"></a>00166 
<a name="l00167"></a>00167     in = fopen(filename,<span class="stringliteral">&quot;rb&quot;</span>);
<a name="l00168"></a>00168     <span class="keywordflow">if</span> (!in) {
<a name="l00169"></a>00169       fprintf(stderr,<span class="stringliteral">&quot;Error in BCReadTurbulentInflowData(): cannot open unsteady boundary data file %s.\n&quot;</span>,filename);
<a name="l00170"></a>00170       <span class="keywordflow">return</span>(1);
<a name="l00171"></a>00171     }
<a name="l00172"></a>00172     <span class="keywordtype">int</span> count = 0;
<a name="l00173"></a>00173     <span class="keywordflow">while</span> ((!feof(in)) &amp;&amp; (count &lt; nproc)) {
<a name="l00174"></a>00174       <span class="keywordtype">int</span> rank[ndims], size[ndims];
<a name="l00175"></a>00175       ferr = fread(rank,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),ndims,in);
<a name="l00176"></a>00176       <span class="keywordflow">if</span> (ferr != ndims) {
<a name="l00177"></a>00177         fprintf(stderr,<span class="stringliteral">&quot;Error in BCReadTurbulentInflowData(): Error (1) in file reading, count %d.\n&quot;</span>,count);
<a name="l00178"></a>00178         <span class="keywordflow">return</span>(1);
<a name="l00179"></a>00179       }
<a name="l00180"></a>00180       <span class="keywordflow">if</span> (rank[dim] != (face &gt; 0 ? 0 : mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dim]-1) ) {
<a name="l00181"></a>00181         fprintf(stderr,<span class="stringliteral">&quot;Error in BCReadTurbulentInflowData(): Error (2) in file reading, count %d.\n&quot;</span>,count);
<a name="l00182"></a>00182         <span class="keywordflow">return</span>(1);
<a name="l00183"></a>00183       }
<a name="l00184"></a>00184       ferr = fread(size,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),ndims,in);
<a name="l00185"></a>00185       <span class="keywordflow">if</span> (ferr != ndims) {
<a name="l00186"></a>00186         fprintf(stderr,<span class="stringliteral">&quot;Error in BCReadTurbulentInflowData(): Error (3) in file reading, count %d.\n&quot;</span>,count);
<a name="l00187"></a>00187         <span class="keywordflow">return</span>(1);
<a name="l00188"></a>00188       }
<a name="l00189"></a>00189       <span class="keywordtype">int</span> flag = 1;
<a name="l00190"></a>00190       <span class="keywordflow">for</span> (d=0; d&lt;ndims; d++) <span class="keywordflow">if</span> ((d != dim) &amp;&amp; (size[d] != DomainSize[d])) flag = 0;
<a name="l00191"></a>00191       <span class="keywordflow">if</span> (!flag) {
<a name="l00192"></a>00192         fprintf(stderr,<span class="stringliteral">&quot;Error in BCReadTurbulentInflowData(): Error (4) (dimension mismatch) in file reading, count %d.\n&quot;</span>,count);
<a name="l00193"></a>00193         <span class="keywordflow">return</span>(1);
<a name="l00194"></a>00194       }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196       <span class="keywordtype">int</span> data_size = nvars;
<a name="l00197"></a>00197       <span class="keywordflow">for</span> (d=0; d&lt;ndims; d++) data_size *= size[d];
<a name="l00198"></a>00198       buffer = (<span class="keywordtype">double</span>*) calloc (data_size,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00199"></a>00199       ferr = fread(buffer,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),data_size,in);
<a name="l00200"></a>00200       <span class="keywordflow">if</span> (ferr != data_size) {
<a name="l00201"></a>00201         fprintf(stderr,<span class="stringliteral">&quot;Error in BCReadTurbulentInflowData(): Error (6) in file reading, count %d.\n&quot;</span>,count);
<a name="l00202"></a>00202         <span class="keywordflow">return</span>(1);
<a name="l00203"></a>00203       }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205       <span class="keywordtype">int</span> rank1D = <a class="code" href="a00045.html#a36e2be86c7dc0d9dd088ed2f5842f556">MPIRank1D</a>(ndims,mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>,rank);
<a name="l00206"></a>00206 
<a name="l00207"></a>00207       <span class="keywordflow">if</span> (!rank1D) {
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         <span class="keywordtype">int</span> <a class="code" href="a00031.html#a3c3f941ca00d3a46c402ac279bc0b44e">index</a>[ndims];
<a name="l00210"></a>00210         inflow_size = (<span class="keywordtype">int</span>*) calloc (ndims, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00211"></a>00211         <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(size,inflow_size,ndims);
<a name="l00212"></a>00212         inflow_data = (<span class="keywordtype">double</span>*) calloc (data_size, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00213"></a>00213         <a class="code" href="a00034.html#ac4ae1109cf287763cef63cc38d52589f">ArrayCopynD</a>(ndims,buffer,inflow_data,size,0,0,index,nvars);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215       } <span class="keywordflow">else</span> {
<a name="l00216"></a>00216 <span class="preprocessor">#ifndef serial</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span>        MPI_Request req[2] = {MPI_REQUEST_NULL,MPI_REQUEST_NULL};
<a name="l00218"></a>00218         MPI_Isend(size,ndims,MPI_INT,rank1D,2152,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;req[0]);
<a name="l00219"></a>00219         MPI_Isend(buffer,data_size,MPI_DOUBLE,rank1D,2153,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;req[1]);
<a name="l00220"></a>00220         MPI_Waitall(2,&amp;req[0],MPI_STATUS_IGNORE);
<a name="l00221"></a>00221 <span class="preprocessor">#else</span>
<a name="l00222"></a>00222 <span class="preprocessor"></span>        fprintf(stderr,<span class="stringliteral">&quot;Error in BCReadTurbulentInflowData(): This is a serial run. Invalid (non-zero) rank read.\n&quot;</span>);
<a name="l00223"></a>00223 <span class="preprocessor">#endif</span>
<a name="l00224"></a>00224 <span class="preprocessor"></span>      }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226       free(buffer);
<a name="l00227"></a>00227       count++;
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     <span class="keywordflow">if</span> (count &lt; nproc) {
<a name="l00231"></a>00231       fprintf(stderr,<span class="stringliteral">&quot;Error in BCReadTurbulentInflowData(): missing data in unsteady boundary data file %s.\n&quot;</span>,filename);
<a name="l00232"></a>00232       fprintf(stderr,<span class="stringliteral">&quot;Error in BCReadTurbulentInflowData(): should contain data for %d processors, &quot;</span>, nproc);
<a name="l00233"></a>00233       fprintf(stderr,<span class="stringliteral">&quot;Error in BCReadTurbulentInflowData(): but contains data for %d processors!\n&quot;</span>, count);
<a name="l00234"></a>00234       <span class="keywordflow">return</span>(1);
<a name="l00235"></a>00235     }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     fclose(in);
<a name="l00238"></a>00238 
<a name="l00239"></a>00239   } <span class="keywordflow">else</span> {
<a name="l00240"></a>00240 <span class="preprocessor">#ifndef serial</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dim] == (face &gt; 0 ? 0 : mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dim]-1) ) {
<a name="l00242"></a>00242       MPI_Request req = MPI_REQUEST_NULL;
<a name="l00243"></a>00243       inflow_size = (<span class="keywordtype">int</span>*) calloc (ndims,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00244"></a>00244       MPI_Irecv(inflow_size,ndims,MPI_INT,0,2152,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;req);
<a name="l00245"></a>00245       MPI_Wait(&amp;req,MPI_STATUS_IGNORE);
<a name="l00246"></a>00246       <span class="keywordtype">int</span> data_size = nvars;
<a name="l00247"></a>00247       <span class="keywordflow">for</span> (d=0; d&lt;ndims; d++) data_size *= inflow_size[d];
<a name="l00248"></a>00248       inflow_data = (<span class="keywordtype">double</span>*) calloc (data_size,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00249"></a>00249       MPI_Irecv(inflow_data,data_size,MPI_DOUBLE,0,2153,mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>,&amp;req);
<a name="l00250"></a>00250       MPI_Wait(&amp;req,MPI_STATUS_IGNORE);
<a name="l00251"></a>00251     }
<a name="l00252"></a>00252 <span class="preprocessor">#else</span>
<a name="l00253"></a>00253 <span class="preprocessor"></span>    fprintf(stderr,<span class="stringliteral">&quot;Error in BCReadTurbulentInflowData(): Serial code should not be here!.\n&quot;</span>);
<a name="l00254"></a>00254 <span class="preprocessor">#endif</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>  }
<a name="l00256"></a>00256   
<a name="l00257"></a>00257   boundary-&gt;<a class="code" href="a00004.html#ac3b478217419275ad063182f69cb543d">UnsteadyDirichletSize</a> = inflow_size;
<a name="l00258"></a>00258   boundary-&gt;<a class="code" href="a00004.html#a48f59fc59e6a86d0b4aad842daea9106">UnsteadyDirichletData</a> = inflow_data;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260   <span class="keywordflow">return</span>(0);
<a name="l00261"></a>00261 }
</pre></div></p>

</div>
</div>
</div>
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=10897352; 
var sc_invisible=1; 
var sc_security="83042f57"; 
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
target="_blank"><img class="statcounter"
src="//c.statcounter.com/10897352/0/83042f57/1/"
alt="website statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
