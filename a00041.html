<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>HyPar: include/interpolation.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>include/interpolation.h File Reference</h1>
<p>Definitions for the functions computing the interpolated value of the primitive at the cell interfaces from the cell-centered values.  
<a href="#_details">More...</a></p>

<p><a href="a00041_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">MUSCLParameters</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure of variables/parameters needed by the MUSCL scheme.  <a href="a00020.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">WENOParameters</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure of variables/parameters needed by the WENO-type scheme.  <a href="a00030.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">CompactScheme</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure of variables/parameters needed by the compact schemes.  <a href="a00003.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a19cc54d502757bfed14b373b443f144c">_FIRST_ORDER_UPWIND_</a>&nbsp;&nbsp;&nbsp;&quot;1&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a89694dcc7c48314c98b9636759bb8bee">_SECOND_ORDER_CENTRAL_</a>&nbsp;&nbsp;&nbsp;&quot;2&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a21f7f383e497570fcb71c43f243539d3">_THIRD_ORDER_MUSCL_</a>&nbsp;&nbsp;&nbsp;&quot;muscl3&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a7bc4a755992e5f68efe365591b7a2c02">_FIFTH_ORDER_UPWIND_</a>&nbsp;&nbsp;&nbsp;&quot;upw5&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#ae832e2314ee85139cec9df4ea82aafa2">_FIFTH_ORDER_COMPACT_UPWIND_</a>&nbsp;&nbsp;&nbsp;&quot;cupw5&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#acfeff1b158131390b7129f4a857b15ff">_FIFTH_ORDER_WENO_</a>&nbsp;&nbsp;&nbsp;&quot;weno5&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a175a82b8ae2b24c0ba51e1b1dd68c0e5">_FIFTH_ORDER_CRWENO_</a>&nbsp;&nbsp;&nbsp;&quot;crweno5&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a6d34f5e8aae80a0d2a27ea20368dfef1">_FIFTH_ORDER_HCWENO_</a>&nbsp;&nbsp;&nbsp;&quot;hcweno5&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#aa7752b40155314f9f2c063d4d9d8339d">_CHARACTERISTIC_</a>&nbsp;&nbsp;&nbsp;&quot;characteristic&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#ac1f614645aa891fde12c0ce4354de45d">_COMPONENTS_</a>&nbsp;&nbsp;&nbsp;&quot;components&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a248926a53714d93eb513eb0faea501ce">_WENO_OPTIMAL_WEIGHT_1_</a>&nbsp;&nbsp;&nbsp;0.1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a6670756d96f1f523cee16eed544d053d">_WENO_OPTIMAL_WEIGHT_2_</a>&nbsp;&nbsp;&nbsp;0.6</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a1040ac7b0b8a805ee3888c9534dc0933">_WENO_OPTIMAL_WEIGHT_3_</a>&nbsp;&nbsp;&nbsp;0.3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a231fd73854e7a1db484a2d3ef05d3325">_CRWENO_OPTIMAL_WEIGHT_1_</a>&nbsp;&nbsp;&nbsp;0.2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#ac6c34db3ed9438f08e64dec775065b0a">_CRWENO_OPTIMAL_WEIGHT_2_</a>&nbsp;&nbsp;&nbsp;0.5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a997c514e872a0a80e59ad19ef3d2746a">_CRWENO_OPTIMAL_WEIGHT_3_</a>&nbsp;&nbsp;&nbsp;0.3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a9584e7fc4d65e4dea714697c890cba92">_WENOWeights_v_JS_</a>(w1, w2, w3, c1, c2, c3, m3, m2, m1, p1, p2, weno, N)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a094028d92064eae70f8f31dd4332e547">_WENOWeights_v_M_</a>(w1, w2, w3, c1, c2, c3, m3, m2, m1, p1, p2, weno, N)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a1203c5f21fa26563cf62429e09db8646">_WENOWeights_v_Z_</a>(w1, w2, w3, c1, c2, c3, m3, m2, m1, p1, p2, weno, N)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#ad98f4bd3af977c9a0bc686ba4e6bb15e">_WENOWeights_v_YC_</a>(w1, w2, w3, c1, c2, c3, m3, m2, m1, p1, p2, weno, N)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a0a067c9c4745556845b9bcb7f049b59b">Interp1PrimFirstOrderUpwind</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">1st order upwind reconstruction (component-wise) on a uniform grid  <a href="#a0a067c9c4745556845b9bcb7f049b59b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a697d5c94aa331054c5286492e7fa39c7">Interp1PrimSecondOrderCentral</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2nd order central reconstruction (component-wise) on a uniform grid  <a href="#a697d5c94aa331054c5286492e7fa39c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#ae7eb6a81a164ca0fa2ace3cab2697847">Interp1PrimThirdOrderMUSCL</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3rd order MUSCL scheme with Koren's limiter (component-wise) on a uniform grid  <a href="#ae7eb6a81a164ca0fa2ace3cab2697847"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#aea7c973ffe0c37bca0703c1bf6175aaa">Interp1PrimFifthOrderUpwind</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5th order upwind reconstruction (component-wise) on a uniform grid  <a href="#aea7c973ffe0c37bca0703c1bf6175aaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a3ac2a77b9fa5a50499c285e49cf91344">Interp1PrimFifthOrderCompactUpwind</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5th order compact upwind reconstruction (component-wise) on a uniform grid  <a href="#a3ac2a77b9fa5a50499c285e49cf91344"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#af2195885ad055989a1b2b11655843343">Interp1PrimFifthOrderWENO</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5th order WENO reconstruction (component-wise) on a uniform grid  <a href="#af2195885ad055989a1b2b11655843343"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a33b1e24c12129941b0027a83c543a654">Interp1PrimFifthOrderCRWENO</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5th order CRWENO reconstruction (component-wise) on a uniform grid  <a href="#a33b1e24c12129941b0027a83c543a654"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#ad9c611137cfce1c622c2e9838fb523c8">Interp1PrimFifthOrderHCWENO</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5th order hybrid compact-WENO reconstruction (component-wise) on a uniform grid  <a href="#ad9c611137cfce1c622c2e9838fb523c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a759e07ba8a484c2c6971fc7c6a81a95a">Interp1PrimFirstOrderUpwindChar</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">1st order upwind reconstruction (characteristic-based) on a uniform grid  <a href="#a759e07ba8a484c2c6971fc7c6a81a95a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a963c82116a2a1d6084af3d519b61b896">Interp1PrimSecondOrderCentralChar</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2nd order central reconstruction (characteristic-based) on a uniform grid  <a href="#a963c82116a2a1d6084af3d519b61b896"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a985d08c4fb9bcb71875c697f9e00d6eb">Interp1PrimThirdOrderMUSCLChar</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3rd order MUSCL scheme with Koren's limiter (characteristic-based) on a uniform grid  <a href="#a985d08c4fb9bcb71875c697f9e00d6eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#ade9ece6e934d70cdf29090494440f505">Interp1PrimFifthOrderUpwindChar</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5th order upwind reconstruction (characteristic-based) on a uniform grid  <a href="#ade9ece6e934d70cdf29090494440f505"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a28b8d3ce17676cec19de4f91f989042d">Interp1PrimFifthOrderCompactUpwindChar</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5th order compact upwind reconstruction (characteristic-based) on a uniform grid  <a href="#a28b8d3ce17676cec19de4f91f989042d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#abf3b032fdc8c0e84b86909db9e0b93c3">Interp1PrimFifthOrderWENOChar</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5th order WENO reconstruction (characteristic-based) on a uniform grid  <a href="#abf3b032fdc8c0e84b86909db9e0b93c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#ae2b27971cc952cf3b4959128bef6174b">Interp1PrimFifthOrderCRWENOChar</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5th order CRWENO reconstruction (characteristic-based) on a uniform grid  <a href="#ae2b27971cc952cf3b4959128bef6174b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a91fbe118c8c01fe1d5efa3cea4930589">Interp1PrimFifthOrderHCWENOChar</a> (double *, double *, double *, double *, int, int, void *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5th order hybrid compact-WENO reconstruction (characteristic-based) on a uniform grid  <a href="#a91fbe118c8c01fe1d5efa3cea4930589"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#ae8bfe856abd743f5af925dc03e708ee3">Interp2PrimSecondOrder</a> (double *, double *, int, void *, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2nd order component-wise interpolation of the 2nd primitive on a uniform grid  <a href="#ae8bfe856abd743f5af925dc03e708ee3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a249ae68fb7394160a7a709220b684acb">InterpSetLimiterVar</a> (double *, double *, double *, int, void *, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a22e0ae19117192cae9978a7a741d15a5">MUSCLInitialize</a> (void *, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#aecbe557b2ccc254cdbbd312fc91717be">WENOInitialize</a> (void *, void *, char *, char *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#a37dd034f5e9eb221bd3fd51cc8d1b0f4">WENOCleanup</a> (void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#af255a582e14c5820cf12f9f95b4e28fd">CompactSchemeInitialize</a> (void *, void *, char *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html#acfaa225472f09e2ade88945e909d5893">CompactSchemeCleanup</a> (void *)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Definitions for the functions computing the interpolated value of the primitive at the cell interfaces from the cell-centered values. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Debojyoti Ghosh </dd></dl>

<p>Definition in file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a19cc54d502757bfed14b373b443f144c"></a><!-- doxytag: member="interpolation.h::_FIRST_ORDER_UPWIND_" ref="a19cc54d502757bfed14b373b443f144c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FIRST_ORDER_UPWIND_&nbsp;&nbsp;&nbsp;&quot;1&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>First order upwind scheme: <a class="el" href="a00041.html#a0a067c9c4745556845b9bcb7f049b59b" title="1st order upwind reconstruction (component-wise) on a uniform grid">Interp1PrimFirstOrderUpwind()</a>, <a class="el" href="a00041.html#a759e07ba8a484c2c6971fc7c6a81a95a" title="1st order upwind reconstruction (characteristic-based) on a uniform grid">Interp1PrimFirstOrderUpwindChar()</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00007">7</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a89694dcc7c48314c98b9636759bb8bee"></a><!-- doxytag: member="interpolation.h::_SECOND_ORDER_CENTRAL_" ref="a89694dcc7c48314c98b9636759bb8bee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SECOND_ORDER_CENTRAL_&nbsp;&nbsp;&nbsp;&quot;2&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Second order central scheme: <a class="el" href="a00041.html#a697d5c94aa331054c5286492e7fa39c7" title="2nd order central reconstruction (component-wise) on a uniform grid">Interp1PrimSecondOrderCentral()</a>, <a class="el" href="a00041.html#a963c82116a2a1d6084af3d519b61b896" title="2nd order central reconstruction (characteristic-based) on a uniform grid">Interp1PrimSecondOrderCentralChar()</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00009">9</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a21f7f383e497570fcb71c43f243539d3"></a><!-- doxytag: member="interpolation.h::_THIRD_ORDER_MUSCL_" ref="a21f7f383e497570fcb71c43f243539d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _THIRD_ORDER_MUSCL_&nbsp;&nbsp;&nbsp;&quot;muscl3&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Third order MUSCL scheme with Koren's limiter: <a class="el" href="a00041.html#ae7eb6a81a164ca0fa2ace3cab2697847" title="3rd order MUSCL scheme with Koren&#39;s limiter (component-wise) on a uniform grid...">Interp1PrimThirdOrderMUSCL()</a>, <a class="el" href="a00041.html#a985d08c4fb9bcb71875c697f9e00d6eb" title="3rd order MUSCL scheme with Koren&#39;s limiter (characteristic-based) on a uniform...">Interp1PrimThirdOrderMUSCLChar()</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00011">11</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7bc4a755992e5f68efe365591b7a2c02"></a><!-- doxytag: member="interpolation.h::_FIFTH_ORDER_UPWIND_" ref="a7bc4a755992e5f68efe365591b7a2c02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FIFTH_ORDER_UPWIND_&nbsp;&nbsp;&nbsp;&quot;upw5&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fifth order upwind scheme: <a class="el" href="a00041.html#aea7c973ffe0c37bca0703c1bf6175aaa" title="5th order upwind reconstruction (component-wise) on a uniform grid">Interp1PrimFifthOrderUpwind()</a>, <a class="el" href="a00041.html#ade9ece6e934d70cdf29090494440f505" title="5th order upwind reconstruction (characteristic-based) on a uniform grid">Interp1PrimFifthOrderUpwindChar()</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00013">13</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae832e2314ee85139cec9df4ea82aafa2"></a><!-- doxytag: member="interpolation.h::_FIFTH_ORDER_COMPACT_UPWIND_" ref="ae832e2314ee85139cec9df4ea82aafa2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FIFTH_ORDER_COMPACT_UPWIND_&nbsp;&nbsp;&nbsp;&quot;cupw5&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fifth order compact upwind scheme: <a class="el" href="a00041.html#a3ac2a77b9fa5a50499c285e49cf91344" title="5th order compact upwind reconstruction (component-wise) on a uniform grid">Interp1PrimFifthOrderCompactUpwind()</a>, <a class="el" href="a00041.html#a28b8d3ce17676cec19de4f91f989042d" title="5th order compact upwind reconstruction (characteristic-based) on a uniform grid">Interp1PrimFifthOrderCompactUpwindChar()</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00015">15</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="acfeff1b158131390b7129f4a857b15ff"></a><!-- doxytag: member="interpolation.h::_FIFTH_ORDER_WENO_" ref="acfeff1b158131390b7129f4a857b15ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FIFTH_ORDER_WENO_&nbsp;&nbsp;&nbsp;&quot;weno5&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fifth order Weighted Essentially Non-Oscillatory (WENO) scheme: <a class="el" href="a00041.html#af2195885ad055989a1b2b11655843343" title="5th order WENO reconstruction (component-wise) on a uniform grid">Interp1PrimFifthOrderWENO()</a>, <a class="el" href="a00041.html#abf3b032fdc8c0e84b86909db9e0b93c3" title="5th order WENO reconstruction (characteristic-based) on a uniform grid">Interp1PrimFifthOrderWENOChar()</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00017">17</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a175a82b8ae2b24c0ba51e1b1dd68c0e5"></a><!-- doxytag: member="interpolation.h::_FIFTH_ORDER_CRWENO_" ref="a175a82b8ae2b24c0ba51e1b1dd68c0e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FIFTH_ORDER_CRWENO_&nbsp;&nbsp;&nbsp;&quot;crweno5&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fifth order Compact Reconstruction Weighted Essentially Non-Oscillatory (CRWENO) scheme: <a class="el" href="a00041.html#a33b1e24c12129941b0027a83c543a654" title="5th order CRWENO reconstruction (component-wise) on a uniform grid">Interp1PrimFifthOrderCRWENO()</a>, <a class="el" href="a00041.html#ae2b27971cc952cf3b4959128bef6174b" title="5th order CRWENO reconstruction (characteristic-based) on a uniform grid">Interp1PrimFifthOrderCRWENOChar()</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00019">19</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6d34f5e8aae80a0d2a27ea20368dfef1"></a><!-- doxytag: member="interpolation.h::_FIFTH_ORDER_HCWENO_" ref="a6d34f5e8aae80a0d2a27ea20368dfef1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FIFTH_ORDER_HCWENO_&nbsp;&nbsp;&nbsp;&quot;hcweno5&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fifth order hybrid compact-WENO scheme: <a class="el" href="a00041.html#ad9c611137cfce1c622c2e9838fb523c8" title="5th order hybrid compact-WENO reconstruction (component-wise) on a uniform grid">Interp1PrimFifthOrderHCWENO()</a>, <a class="el" href="a00041.html#a91fbe118c8c01fe1d5efa3cea4930589" title="5th order hybrid compact-WENO reconstruction (characteristic-based) on a uniform...">Interp1PrimFifthOrderHCWENOChar()</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00021">21</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa7752b40155314f9f2c063d4d9d8339d"></a><!-- doxytag: member="interpolation.h::_CHARACTERISTIC_" ref="aa7752b40155314f9f2c063d4d9d8339d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _CHARACTERISTIC_&nbsp;&nbsp;&nbsp;&quot;characteristic&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Characteristic-based interpolation of vectors (Physical model must define left and right eigenvectors) </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00024">24</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac1f614645aa891fde12c0ce4354de45d"></a><!-- doxytag: member="interpolation.h::_COMPONENTS_" ref="ac1f614645aa891fde12c0ce4354de45d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _COMPONENTS_&nbsp;&nbsp;&nbsp;&quot;components&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Component-wise interpolation of vectors </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00025">25</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a248926a53714d93eb513eb0faea501ce"></a><!-- doxytag: member="interpolation.h::_WENO_OPTIMAL_WEIGHT_1_" ref="a248926a53714d93eb513eb0faea501ce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _WENO_OPTIMAL_WEIGHT_1_&nbsp;&nbsp;&nbsp;0.1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optimal value for the first fifth-order WENO weight </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00191">191</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6670756d96f1f523cee16eed544d053d"></a><!-- doxytag: member="interpolation.h::_WENO_OPTIMAL_WEIGHT_2_" ref="a6670756d96f1f523cee16eed544d053d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _WENO_OPTIMAL_WEIGHT_2_&nbsp;&nbsp;&nbsp;0.6</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optimal value for the second fifth-order WENO weight </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00193">193</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1040ac7b0b8a805ee3888c9534dc0933"></a><!-- doxytag: member="interpolation.h::_WENO_OPTIMAL_WEIGHT_3_" ref="a1040ac7b0b8a805ee3888c9534dc0933" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _WENO_OPTIMAL_WEIGHT_3_&nbsp;&nbsp;&nbsp;0.3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optimal value for the third fifth-order WENO weight </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00195">195</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a231fd73854e7a1db484a2d3ef05d3325"></a><!-- doxytag: member="interpolation.h::_CRWENO_OPTIMAL_WEIGHT_1_" ref="a231fd73854e7a1db484a2d3ef05d3325" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _CRWENO_OPTIMAL_WEIGHT_1_&nbsp;&nbsp;&nbsp;0.2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optimal value for the first fifth-order CRWENO weight </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00197">197</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac6c34db3ed9438f08e64dec775065b0a"></a><!-- doxytag: member="interpolation.h::_CRWENO_OPTIMAL_WEIGHT_2_" ref="ac6c34db3ed9438f08e64dec775065b0a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _CRWENO_OPTIMAL_WEIGHT_2_&nbsp;&nbsp;&nbsp;0.5</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optimal value for the second fifth-order CRWENO weight </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00199">199</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a997c514e872a0a80e59ad19ef3d2746a"></a><!-- doxytag: member="interpolation.h::_CRWENO_OPTIMAL_WEIGHT_3_" ref="a997c514e872a0a80e59ad19ef3d2746a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _CRWENO_OPTIMAL_WEIGHT_3_&nbsp;&nbsp;&nbsp;0.3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optimal value for the third fifth-order CRWENO weight </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00201">201</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9584e7fc4d65e4dea714697c890cba92"></a><!-- doxytag: member="interpolation.h::_WENOWeights_v_JS_" ref="a9584e7fc4d65e4dea714697c890cba92" args="(w1, w2, w3, c1, c2, c3, m3, m2, m1, p1, p2, weno, N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _WENOWeights_v_JS_</td>
          <td>(</td>
          <td class="paramtype">w1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">w2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">w3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weno, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    <span class="keywordtype">int</span> idx; \
    <span class="comment">/* calculate smoothness indicators and the WENO weights */</span>\
    <span class="keywordtype">double</span> b1, b2, b3, a1, a2, a3, a_sum_inv; \
    <span class="keywordflow">for</span> (idx=0; idx&lt;N; idx++) { \
      b1 = thirteen_by_twelve*(m3[idx]-2*m2[idx]+m1[idx])*(m3[idx]-2*m2[idx]+m1[idx]) \
           + one_fourth*(m3[idx]-4*m2[idx]+3*m1[idx])*(m3[idx]-4*m2[idx]+3*m1[idx]);  \
      a1 = c1 / ( (b1+weno-&gt;eps) * (b1+weno-&gt;eps) );  \
      b2 = thirteen_by_twelve*(m2[idx]-2*m1[idx]+p1[idx])*(m2[idx]-2*m1[idx]+p1[idx]) \
           + one_fourth*(m2[idx]-p1[idx])*(m2[idx]-p1[idx]);                \
      a2 = c2 / ( (b2+weno-&gt;eps) * (b2+weno-&gt;eps) );  \
      b3 = thirteen_by_twelve*(m1[idx]-2*p1[idx]+p2[idx])*(m1[idx]-2*p1[idx]+p2[idx]) \
           + one_fourth*(3*m1[idx]-4*p1[idx]+p2[idx])*(3*m1[idx]-4*p1[idx]+p2[idx]);  \
      a3 = c3 / ( (b3+weno-&gt;eps) * (b3+weno-&gt;eps) );  \
      a_sum_inv = 1.0 / (a1 + a2 + a3); \
      w1[idx] = a1 * a_sum_inv; \
      w2[idx] = a2 * a_sum_inv; \
      w3[idx] = a3 * a_sum_inv; \
    } \
  }
</pre></div><p>Compute the WENO weights according the the Jiang &amp; Shu formulation: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \omega_k = \frac {a_k} {\sum_{j=1}^3 a_j },\ a_k = \frac {c_k} {\left(\beta_k+\epsilon\right)^p},\ k = 1,2,3, \end{equation}" src="form_4.png"/>
</p>
<p> where <img class="formulaInl" alt="$c_k$" src="form_5.png"/> are the optimal weights, <img class="formulaInl" alt="$p$" src="form_6.png"/> is hardcoded to <img class="formulaInl" alt="$2$" src="form_7.png"/>, and <img class="formulaInl" alt="$\epsilon$" src="form_8.png"/> is an input parameter (<a class="el" href="a00030.html#a974b448c3d0a13d483d36ef15de369b5">WENOParameters::eps</a>) (typically <img class="formulaInl" alt="$10^{-6}$" src="form_9.png"/>). The smoothness indicators <img class="formulaInl" alt="$\beta_k$" src="form_10.png"/> are given by: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray} \beta_1 &amp;=&amp; \frac{13}{12} \left(f_{j-2}-2f_{j-1}+f_j\right)^2 + \frac{1}{4}\left(f_{j-2}-4f_{j-1}+3f_j\right)^2 \\ \beta_2 &amp;=&amp; \frac{13}{12} \left(f_{j-1}-2f_j+f_{j+1}\right)^2 + \frac{1}{4}\left(f_{j-1}-f_{j+1}\right)^2 \\ \beta_3 &amp;=&amp; \frac{13}{12} \left(f_j-2f_{j+1}+f_{j+2}\right)^2 + \frac{1}{4}\left(3f_j-4f_{j+1}+f_{j+2}\right)^2 \end{eqnarray}" src="form_11.png"/>
</p>
<p><b>Notes:</b> + This macro computes the weights for one variable along one grid line.</p>
<p><b>Arguments:</b> + <em>w1</em>, <em>w2</em>,<em>w3</em> are the nonlinear WENO weights. + <em>c1</em>, <em>c2</em>,<em>c3</em> are optimal coefficients. + <em>m3</em>, <em>m2</em>,<em>m1</em>,<em>p1</em>,<em>p2</em> are the function values at stencil points corresponding to the interface j+1/2: j-2,j-1,j,j+1,j+2 + <em>weno</em> is an object of type <a class="el" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a> containing parameters for the WENO method.</p>
<p><b>Reference:</b> + Jiang, Shu, J. Comput. Phys., 1996. <a href="http://dx.doi.org/10.1006/jcph.1996.0130">http://dx.doi.org/10.1006/jcph.1996.0130</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00228">228</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a094028d92064eae70f8f31dd4332e547"></a><!-- doxytag: member="interpolation.h::_WENOWeights_v_M_" ref="a094028d92064eae70f8f31dd4332e547" args="(w1, w2, w3, c1, c2, c3, m3, m2, m1, p1, p2, weno, N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _WENOWeights_v_M_</td>
          <td>(</td>
          <td class="paramtype">w1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">w2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">w3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weno, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    <span class="keywordtype">int</span> idx; \
    <span class="comment">/* calculate smoothness indicators and the WENO weights */</span>\
    <span class="keywordtype">double</span> b1, b2, b3, a1, a2, a3, a_sum_inv; \
    <span class="keywordflow">for</span> (idx=0; idx&lt;N; idx++) { \
      b1 = thirteen_by_twelve*(m3[idx]-2*m2[idx]+m1[idx])*(m3[idx]-2*m2[idx]+m1[idx]) \
           + one_fourth*(m3[idx]-4*m2[idx]+3*m1[idx])*(m3[idx]-4*m2[idx]+3*m1[idx]);  \
      a1 = c1 / ( (b1+weno-&gt;eps) * (b1+weno-&gt;eps) );  \
      b2 = thirteen_by_twelve*(m2[idx]-2*m1[idx]+p1[idx])*(m2[idx]-2*m1[idx]+p1[idx]) \
           + one_fourth*(m2[idx]-p1[idx])*(m2[idx]-p1[idx]);                \
      a2 = c2 / ( (b2+weno-&gt;eps) * (b2+weno-&gt;eps) );  \
      b3 = thirteen_by_twelve*(m1[idx]-2*p1[idx]+p2[idx])*(m1[idx]-2*p1[idx]+p2[idx]) \
           + one_fourth*(3*m1[idx]-4*p1[idx]+p2[idx])*(3*m1[idx]-4*p1[idx]+p2[idx]);  \
      a3 = c3 / ( (b3+weno-&gt;eps) * (b3+weno-&gt;eps) );  \
      a_sum_inv = 1.0 / (a1 + a2 + a3); \
      w1[idx] = a1 * a_sum_inv; \
      w2[idx] = a2 * a_sum_inv; \
      w3[idx] = a3 * a_sum_inv; \
      a1 = w1[idx] * (c1 + c1*c1 - 3*c1*w1[idx] + w1[idx]*w1[idx]) / (c1*c1 + w1[idx]*(1.0-2.0*c1)); \
      a2 = w2[idx] * (c2 + c2*c2 - 3*c2*w2[idx] + w2[idx]*w2[idx]) / (c2*c2 + w2[idx]*(1.0-2.0*c2)); \
      a3 = w3[idx] * (c3 + c3*c3 - 3*c3*w3[idx] + w3[idx]*w3[idx]) / (c3*c3 + w3[idx]*(1.0-2.0*c3)); \
      a_sum_inv = 1.0 / (a1 + a2 + a3); \
      w1[idx] = a1 * a_sum_inv; \
      w2[idx] = a2 * a_sum_inv; \
      w3[idx] = a3 * a_sum_inv; \
    } \
  }
</pre></div><p>Compute the WENO weights according the the Mapped-WENO formulation: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray} \omega_k &amp;=&amp; \frac {a_k} {\sum_{j=1}^3 a_j },\ a_k = \frac {\tilde{\omega}_k \left( c_k + c_k^2 - 3c_k\tilde{\omega}_k + \tilde{\omega}_k^2\right)} {c_k^2 + \tilde{\omega}_k\left(1-2c_k\right)}, \\ \tilde{\omega}_k &amp;=&amp; \frac {\tilde{a}_k} {\sum_{j=1}^3 \tilde{a}_j },\ \tilde{a}_k = \frac {c_k} {\left(\beta_k+\epsilon\right)^p},\ k = 1,2,3, \end{eqnarray}" src="form_12.png"/>
</p>
<p> where <img class="formulaInl" alt="$c_k$" src="form_5.png"/> are the optimal weights, <img class="formulaInl" alt="$p$" src="form_6.png"/> is hardcoded to <img class="formulaInl" alt="$2$" src="form_7.png"/>, and <img class="formulaInl" alt="$\epsilon$" src="form_8.png"/> is an input parameter (<a class="el" href="a00030.html#a974b448c3d0a13d483d36ef15de369b5">WENOParameters::eps</a>) (typically <img class="formulaInl" alt="$10^{-6}$" src="form_9.png"/>). The smoothness indicators <img class="formulaInl" alt="$\beta_k$" src="form_10.png"/> are given by: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray} \beta_1 &amp;=&amp; \frac{13}{12} \left(f_{j-2}-2f_{j-1}+f_j\right)^2 + \frac{1}{4}\left(f_{j-2}-4f_{j-1}+3f_j\right)^2 \\ \beta_2 &amp;=&amp; \frac{13}{12} \left(f_{j-1}-2f_j+f_{j+1}\right)^2 + \frac{1}{4}\left(f_{j-1}-f_{j+1}\right)^2 \\ \beta_3 &amp;=&amp; \frac{13}{12} \left(f_j-2f_{j+1}+f_{j+2}\right)^2 + \frac{1}{4}\left(3f_j-4f_{j+1}+f_{j+2}\right)^2 \end{eqnarray}" src="form_11.png"/>
</p>
<p><b>Notes:</b> + This macro computes the weights for one variable along one grid line.</p>
<p><b>Arguments:-</b> + <em>w1</em>, <em>w2</em>,<em>w3</em> are the nonlinear WENO weights. + <em>c1</em>, <em>c2</em>,<em>c3</em> are optimal coefficients. + <em>m3</em>, <em>m2</em>,<em>m1</em>,<em>p1</em>,<em>p2</em> are the function values at stencil points corresponding to the interface j+1/2: j-2,j-1,j,j+1,j+2 + <em>weno</em> is an object of type <a class="el" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a> containing parameters for the WENO method. + <em>N</em> is the number of interfaces along the grid line on which this WENO-type reconstruction is happening.</p>
<p><b>Reference:</b> + Henrick, Aslam, Powers, J. Comput. Phys., 2005. <a href="http://dx.doi.org/10.1016/j.jcp.2005.01.023">http://dx.doi.org/10.1016/j.jcp.2005.01.023</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00277">277</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1203c5f21fa26563cf62429e09db8646"></a><!-- doxytag: member="interpolation.h::_WENOWeights_v_Z_" ref="a1203c5f21fa26563cf62429e09db8646" args="(w1, w2, w3, c1, c2, c3, m3, m2, m1, p1, p2, weno, N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _WENOWeights_v_Z_</td>
          <td>(</td>
          <td class="paramtype">w1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">w2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">w3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weno, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    <span class="keywordtype">int</span> idx; \
    <span class="comment">/* calculate smoothness indicators and the WENO weights */</span>\
    <span class="keywordtype">double</span> b1, b2, b3, a1, a2, a3, a_sum_inv, tau; \
    <span class="keywordflow">for</span> (idx=0; idx&lt;N; idx++) { \
      b1 = thirteen_by_twelve*(m3[idx]-2*m2[idx]+m1[idx])*(m3[idx]-2*m2[idx]+m1[idx]) \
           + one_fourth*(m3[idx]-4*m2[idx]+3*m1[idx])*(m3[idx]-4*m2[idx]+3*m1[idx]);  \
      b2 = thirteen_by_twelve*(m2[idx]-2*m1[idx]+p1[idx])*(m2[idx]-2*m1[idx]+p1[idx]) \
           + one_fourth*(m2[idx]-p1[idx])*(m2[idx]-p1[idx]);                \
      b3 = thirteen_by_twelve*(m1[idx]-2*p1[idx]+p2[idx])*(m1[idx]-2*p1[idx]+p2[idx]) \
           + one_fourth*(3*m1[idx]-4*p1[idx]+p2[idx])*(3*m1[idx]-4*p1[idx]+p2[idx]);  \
      tau = <a class="code" href="a00043.html#adf1be5ccbb7a2522b4f3a64043c72880">absolute</a>(b3 - b1);  \
      a1 = c1 * (1.0 + (tau/(b1+weno-&gt;eps)) * (tau/(b1+weno-&gt;eps)) );  \
      a2 = c2 * (1.0 + (tau/(b2+weno-&gt;eps)) * (tau/(b2+weno-&gt;eps)) );  \
      a3 = c3 * (1.0 + (tau/(b3+weno-&gt;eps)) * (tau/(b3+weno-&gt;eps)) );  \
      a_sum_inv = 1.0 / (a1 + a2 + a3); \
      w1[idx] = a1 * a_sum_inv; \
      w2[idx] = a2 * a_sum_inv; \
      w3[idx] = a3 * a_sum_inv; \
    } \
  }
</pre></div><p>Compute the WENO weights according the the WENO-Z formulation: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \omega_k = \frac {a_k} {\sum_{j=1}^3 a_j },\ a_k = c_k \left( 1 + \frac{\tau_5}{\beta_k+\epsilon} \right)^p,\ k = 1,2,3, \end{equation}" src="form_13.png"/>
</p>
<p> where <img class="formulaInl" alt="$c_k$" src="form_5.png"/> are the optimal weights, <img class="formulaInl" alt="$p$" src="form_6.png"/> is hardcoded to <img class="formulaInl" alt="$2$" src="form_7.png"/>, and <img class="formulaInl" alt="$\epsilon$" src="form_8.png"/> is an input parameter (<a class="el" href="a00030.html#a974b448c3d0a13d483d36ef15de369b5">WENOParameters::eps</a>) (typically <img class="formulaInl" alt="$10^{-6}$" src="form_9.png"/>). The smoothness indicators <img class="formulaInl" alt="$\beta_k$" src="form_10.png"/> are given by: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray} \beta_1 &amp;=&amp; \frac{13}{12} \left(f_{j-2}-2f_{j-1}+f_j\right)^2 + \frac{1}{4}\left(f_{j-2}-4f_{j-1}+3f_j\right)^2 \\ \beta_2 &amp;=&amp; \frac{13}{12} \left(f_{j-1}-2f_j+f_{j+1}\right)^2 + \frac{1}{4}\left(f_{j-1}-f_{j+1}\right)^2 \\ \beta_3 &amp;=&amp; \frac{13}{12} \left(f_j-2f_{j+1}+f_{j+2}\right)^2 + \frac{1}{4}\left(3f_j-4f_{j+1}+f_{j+2}\right)^2, \end{eqnarray}" src="form_14.png"/>
</p>
<p> and <img class="formulaInl" alt="$\tau_5 = \left|\beta_1 - \beta_3 \right|$" src="form_15.png"/>.</p>
<p><b>Notes:</b> + This macro computes the weights for one variable along one grid line.</p>
<p><b>Arguments:</b> + <em>w1</em>, <em>w2</em>,<em>w3</em> are the nonlinear WENO weights.<br/>
 + <em>c1</em>, <em>c2</em>,<em>c3</em> are optimal coefficients. + <em>m3</em>, <em>m2</em>,<em>m1</em>,<em>p1</em>,<em>p2</em> are the function values at stencil points corresponding to the interface j+1/2: j-2,j-1,j,j+1,j+2 + <em>weno</em> is an object of type <a class="el" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a> containing parameters for the WENO method. + <em>N</em> is the number of interfaces along the grid line on which this WENO-type reconstruction is happening.</p>
<p><b>Reference:</b> + Borges, et. al., An improved weighted essentially non-oscillatory scheme for hyperbolic conservation laws, J. Comput. Phys., 2008. <a href="http://dx.doi.org/10.1016/j.jcp.2007.11.038">http://dx.doi.org/10.1016/j.jcp.2007.11.038</a> + Castro, M., Costa, B., Don, W. S., High order weighted essentially non-oscillatory WENO-Z schemes for hyperbolic conservation laws, J. Comput. Phys., 2011. <a href="http://dx.doi.org/10.1016/j.jcp.2010.11.028">http://dx.doi.org/10.1016/j.jcp.2010.11.028</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00336">336</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad98f4bd3af977c9a0bc686ba4e6bb15e"></a><!-- doxytag: member="interpolation.h::_WENOWeights_v_YC_" ref="ad98f4bd3af977c9a0bc686ba4e6bb15e" args="(w1, w2, w3, c1, c2, c3, m3, m2, m1, p1, p2, weno, N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _WENOWeights_v_YC_</td>
          <td>(</td>
          <td class="paramtype">w1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">w2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">w3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">m1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weno, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    <span class="keywordtype">int</span> idx; \
    <span class="comment">/* calculate smoothness indicators and the WENO weights */</span>\
    <span class="keywordtype">double</span> b1, b2, b3, a1, a2, a3, a_sum_inv, tau; \
    <span class="keywordflow">for</span> (idx=0; idx&lt;N; idx++) { \
      b1 = thirteen_by_twelve*(m3[idx]-2*m2[idx]+m1[idx])*(m3[idx]-2*m2[idx]+m1[idx]) \
           + one_fourth*(m3[idx]-4*m2[idx]+3*m1[idx])*(m3[idx]-4*m2[idx]+3*m1[idx]);  \
      b2 = thirteen_by_twelve*(m2[idx]-2*m1[idx]+p1[idx])*(m2[idx]-2*m1[idx]+p1[idx]) \
           + one_fourth*(m2[idx]-p1[idx])*(m2[idx]-p1[idx]);                \
      b3 = thirteen_by_twelve*(m1[idx]-2*p1[idx]+p2[idx])*(m1[idx]-2*p1[idx]+p2[idx]) \
           + one_fourth*(3*m1[idx]-4*p1[idx]+p2[idx])*(3*m1[idx]-4*p1[idx]+p2[idx]);  \
      tau = (m3[idx]-4*m2[idx]+6*m1[idx]-4*p1[idx]+p2[idx])*(m3[idx]-4*m2[idx]+6*m1[idx]-4*p1[idx]+p2[idx]);  \
      a1 = c1 * (1.0 + (tau/(b1+weno-&gt;eps)) * (tau/(b1+weno-&gt;eps)) );  \
      a2 = c2 * (1.0 + (tau/(b2+weno-&gt;eps)) * (tau/(b2+weno-&gt;eps)) );  \
      a3 = c3 * (1.0 + (tau/(b3+weno-&gt;eps)) * (tau/(b3+weno-&gt;eps)) );  \
      a_sum_inv = 1.0 / (a1 + a2 + a3); \
      w1[idx] = a1 * a_sum_inv; \
      w2[idx] = a2 * a_sum_inv; \
      w3[idx] = a3 * a_sum_inv; \
    } \
  }
</pre></div><p>Compute the WENO weights according the the ESWENO formulation of Yamaleev &amp; Carpenter. Note that only the formulation for the nonlinear weights is adopted and implemented here, not the ESWENO scheme as a whole. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \omega_k = \frac {a_k} {\sum_{j=1}^3 a_j },\ a_k = c_k \left( 1 + \frac{\tau_5}{\beta_k+\epsilon} \right)^p,\ k = 1,2,3, \end{equation}" src="form_13.png"/>
</p>
<p> where <img class="formulaInl" alt="$c_k$" src="form_5.png"/> are the optimal weights, <img class="formulaInl" alt="$p$" src="form_6.png"/> is hardcoded to <img class="formulaInl" alt="$2$" src="form_7.png"/>, and <img class="formulaInl" alt="$\epsilon$" src="form_8.png"/> is an input parameter (<a class="el" href="a00030.html#a974b448c3d0a13d483d36ef15de369b5">WENOParameters::eps</a>) (typically <img class="formulaInl" alt="$10^{-6}$" src="form_9.png"/>). The smoothness indicators <img class="formulaInl" alt="$\beta_k$" src="form_10.png"/> are given by: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray} \beta_1 &amp;=&amp; \frac{13}{12} \left(f_{j-2}-2f_{j-1}+f_j\right)^2 + \frac{1}{4}\left(f_{j-2}-4f_{j-1}+3f_j\right)^2 \\ \beta_2 &amp;=&amp; \frac{13}{12} \left(f_{j-1}-2f_j+f_{j+1}\right)^2 + \frac{1}{4}\left(f_{j-1}-f_{j+1}\right)^2 \\ \beta_3 &amp;=&amp; \frac{13}{12} \left(f_j-2f_{j+1}+f_{j+2}\right)^2 + \frac{1}{4}\left(3f_j-4f_{j+1}+f_{j+2}\right)^2, \end{eqnarray}" src="form_14.png"/>
</p>
<p> and <img class="formulaInl" alt="$\tau_5 = \left( f_{j-2}-4f_{j-1}+6f_j-4f_{j+1}+f_{j+2} \right)^2$" src="form_16.png"/>.</p>
<p><b>Notes:</b> + This macro computes the weights for one variable along one grid line.</p>
<p><b>Arguments:</b> + <em>w1</em>, <em>w2</em>,<em>w3</em> are the nonlinear WENO weights.<br/>
 + <em>c1</em>, <em>c2</em>,<em>c3</em> are optimal coefficients.<br/>
 + <em>m3</em>, <em>m2</em>,<em>m1</em>,<em>p1</em>,<em>p2</em> are the function values at stencil points corresponding to the interface j+1/2: j-2,j-1,j,j+1,j+2<br/>
 + <em>weno</em> is an object of type <a class="el" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a> containing parameters for the WENO method.<br/>
 + <em>N</em> is the number of interfaces along the grid line on which this WENO-type reconstruction is happening.<br/>
</p>
<p><b>Reference:</b> + Yamaleev, Carpenter, A systematic methodology for constructing high-order energy stable WENO schemes, J. Comput. Phys., 2009. <a href="http://dx.doi.org/10.1016/j.jcp.2009.03.002">http://dx.doi.org/10.1016/j.jcp.2009.03.002</a> </p>

<p>Definition at line <a class="el" href="a00041_source.html#l00389">389</a> of file <a class="el" href="a00041_source.html">interpolation.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0a067c9c4745556845b9bcb7f049b59b"></a><!-- doxytag: member="interpolation.h::Interp1PrimFirstOrderUpwind" ref="a0a067c9c4745556845b9bcb7f049b59b" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFirstOrderUpwind </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>1st order upwind reconstruction (component-wise) on a uniform grid </p>
<p>Component-wise interpolation of the first primitive at the cell interfaces using the first-order upwind scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the 1st order upwind scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 1st order upwind numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = \left\{\begin{array}{cc} {\bf f}_{j} &amp; {\rm upw} > 0 \\ {\bf f}_{j+1} &amp; {\rm upw} \le 0 \end{array}\right.. \end{equation}" src="form_169.png"/>
</p>
<p><b>Implementation</b> <b>Notes:</b> + The scalar interpolation method is applied to the vector function in a component-wise manner. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00139_source.html#l00061">61</a> of file <a class="el" href="a00139_source.html">Interp1PrimFirstOrderUpwind.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00063"></a>00063                                                                                                    {\bf f}\left({\bf u}\right)\f$ */
<a name="l00064"></a>00064                                 <span class="keywordtype">double</span> *u,   
<a name="l00065"></a>00065                                 <span class="keywordtype">double</span> *x,   
<a name="l00066"></a>00066                                 <span class="keywordtype">int</span>    upw,  
<a name="l00067"></a>00067                                 <span class="keywordtype">int</span>    dir,  
<a name="l00068"></a>00068                                 <span class="keywordtype">void</span>   *s,   
<a name="l00069"></a>00069                                 <span class="keywordtype">void</span>   *m,   
<a name="l00070"></a>00070                                 <span class="keywordtype">int</span>    uflag 
<a name="l00071"></a>00071                                )
<a name="l00072"></a>00072 {
<a name="l00073"></a>00073   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>         *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)        s;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00076"></a>00076   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00077"></a>00077   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00078"></a>00078   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00081"></a>00081 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00082"></a>00082   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00083"></a>00083   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00084"></a>00084   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00085"></a>00085   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00086"></a>00086 
<a name="l00087"></a>00087   <span class="keywordtype">int</span> i;
<a name="l00088"></a>00088 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,index_outer,indexC,indexI)</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00090"></a>00090     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00091"></a>00091     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00092"></a>00092     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00093"></a>00093     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00094"></a>00094       indexC[dir] = (upw &gt; 0 ? indexI[dir]-1 : indexI[dir]);
<a name="l00095"></a>00095       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0     ,p);
<a name="l00096"></a>00096       <span class="keywordtype">int</span> q; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim         ,indexC,ghosts,q);
<a name="l00097"></a>00097       <span class="keywordtype">int</span> v; <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++)  fI[p*nvars+v] = fC[q*nvars+v];
<a name="l00098"></a>00098     }
<a name="l00099"></a>00099   }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   <span class="keywordflow">return</span>(0);
<a name="l00102"></a>00102 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a697d5c94aa331054c5286492e7fa39c7"></a><!-- doxytag: member="interpolation.h::Interp1PrimSecondOrderCentral" ref="a697d5c94aa331054c5286492e7fa39c7" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimSecondOrderCentral </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>2nd order central reconstruction (component-wise) on a uniform grid </p>
<p>Component-wise interpolation of the first primitive at the cell interfaces using the second-order central scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the 2nd order central scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 2nd order central numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = \frac{1}{2}\left( {\bf f}_{j} + {\bf f}_{j+1} \right). \end{equation}" src="form_171.png"/>
</p>
<p><b>Implementation</b> <b>Notes:</b> + The scalar interpolation method is applied to the vector function in a component-wise manner. + Since this is a central scheme, the input argument <b>upw</b> has no effect. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00141_source.html#l00062">62</a> of file <a class="el" href="a00141_source.html">Interp1PrimSecondOrderCentral.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00064"></a>00064                                                                                                        {\bf f}\left({\bf u}\right)\f$ */
<a name="l00065"></a>00065                                     <span class="keywordtype">double</span> *u,   
<a name="l00066"></a>00066                                     <span class="keywordtype">double</span> *x,   
<a name="l00067"></a>00067                                     <span class="keywordtype">int</span>    upw,  
<a name="l00068"></a>00068                                     <span class="keywordtype">int</span>    dir,  
<a name="l00069"></a>00069                                     <span class="keywordtype">void</span>   *s,   
<a name="l00070"></a>00070                                     <span class="keywordtype">void</span>   *m,   
<a name="l00071"></a>00071                                     <span class="keywordtype">int</span>    uflag 
<a name="l00072"></a>00072                                  )
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>         *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)        s;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00077"></a>00077   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00078"></a>00078   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00079"></a>00079   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00082"></a>00082 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00083"></a>00083   <span class="keywordtype">int</span> indexL[ndims], indexR[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00084"></a>00084   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00085"></a>00085   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00086"></a>00086   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088   <span class="keywordtype">int</span> i;
<a name="l00089"></a>00089 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,index_outer,indexL,indexR,indexI)</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00091"></a>00091     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00092"></a>00092     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexL,ndims);
<a name="l00093"></a>00093     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexR,ndims);
<a name="l00094"></a>00094     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00095"></a>00095     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00096"></a>00096       indexL[dir] = indexI[dir]-1;
<a name="l00097"></a>00097       indexR[dir] = indexI[dir];
<a name="l00098"></a>00098       <span class="keywordtype">int</span> p;  <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0     ,p);
<a name="l00099"></a>00099       <span class="keywordtype">int</span> qL; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim         ,indexL,ghosts,qL);
<a name="l00100"></a>00100       <span class="keywordtype">int</span> qR; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim         ,indexR,ghosts,qR);
<a name="l00101"></a>00101       <span class="keywordtype">int</span> v; <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++)  fI[p*nvars+v] = 0.5*(fC[qL*nvars+v]+fC[qR*nvars+v]);
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103   }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105   <span class="keywordflow">return</span>(0);
<a name="l00106"></a>00106 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae7eb6a81a164ca0fa2ace3cab2697847"></a><!-- doxytag: member="interpolation.h::Interp1PrimThirdOrderMUSCL" ref="ae7eb6a81a164ca0fa2ace3cab2697847" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimThirdOrderMUSCL </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>3rd order MUSCL scheme with Koren's limiter (component-wise) on a uniform grid </p>
<p>Component-wise interpolation of the first primitive at the cell interfaces using the third-order MUSCL scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the 3rd order MUSCL scheme with Koren's limiter on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as: using the 3rd order MUSCL scheme with Koren's limiter as follows: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = {\bf f}_{j-1} + \phi \left[\frac{1}{3}\left({\bf f}_j-{\bf f}_{j-1}\right) + \frac{1}{6}\left({\bf f}_{j-1}-{\bf f}_{j-2}\right)\right] \end{equation}" src="form_173.png"/>
</p>
<p> where </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \phi = \frac {3\left({\bf f}_j-{\bf f}_{j-1}\right)\left({\bf f}_{j-1}-{\bf f}_{j-2}\right) + \epsilon} {2\left[\left({\bf f}_j-{\bf f}_{j-1}\right)-\left({\bf f}_{j-1}-{\bf f}_{j-2}\right)\right]^2 + 3\left({\bf f}_j-{\bf f}_{j-1}\right)\left({\bf f}_{j-1}-{\bf f}_{j-2}\right) + \epsilon}. \end{equation}" src="form_174.png"/>
</p>
<p> and <img class="formulaInl" alt="$\epsilon$" src="form_8.png"/> is a small constant (typically <img class="formulaInl" alt="$10^{-3}$" src="form_175.png"/>).</p>
<p><b>Implementation</b> <b>Notes:</b> + The scalar interpolation method is applied to the vector function in a component-wise manner. + The method described above corresponds to a left-biased interpolation. The corresponding right-biased interpolation can be obtained by reflecting the equations about interface j+1/2. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p>Reference: + van Leer, B., Towards the Ultimate Conservative Difference Scheme. 2: Monotonicity and Conservation Combined in a Second-Order Scheme, J. of Comput. Phys., 14 (4), 1974, pp.361-370, <a href="http://dx.doi.org/10.1016/0021-9991(74)">http://dx.doi.org/10.1016/0021-9991(74)</a>90019-9 + Koren, B., A Robust Upwind Discretization Method for Advection, Diffusion and Source Terms, Centrum voor Wiskunde en Informatica, Amsterdam, 1993 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00143_source.html#l00075">75</a> of file <a class="el" href="a00143_source.html">Interp1PrimThirdOrderMUSCL.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00077"></a>00077                                                                                                    {\bf f}\left({\bf u}\right)\f$ */
<a name="l00078"></a>00078                                 <span class="keywordtype">double</span> *u,   
<a name="l00079"></a>00079                                 <span class="keywordtype">double</span> *x,   
<a name="l00080"></a>00080                                 <span class="keywordtype">int</span>    upw,  
<a name="l00081"></a>00081                                 <span class="keywordtype">int</span>    dir,  
<a name="l00082"></a>00082                                 <span class="keywordtype">void</span>   *s,   
<a name="l00083"></a>00083                                 <span class="keywordtype">void</span>   *m,   
<a name="l00084"></a>00084                                 <span class="keywordtype">int</span>    uflag 
<a name="l00085"></a>00085                               )
<a name="l00086"></a>00086 {
<a name="l00087"></a>00087   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)          s;
<a name="l00088"></a>00088   <a class="code" href="a00020.html" title="Structure of variables/parameters needed by the MUSCL scheme.">MUSCLParameters</a> *muscl  = (<a class="code" href="a00020.html" title="Structure of variables/parameters needed by the MUSCL scheme.">MUSCLParameters</a>*) solver-&gt;<a class="code" href="a00015.html#a29c46b81ad574e4dfbad5a7211487dcb">interp</a>;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00091"></a>00091   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00092"></a>00092   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00093"></a>00093   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095   <span class="comment">/* define some constants */</span>
<a name="l00096"></a>00096   <span class="keywordtype">double</span> one_third = 1.0/3.0;
<a name="l00097"></a>00097   <span class="keywordtype">double</span> one_sixth = 1.0/6.0;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00100"></a>00100 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00101"></a>00101   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00102"></a>00102   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00103"></a>00103   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00104"></a>00104   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00105"></a>00105 
<a name="l00106"></a>00106   <span class="keywordtype">int</span> i;
<a name="l00107"></a>00107   <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00108"></a>00108 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,index_outer,indexC,indexI)</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00110"></a>00110       <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00111"></a>00111       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00112"></a>00112       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00113"></a>00113       <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00114"></a>00114         <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00115"></a>00115         <span class="keywordtype">int</span> qm1,qm2,qp1,v;
<a name="l00116"></a>00116         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00117"></a>00117         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00118"></a>00118         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00119"></a>00119         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++)  {
<a name="l00120"></a>00120           <span class="comment">/* Defining stencil points */</span>
<a name="l00121"></a>00121           <span class="keywordtype">double</span> m2, m1, p1;
<a name="l00122"></a>00122           m2 = fC[qm2*nvars+v];
<a name="l00123"></a>00123           m1 = fC[qm1*nvars+v];
<a name="l00124"></a>00124           p1 = fC[qp1*nvars+v];
<a name="l00125"></a>00125 
<a name="l00126"></a>00126           <span class="keywordtype">double</span> fdiff = p1 - m1;
<a name="l00127"></a>00127           <span class="keywordtype">double</span> bdiff = m1 - m2;
<a name="l00128"></a>00128           <span class="keywordtype">double</span> limit =  (3*fdiff*bdiff + muscl-&gt;<a class="code" href="a00020.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>) 
<a name="l00129"></a>00129                         / (2*(fdiff-bdiff)*(fdiff-bdiff) + 3*fdiff*bdiff + muscl-&gt;<a class="code" href="a00020.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>);
<a name="l00130"></a>00130 
<a name="l00131"></a>00131           fI[p*nvars+v] = m1 +  limit * (one_third*fdiff + one_sixth*bdiff);
<a name="l00132"></a>00132         }
<a name="l00133"></a>00133       }
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135   } <span class="keywordflow">else</span> {
<a name="l00136"></a>00136 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,index_outer,indexC,indexI)</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00138"></a>00138       <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00139"></a>00139       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00140"></a>00140       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00141"></a>00141       <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00142"></a>00142         <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00143"></a>00143         <span class="keywordtype">int</span> qm1,qp1,qp2,v;
<a name="l00144"></a>00144         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00145"></a>00145         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00146"></a>00146         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00147"></a>00147         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++)  {
<a name="l00148"></a>00148           <span class="comment">/* Defining stencil points */</span>
<a name="l00149"></a>00149           <span class="keywordtype">double</span> m1, p1, p2;
<a name="l00150"></a>00150           m1 = fC[qm1*nvars+v];
<a name="l00151"></a>00151           p1 = fC[qp1*nvars+v];
<a name="l00152"></a>00152           p2 = fC[qp2*nvars+v];
<a name="l00153"></a>00153 
<a name="l00154"></a>00154           <span class="keywordtype">double</span> fdiff = p2 - p1;
<a name="l00155"></a>00155           <span class="keywordtype">double</span> bdiff = p1 - m1;
<a name="l00156"></a>00156           <span class="keywordtype">double</span> limit =  (3*fdiff*bdiff + muscl-&gt;<a class="code" href="a00020.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>) 
<a name="l00157"></a>00157                         / (2*(fdiff-bdiff)*(fdiff-bdiff) + 3*fdiff*bdiff + muscl-&gt;<a class="code" href="a00020.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>);
<a name="l00158"></a>00158 
<a name="l00159"></a>00159           fI[p*nvars+v] = p1 -  limit * (one_third*fdiff + one_sixth*bdiff);
<a name="l00160"></a>00160         }
<a name="l00161"></a>00161       }
<a name="l00162"></a>00162     }
<a name="l00163"></a>00163   }
<a name="l00164"></a>00164   
<a name="l00165"></a>00165   <span class="keywordflow">return</span>(0);
<a name="l00166"></a>00166 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aea7c973ffe0c37bca0703c1bf6175aaa"></a><!-- doxytag: member="interpolation.h::Interp1PrimFifthOrderUpwind" ref="aea7c973ffe0c37bca0703c1bf6175aaa" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFifthOrderUpwind </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5th order upwind reconstruction (component-wise) on a uniform grid </p>
<p>Component-wise interpolation of the first primitive at the cell interfaces using the fifth-order upwind scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the fifth order upwind scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 5th order upwind numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \hat{\bf f}_{j+1/2} = \frac{1}{30} {\bf f}_{j-2} - \frac{13}{60}{\bf f}_{j-1} + \frac{47}{60}{\bf f}_j + \frac{27}{60}{\bf f}_{j+1} - \frac{1}{20}{\bf f}_{j+2}. \end{align}" src="form_165.png"/>
</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + The method described above corresponds to a left-biased interpolation. The corresponding right-biased interpolation can be obtained by reflecting the equations about interface j+1/2. + The scalar interpolation method is applied to the vector function in a component-wise manner. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p><b>Reference:</b> + Jiang, G.-S., Shu, C.-W., Efficient Implementation of Weighted ENO Schemes, J. Comput. Phys., 126 (1), 1996, pp. 202-228, <a href="http://dx.doi.org/10.1006/jcph.1996.0130">http://dx.doi.org/10.1006/jcph.1996.0130</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00135_source.html#l00068">68</a> of file <a class="el" href="a00135_source.html">Interp1PrimFifthOrderUpwind.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00070"></a>00070                                                                                                    {\bf f}\left({\bf u}\right)\f$ */
<a name="l00071"></a>00071                                 <span class="keywordtype">double</span> *u,   
<a name="l00072"></a>00072                                 <span class="keywordtype">double</span> *x,   
<a name="l00073"></a>00073                                 <span class="keywordtype">int</span>    upw,  
<a name="l00074"></a>00074                                 <span class="keywordtype">int</span>    dir,  
<a name="l00075"></a>00075                                 <span class="keywordtype">void</span>   *s,   
<a name="l00076"></a>00076                                 <span class="keywordtype">void</span>   *m,   
<a name="l00077"></a>00077                                 <span class="keywordtype">int</span>    uflag 
<a name="l00078"></a>00078                                )
<a name="l00079"></a>00079 {
<a name="l00080"></a>00080   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)          s;
<a name="l00081"></a>00081 
<a name="l00082"></a>00082   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00083"></a>00083   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00084"></a>00084   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00085"></a>00085   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00086"></a>00086   <span class="keywordtype">int</span> *stride= solver-&gt;<a class="code" href="a00015.html#a39dc7def53a36bdc722aa90f52e04561">stride_with_ghosts</a>;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088   <span class="comment">/* define some constants */</span>
<a name="l00089"></a>00089   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_by_thirty        = 1.0/30.0,
<a name="l00090"></a>00090                       thirteen_by_sixty    = 13.0/60.0,
<a name="l00091"></a>00091                       fortyseven_by_sixty  = 47.0/60.0,
<a name="l00092"></a>00092                       twentyseven_by_sixty = 27.0/60.0,
<a name="l00093"></a>00093                       one_by_twenty        = 1.0/20.0;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00096"></a>00096 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00097"></a>00097   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00098"></a>00098   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00099"></a>00099   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00100"></a>00100   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00101"></a>00101 
<a name="l00102"></a>00102   <span class="keywordtype">int</span> i;
<a name="l00103"></a>00103 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,index_outer,indexC,indexI)</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00105"></a>00105     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00106"></a>00106     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00107"></a>00107     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00108"></a>00108     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00109"></a>00109       <span class="keywordtype">int</span> qm1,qm2,qm3,qp1,qp2,p;
<a name="l00110"></a>00110       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00111"></a>00111       <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00112"></a>00112         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00113"></a>00113         qm3 = qm1 - 2*stride[dir];
<a name="l00114"></a>00114         qm2 = qm1 -   stride[dir];
<a name="l00115"></a>00115         qp1 = qm1 +   stride[dir];
<a name="l00116"></a>00116         qp2 = qm1 + 2*stride[dir];
<a name="l00117"></a>00117       } <span class="keywordflow">else</span> {
<a name="l00118"></a>00118         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00119"></a>00119         qm3 = qm1 + 2*stride[dir];
<a name="l00120"></a>00120         qm2 = qm1 +   stride[dir];
<a name="l00121"></a>00121         qp1 = qm1 -   stride[dir];
<a name="l00122"></a>00122         qp2 = qm1 - 2*stride[dir];
<a name="l00123"></a>00123       }
<a name="l00124"></a>00124 
<a name="l00125"></a>00125       <span class="comment">/* Defining stencil points */</span>
<a name="l00126"></a>00126       <span class="keywordtype">double</span> *fm3, *fm2, *fm1, *fp1, *fp2;
<a name="l00127"></a>00127       fm3 = (fC+qm3*nvars);
<a name="l00128"></a>00128       fm2 = (fC+qm2*nvars);
<a name="l00129"></a>00129       fm1 = (fC+qm1*nvars);
<a name="l00130"></a>00130       fp1 = (fC+qp1*nvars);
<a name="l00131"></a>00131       fp2 = (fC+qp2*nvars);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133       <span class="keywordtype">int</span> v;
<a name="l00134"></a>00134       <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) {
<a name="l00135"></a>00135         (fI+p*nvars)[v] =   one_by_thirty         * fm3[v]
<a name="l00136"></a>00136                           - thirteen_by_sixty     * fm2[v]
<a name="l00137"></a>00137                           + fortyseven_by_sixty   * fm1[v]
<a name="l00138"></a>00138                           + twentyseven_by_sixty  * fp1[v]
<a name="l00139"></a>00139                           - one_by_twenty         * fp2[v];
<a name="l00140"></a>00140       }
<a name="l00141"></a>00141     }
<a name="l00142"></a>00142   }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="keywordflow">return</span>(0);
<a name="l00145"></a>00145 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3ac2a77b9fa5a50499c285e49cf91344"></a><!-- doxytag: member="interpolation.h::Interp1PrimFifthOrderCompactUpwind" ref="a3ac2a77b9fa5a50499c285e49cf91344" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFifthOrderCompactUpwind </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5th order compact upwind reconstruction (component-wise) on a uniform grid </p>
<p>Component-wise interpolation of the first primitive at the cell interfaces using the fifth-order compact upwind scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the fifth order compact upwind scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 5th order compact upwind numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \frac{3}{10}\hat{\bf f}_{j-1/2} + \frac{6}{10}\hat{\bf f}_{j+1/2} + \frac{1}{10}\hat{\bf f}_{j+3/2} = \frac{1}{30}{\bf f}_{j-1} + \frac{19}{30}{\bf f}_j + \frac{1}{3}{\bf f}_{j+1}. \end{align}" src="form_149.png"/>
</p>
<p> The resulting tridiagonal system is solved using <a class="el" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU()</a> (see also <a class="el" href="a00029.html">TridiagLU</a>, <a class="el" href="a00062.html" title="Header file for TridiagLU.">tridiagLU.h</a>).</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + The method described above corresponds to a left-biased interpolation. The corresponding right-biased interpolation can be obtained by reflecting the equations about interface j+1/2. + The scalar interpolation method is applied to the vector function in a component-wise manner. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p><b>Reference:</b> + Ghosh, D., Baeder, J. D., Compact Reconstruction Schemes with Weighted ENO Limiting for Hyperbolic Conservation Laws, SIAM Journal on Scientific Computing, 34 (3), 2012, A1678–A1706, <a href="http://dx.doi.org/10.1137/110857659">http://dx.doi.org/10.1137/110857659</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00129_source.html#l00072">72</a> of file <a class="el" href="a00129_source.html">Interp1PrimFifthOrderCompactUpwind.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00074"></a>00074                                                                                                            {\bf f}\left({\bf u}\right)\f$ */
<a name="l00075"></a>00075                                         <span class="keywordtype">double</span> *u,   
<a name="l00076"></a>00076                                         <span class="keywordtype">double</span> *x,   
<a name="l00077"></a>00077                                         <span class="keywordtype">int</span>    upw,  
<a name="l00078"></a>00078                                         <span class="keywordtype">int</span>    dir,  
<a name="l00079"></a>00079                                         <span class="keywordtype">void</span>   *s,   
<a name="l00080"></a>00080                                         <span class="keywordtype">void</span>   *m,   
<a name="l00081"></a>00081                                         <span class="keywordtype">int</span>    uflag 
<a name="l00082"></a>00082                                       )
<a name="l00083"></a>00083 {
<a name="l00084"></a>00084   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)          s;
<a name="l00085"></a>00085   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>    *mpi    = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*)   m;
<a name="l00086"></a>00086   <a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>   *compact= (<a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>*)  solver-&gt;<a class="code" href="a00015.html#a56318721d534e74a96b440f8542a0232">compact</a>;
<a name="l00087"></a>00087   <a class="code" href="a00029.html">TridiagLU</a>       *lu     = (<a class="code" href="a00029.html">TridiagLU</a>*)      solver-&gt;<a class="code" href="a00015.html#a1dbfa1e479a373073b6ebf72401a7f0f">lusolver</a>;
<a name="l00088"></a>00088   <span class="keywordtype">int</span>             sys,Nsys,d,v;
<a name="l00089"></a>00089   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00092"></a>00092   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00093"></a>00093   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00094"></a>00094   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00095"></a>00095   <span class="keywordtype">int</span> *stride= solver-&gt;<a class="code" href="a00015.html#a39dc7def53a36bdc722aa90f52e04561">stride_with_ghosts</a>;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097   <span class="comment">/* define some constants */</span>
<a name="l00098"></a>00098   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_third            = 1.0/3.0,
<a name="l00099"></a>00099                       thirteen_by_sixty    = 13.0/60.0,
<a name="l00100"></a>00100                       fortyseven_by_sixty  = 47.0/60.0,
<a name="l00101"></a>00101                       twentyseven_by_sixty = 27.0/60.0,
<a name="l00102"></a>00102                       one_by_twenty        = 1.0/20.0,
<a name="l00103"></a>00103                       one_by_thirty        = 1.0/30.0,
<a name="l00104"></a>00104                       nineteen_by_thirty   = 19.0/30.0,
<a name="l00105"></a>00105                       three_by_ten         = 3.0/10.0,
<a name="l00106"></a>00106                       six_by_ten           = 6.0/10.0,
<a name="l00107"></a>00107                       one_by_ten           = 1.0/10.0;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00110"></a>00110 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00111"></a>00111   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00112"></a>00112   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00113"></a>00113   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00114"></a>00114   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   <span class="comment">/* calculate total number of tridiagonal systems to solve */</span>
<a name="l00117"></a>00117   <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,Nsys); Nsys *= nvars;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119   <span class="comment">/* Allocate arrays for tridiagonal system */</span>
<a name="l00120"></a>00120   <span class="keywordtype">double</span> *A = compact-&gt;<a class="code" href="a00003.html#ac900805a486cbb8489e3c176ed6e0d8e">A</a>;
<a name="l00121"></a>00121   <span class="keywordtype">double</span> *B = compact-&gt;<a class="code" href="a00003.html#ad36954709307649365515214a02ab06d">B</a>;
<a name="l00122"></a>00122   <span class="keywordtype">double</span> *C = compact-&gt;<a class="code" href="a00003.html#a0a26ce8d1878aac6ddc87e3f6290e039">C</a>;
<a name="l00123"></a>00123   <span class="keywordtype">double</span> *R = compact-&gt;<a class="code" href="a00003.html#ac06de847603f5cfaec085f6fe500f3c8">R</a>;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,index_outer,indexC,indexI)</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys &lt; N_outer; sys++) {
<a name="l00127"></a>00127     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00128"></a>00128     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00129"></a>00129     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00130"></a>00130     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00131"></a>00131       <span class="keywordtype">int</span> qm1,qm2,qm3,qp1,qp2,p;
<a name="l00132"></a>00132       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00133"></a>00133       <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00134"></a>00134         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00135"></a>00135         qm3 = qm1 - 2*stride[dir];
<a name="l00136"></a>00136         qm2 = qm1 -   stride[dir];
<a name="l00137"></a>00137         qp1 = qm1 +   stride[dir];
<a name="l00138"></a>00138         qp2 = qm1 + 2*stride[dir];
<a name="l00139"></a>00139       } <span class="keywordflow">else</span> {
<a name="l00140"></a>00140         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00141"></a>00141         qm3 = qm1 + 2*stride[dir];
<a name="l00142"></a>00142         qm2 = qm1 +   stride[dir];
<a name="l00143"></a>00143         qp1 = qm1 -   stride[dir];
<a name="l00144"></a>00144         qp2 = qm1 - 2*stride[dir];
<a name="l00145"></a>00145       }
<a name="l00146"></a>00146 
<a name="l00147"></a>00147       <span class="comment">/* Defining stencil points */</span>
<a name="l00148"></a>00148       <span class="keywordtype">double</span> *fm3, *fm2, *fm1, *fp1, *fp2;
<a name="l00149"></a>00149       fm3 = fC+qm3*nvars;
<a name="l00150"></a>00150       fm2 = fC+qm2*nvars;
<a name="l00151"></a>00151       fm1 = fC+qm1*nvars;
<a name="l00152"></a>00152       fp1 = fC+qp1*nvars;
<a name="l00153"></a>00153       fp2 = fC+qp2*nvars;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155       <span class="keywordflow">if</span> (   ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == 0                ) &amp;&amp; (indexI[dir] == 0       ))
<a name="l00156"></a>00156           || ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) &amp;&amp; (indexI[dir] == dim[dir])) ) {
<a name="l00157"></a>00157 
<a name="l00158"></a>00158         <span class="comment">/* Use 5th order upwind at the physical boundaries */</span>
<a name="l00159"></a>00159         <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>((A+Nsys*indexI[dir]+sys*nvars),nvars,0.0)
<a name="l00160"></a>00160         <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>((B+Nsys*indexI[dir]+sys*nvars),nvars,1.0)
<a name="l00161"></a>00161         <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>((C+Nsys*indexI[dir]+sys*nvars),nvars,0.0)
<a name="l00162"></a>00162         for (v=0; v&lt;nvars; v++) {
<a name="l00163"></a>00163           (R+Nsys*indexI[dir]+sys*nvars)[v] =   one_by_thirty         * fm3[v]
<a name="l00164"></a>00164                                               - thirteen_by_sixty     * fm2[v]
<a name="l00165"></a>00165                                               + fortyseven_by_sixty   * fm1[v]
<a name="l00166"></a>00166                                               + twentyseven_by_sixty  * fp1[v]
<a name="l00167"></a>00167                                               - one_by_twenty         * fp2[v];
<a name="l00168"></a>00168         }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170       } <span class="keywordflow">else</span> {
<a name="l00171"></a>00171 
<a name="l00172"></a>00172         <span class="comment">/* Use 5th order upwind at the physical boundaries */</span>
<a name="l00173"></a>00173         <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00174"></a>00174           <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>((A+Nsys*indexI[dir]+sys*nvars),nvars,three_by_ten);
<a name="l00175"></a>00175           <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>((B+Nsys*indexI[dir]+sys*nvars),nvars,six_by_ten  );
<a name="l00176"></a>00176           <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>((C+Nsys*indexI[dir]+sys*nvars),nvars,one_by_ten  );
<a name="l00177"></a>00177         } <span class="keywordflow">else</span> {
<a name="l00178"></a>00178           <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>((C+Nsys*indexI[dir]+sys*nvars),nvars,three_by_ten);
<a name="l00179"></a>00179           <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>((B+Nsys*indexI[dir]+sys*nvars),nvars,six_by_ten  );
<a name="l00180"></a>00180           <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>((A+Nsys*indexI[dir]+sys*nvars),nvars,one_by_ten  );
<a name="l00181"></a>00181         }
<a name="l00182"></a>00182         <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) {
<a name="l00183"></a>00183           (R+Nsys*indexI[dir]+sys*nvars)[v] =   one_by_thirty      * fm2[v]
<a name="l00184"></a>00184                                               + nineteen_by_thirty * fm1[v]
<a name="l00185"></a>00185                                               + one_third          * fp1[v];
<a name="l00186"></a>00186         }
<a name="l00187"></a>00187       }
<a name="l00188"></a>00188     }
<a name="l00189"></a>00189   }
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 <span class="preprocessor">#ifdef serial</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span>
<a name="l00193"></a>00193   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00194"></a>00194   <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU</a>(A,B,C,R,dim[dir]+1,Nsys,lu,NULL); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 <span class="preprocessor">#else</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>
<a name="l00198"></a>00198   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00199"></a>00199   <span class="comment">/* all processes except the last will solve without the last interface to avoid overlap */</span>
<a name="l00200"></a>00200   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1)  { <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU</a>(A,B,C,R,dim[dir]  ,Nsys,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr); }
<a name="l00201"></a>00201   <span class="keywordflow">else</span>                                    { <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU</a>(A,B,C,R,dim[dir]+1,Nsys,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr); }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203   <span class="comment">/* Now get the solution to the last interface from the next proc */</span>
<a name="l00204"></a>00204   <span class="keywordtype">double</span> *sendbuf = compact-&gt;<a class="code" href="a00003.html#aba3b15034da676474db917f9f5533085">sendbuf</a>;
<a name="l00205"></a>00205   <span class="keywordtype">double</span> *recvbuf = compact-&gt;<a class="code" href="a00003.html#afc23e46e08649e112e8d64d780cea5cb">recvbuf</a>;
<a name="l00206"></a>00206   MPI_Request req[2] = {MPI_REQUEST_NULL,MPI_REQUEST_NULL};
<a name="l00207"></a>00207   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]) <span class="keywordflow">for</span> (d=0; d&lt;Nsys; d++) sendbuf[d] = R[d];
<a name="l00208"></a>00208   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) MPI_Irecv(recvbuf,Nsys,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]+1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[0]);
<a name="l00209"></a>00209   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir])                      MPI_Isend(sendbuf,Nsys,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]-1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[1]);
<a name="l00210"></a>00210   MPI_Waitall(2,&amp;req[0],MPI_STATUS_IGNORE);
<a name="l00211"></a>00211   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) <span class="keywordflow">for</span> (d=0; d&lt;Nsys; d++) R[d+Nsys*dim[dir]] = recvbuf[d];
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="preprocessor">#endif</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span>
<a name="l00215"></a>00215   <span class="comment">/* save the solution to fI */</span>
<a name="l00216"></a>00216 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,index_outer,indexC,indexI)</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys &lt; N_outer; sys++) {
<a name="l00218"></a>00218     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00219"></a>00219     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00220"></a>00220     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00221"></a>00221       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00222"></a>00222       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((R+sys*nvars+Nsys*indexI[dir]),(fI+nvars*p),nvars);
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224   }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226   <span class="keywordflow">return</span>(0);
<a name="l00227"></a>00227 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af2195885ad055989a1b2b11655843343"></a><!-- doxytag: member="interpolation.h::Interp1PrimFifthOrderWENO" ref="af2195885ad055989a1b2b11655843343" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFifthOrderWENO </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5th order WENO reconstruction (component-wise) on a uniform grid </p>
<p>Component-wise interpolation of the first primitive at the cell interfaces using the fifth-order WENO scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the fifth order WENO scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 5th order WENO numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as the convex combination of three 3rd order methods: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} &amp;\ \omega_1\ \times\ \left[ \hat{\bf f}_{j+1/2}^1 = \frac{1}{3} {\bf f}_{j-2} - \frac{7}{6} {\bf f}_{j-1} + \frac{11}{6} {\bf f}_j \right]\\ + &amp;\ \omega_2\ \times\ \left[ \hat{\bf f}_{j+1/2}^2 = -\frac{1}{6} {\bf f}_{j-1} + \frac{5}{6} {\bf f}_j + \frac{1}{3} {\bf f}_{j+1} \right]\\ + &amp;\ \omega_3\ \times\ \left[ \hat{\bf f}_{j+1/2}^3 = \frac{1}{3} {\bf f}_j + \frac{5}{6} {\bf f}_{j+1} - \frac{1}{6} {\bf f}_{j+2} \right]\\ \Rightarrow &amp;\ \hat{\bf f}_{j+1/2} = \frac{\omega_1}{3} {\bf f}_{j-2} - \frac{1}{6}(7\omega_1+\omega_2){\bf f}_{j-1} + \frac{1}{6}(11\omega_1+5\omega_2+2\omega_3){\bf f}_j + \frac{1}{6}(2\omega_2+5\omega_3){\bf f}_{j+1} - \frac{\omega_3}{6}{\bf f}_{j+2}, \end{align}" src="form_167.png"/>
</p>
<p> where <img class="formulaInl" alt="$\omega_k; k=1,2,3$" src="form_161.png"/> are the nonlinear WENO weights computed in <a class="el" href="a00148.html#a91383df8b8b5f32861e2ecb18dab8ab7">WENOFifthOrderCalculateWeights()</a> (note that the <img class="formulaInl" alt="$\omega$" src="form_25.png"/> are different for each component of the vector <img class="formulaInl" alt="$\hat{\bf f}$" src="form_162.png"/>).</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + The method described above corresponds to a left-biased interpolation. The corresponding right-biased interpolation can be obtained by reflecting the equations about interface j+1/2. + The scalar interpolation method is applied to the vector function in a component-wise manner. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p><b>Reference:</b> + Jiang, G.-S., Shu, C.-W., Efficient Implementation of Weighted ENO Schemes, J. Comput. Phys., 126 (1), 1996, pp. 202-228, <a href="http://dx.doi.org/10.1006/jcph.1996.0130">http://dx.doi.org/10.1006/jcph.1996.0130</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00137_source.html#l00072">72</a> of file <a class="el" href="a00137_source.html">Interp1PrimFifthOrderWENO.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00074"></a>00074                                                                                                    {\bf f}\left({\bf u}\right)\f$ */
<a name="l00075"></a>00075                                 <span class="keywordtype">double</span> *u,   
<a name="l00076"></a>00076                                 <span class="keywordtype">double</span> *x,   
<a name="l00077"></a>00077                                 <span class="keywordtype">int</span>    upw,  
<a name="l00078"></a>00078                                 <span class="keywordtype">int</span>    dir,  
<a name="l00079"></a>00079                                 <span class="keywordtype">void</span>   *s,   
<a name="l00080"></a>00080                                 <span class="keywordtype">void</span>   *m,   
<a name="l00081"></a>00081                                 <span class="keywordtype">int</span>    uflag 
<a name="l00082"></a>00082                              )
<a name="l00083"></a>00083 {
<a name="l00084"></a>00084   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)          s;
<a name="l00085"></a>00085   <a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>  *weno   = (<a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>*) solver-&gt;<a class="code" href="a00015.html#a29c46b81ad574e4dfbad5a7211487dcb">interp</a>;
<a name="l00086"></a>00086 
<a name="l00087"></a>00087   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00088"></a>00088   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00089"></a>00089   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00090"></a>00090   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00091"></a>00091   <span class="keywordtype">int</span> *stride= solver-&gt;<a class="code" href="a00015.html#a39dc7def53a36bdc722aa90f52e04561">stride_with_ghosts</a>;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   <span class="comment">/* define some constants */</span>
<a name="l00094"></a>00094   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_sixth          = 1.0/6.0;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096   <span class="keywordtype">double</span> *ww1, *ww2, *ww3;
<a name="l00097"></a>00097   ww1 = weno-&gt;<a class="code" href="a00030.html#a3ee56e3d8244b3d4582f1396a79f9791">w1</a> + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;<a class="code" href="a00030.html#a439227feff9d7f55384e8780cfc2eb82">size</a> : 0) + weno-&gt;<a class="code" href="a00030.html#ad0c30ee1add42468a6d7c022f2efdf70">offset</a>[dir];
<a name="l00098"></a>00098   ww2 = weno-&gt;<a class="code" href="a00030.html#a31eb3c1fcb3bc85ab4fa156325a1f849">w2</a> + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;<a class="code" href="a00030.html#a439227feff9d7f55384e8780cfc2eb82">size</a> : 0) + weno-&gt;<a class="code" href="a00030.html#ad0c30ee1add42468a6d7c022f2efdf70">offset</a>[dir];
<a name="l00099"></a>00099   ww3 = weno-&gt;<a class="code" href="a00030.html#aabd83eb3f8a7e3bb9f79a4a943bbd508">w3</a> + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;<a class="code" href="a00030.html#a439227feff9d7f55384e8780cfc2eb82">size</a> : 0) + weno-&gt;<a class="code" href="a00030.html#ad0c30ee1add42468a6d7c022f2efdf70">offset</a>[dir];
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00102"></a>00102 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00103"></a>00103   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00104"></a>00104   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00105"></a>00105   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00106"></a>00106   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="keywordtype">int</span> i;
<a name="l00109"></a>00109 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,index_outer,indexC,indexI)</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00111"></a>00111     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00112"></a>00112     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00113"></a>00113     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00114"></a>00114     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00115"></a>00115       <span class="keywordtype">int</span> qm1,qm2,qm3,qp1,qp2,p;
<a name="l00116"></a>00116       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00117"></a>00117       <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00118"></a>00118         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00119"></a>00119         qm3 = qm1 - 2*stride[dir];
<a name="l00120"></a>00120         qm2 = qm1 -   stride[dir];
<a name="l00121"></a>00121         qp1 = qm1 +   stride[dir];
<a name="l00122"></a>00122         qp2 = qm1 + 2*stride[dir];
<a name="l00123"></a>00123       } <span class="keywordflow">else</span> {
<a name="l00124"></a>00124         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00125"></a>00125         qm3 = qm1 + 2*stride[dir];
<a name="l00126"></a>00126         qm2 = qm1 +   stride[dir];
<a name="l00127"></a>00127         qp1 = qm1 -   stride[dir];
<a name="l00128"></a>00128         qp2 = qm1 - 2*stride[dir];
<a name="l00129"></a>00129       }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131       <span class="comment">/* Defining stencil points */</span>
<a name="l00132"></a>00132       <span class="keywordtype">double</span> *fm3, *fm2, *fm1, *fp1, *fp2;
<a name="l00133"></a>00133       fm3 = (fC+qm3*nvars);
<a name="l00134"></a>00134       fm2 = (fC+qm2*nvars);
<a name="l00135"></a>00135       fm1 = (fC+qm1*nvars);
<a name="l00136"></a>00136       fp1 = (fC+qp1*nvars);
<a name="l00137"></a>00137       fp2 = (fC+qp2*nvars);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139       <span class="comment">/* Candidate stencils and their optimal weights*/</span>
<a name="l00140"></a>00140       <span class="keywordtype">double</span> f1[nvars], f2[nvars], f3[nvars];
<a name="l00141"></a>00141       <a class="code" href="a00034.html#a7f8e5a8a430e71fd48b436003049d07b">_ArrayAXBYCZ_</a>(f1,(2*one_sixth),fm3,(-7*one_sixth) ,fm2,(11*one_sixth) ,fm1,nvars);
<a name="l00142"></a>00142       <a class="code" href="a00034.html#a7f8e5a8a430e71fd48b436003049d07b">_ArrayAXBYCZ_</a>(f2,(-one_sixth) ,fm2,(5*one_sixth)  ,fm1,(2*one_sixth)  ,fp1,nvars);
<a name="l00143"></a>00143       <a class="code" href="a00034.html#a7f8e5a8a430e71fd48b436003049d07b">_ArrayAXBYCZ_</a>(f3,(2*one_sixth),fm1,(5*one_sixth)  ,fp1,(-one_sixth)   ,fp2,nvars);
<a name="l00144"></a>00144 
<a name="l00145"></a>00145       <span class="comment">/* calculate WENO weights */</span>
<a name="l00146"></a>00146       <span class="keywordtype">double</span> *w1,*w2,*w3;
<a name="l00147"></a>00147       w1 = (ww1+p*nvars);
<a name="l00148"></a>00148       w2 = (ww2+p*nvars);
<a name="l00149"></a>00149       w3 = (ww3+p*nvars);
<a name="l00150"></a>00150 
<a name="l00151"></a>00151       <a class="code" href="a00034.html#a6e9a85d9e2b01e38fecf30887ad7cf17">_ArrayMultiply3Add1D_</a>((fI+p*nvars),w1,f1,w2,f2,w3,f3,nvars);
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153   }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   <span class="keywordflow">return</span>(0);
<a name="l00156"></a>00156 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a33b1e24c12129941b0027a83c543a654"></a><!-- doxytag: member="interpolation.h::Interp1PrimFifthOrderCRWENO" ref="a33b1e24c12129941b0027a83c543a654" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFifthOrderCRWENO </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5th order CRWENO reconstruction (component-wise) on a uniform grid </p>
<p>Component-wise interpolation of the first primitive at the cell interfaces using the fifth-order CRWENO scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the fifth order CRWENO scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 5th order CRWENO numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as the convex combination of three 3rd order methods: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} &amp;\ \omega_1\ \times\ \left[ \frac{2}{3}\hat{\bf f}_{j-1/2} + \frac{1}{3}\hat{\bf f}_{j+1/2} = \frac{1}{6} \left( f_{j-1} + 5f_j \right) \right]\\ + &amp;\ \omega_2\ \times\ \left[ \frac{1}{3}\hat{\bf f}_{j-1/2}+\frac{2}{3}\hat{\bf f}_{j+1/2} = \frac{1}{6} \left( 5f_j + f_{j+1} \right) \right] \\ + &amp;\ \omega_3\ \times\ \left[ \frac{2}{3}\hat{\bf f}_{j+1/2} + \frac{1}{3}\hat{\bf f}_{j+3/2} = \frac{1}{6} \left( f_j + 5f_{j+1} \right) \right] \\ \Rightarrow &amp;\ \left(\frac{2}{3}\omega_1+\frac{1}{3}\omega_2\right)\hat{\bf f}_{j-1/2} + \left[\frac{1}{3}\omega_1+\frac{2}{3}(\omega_2+\omega_3)\right]\hat{\bf f}_{j+1/2} + \frac{1}{3}\omega_3\hat{\bf f}_{j+3/2} = \frac{\omega_1}{6}{\bf f}_{j-1} + \frac{5(\omega_1+\omega_2)+\omega_3}{6}{\bf f}_j + \frac{\omega_2+5\omega_3}{6}{\bf f}_{j+1}, \end{align}" src="form_160.png"/>
</p>
<p> where <img class="formulaInl" alt="$\omega_k; k=1,2,3$" src="form_161.png"/> are the nonlinear WENO weights computed in <a class="el" href="a00148.html#a91383df8b8b5f32861e2ecb18dab8ab7">WENOFifthOrderCalculateWeights()</a> (note that the <img class="formulaInl" alt="$\omega$" src="form_25.png"/> are different for each component of the vector <img class="formulaInl" alt="$\hat{\bf f}$" src="form_162.png"/>). The resulting tridiagonal system is solved using <a class="el" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU()</a> (see also <a class="el" href="a00029.html">TridiagLU</a>, <a class="el" href="a00062.html" title="Header file for TridiagLU.">tridiagLU.h</a>).</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + The method described above corresponds to a left-biased interpolation. The corresponding right-biased interpolation can be obtained by reflecting the equations about interface j+1/2. + The scalar interpolation method is applied to the vector function in a component-wise manner. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p><b>Reference:</b> + Ghosh, D., Baeder, J. D., Compact Reconstruction Schemes with Weighted ENO Limiting for Hyperbolic Conservation Laws, SIAM Journal on Scientific Computing, 34 (3), 2012, A1678–A1706, <a href="http://dx.doi.org/10.1137/110857659">http://dx.doi.org/10.1137/110857659</a> + Ghosh, D., Constantinescu, E. M., Brown, J., Efficient Implementation of Nonlinear Compact Schemes on Massively Parallel Platforms, SIAM Journal on Scientific Computing, 37 (3), 2015, C354–C383, <a href="http://dx.doi.org/10.1137/140989261">http://dx.doi.org/10.1137/140989261</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00131_source.html#l00078">78</a> of file <a class="el" href="a00131_source.html">Interp1PrimFifthOrderCRWENO.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00080"></a>00080                                                                                                    {\bf f}\left({\bf u}\right)\f$ */
<a name="l00081"></a>00081                                 <span class="keywordtype">double</span> *u,   
<a name="l00082"></a>00082                                 <span class="keywordtype">double</span> *x,   
<a name="l00083"></a>00083                                 <span class="keywordtype">int</span>    upw,  
<a name="l00084"></a>00084                                 <span class="keywordtype">int</span>    dir,  
<a name="l00085"></a>00085                                 <span class="keywordtype">void</span>   *s,   
<a name="l00086"></a>00086                                 <span class="keywordtype">void</span>   *m,   
<a name="l00087"></a>00087                                 <span class="keywordtype">int</span>    uflag 
<a name="l00088"></a>00088                                )
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)          s;
<a name="l00091"></a>00091   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>    *mpi    = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*)   m;
<a name="l00092"></a>00092   <a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>   *compact= (<a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>*)  solver-&gt;<a class="code" href="a00015.html#a56318721d534e74a96b440f8542a0232">compact</a>;
<a name="l00093"></a>00093   <a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>  *weno   = (<a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>*) solver-&gt;<a class="code" href="a00015.html#a29c46b81ad574e4dfbad5a7211487dcb">interp</a>;
<a name="l00094"></a>00094   <a class="code" href="a00029.html">TridiagLU</a>       *lu     = (<a class="code" href="a00029.html">TridiagLU</a>*)      solver-&gt;<a class="code" href="a00015.html#a1dbfa1e479a373073b6ebf72401a7f0f">lusolver</a>;
<a name="l00095"></a>00095   <span class="keywordtype">int</span>             sys,Nsys,d;
<a name="l00096"></a>00096   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00099"></a>00099   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00100"></a>00100   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00101"></a>00101   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00102"></a>00102   <span class="keywordtype">int</span> *stride= solver-&gt;<a class="code" href="a00015.html#a39dc7def53a36bdc722aa90f52e04561">stride_with_ghosts</a>;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="comment">/* define some constants */</span>
<a name="l00105"></a>00105   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_third          = 1.0/3.0;
<a name="l00106"></a>00106   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_sixth          = 1.0/6.0;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="keywordtype">double</span> *ww1, *ww2, *ww3;
<a name="l00109"></a>00109   ww1 = weno-&gt;w1 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00110"></a>00110   ww2 = weno-&gt;w2 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00111"></a>00111   ww3 = weno-&gt;w3 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00114"></a>00114 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00115"></a>00115   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00116"></a>00116   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00117"></a>00117   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00118"></a>00118   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00119"></a>00119 
<a name="l00120"></a>00120   <span class="comment">/* calculate total number of tridiagonal systems to solve */</span>
<a name="l00121"></a>00121   <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,Nsys); Nsys *= nvars;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   <span class="comment">/* Allocate arrays for tridiagonal system */</span>
<a name="l00124"></a>00124   <span class="keywordtype">double</span> *A = compact-&gt;<a class="code" href="a00003.html#ac900805a486cbb8489e3c176ed6e0d8e">A</a>;
<a name="l00125"></a>00125   <span class="keywordtype">double</span> *B = compact-&gt;<a class="code" href="a00003.html#ad36954709307649365515214a02ab06d">B</a>;
<a name="l00126"></a>00126   <span class="keywordtype">double</span> *C = compact-&gt;<a class="code" href="a00003.html#a0a26ce8d1878aac6ddc87e3f6290e039">C</a>;
<a name="l00127"></a>00127   <span class="keywordtype">double</span> *R = compact-&gt;<a class="code" href="a00003.html#ac06de847603f5cfaec085f6fe500f3c8">R</a>;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,index_outer,indexC,indexI)</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys &lt; N_outer; sys++) {
<a name="l00131"></a>00131     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00132"></a>00132     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00133"></a>00133     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00134"></a>00134     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00135"></a>00135       <span class="keywordtype">int</span> qm1,qm2,qm3,qp1,qp2,p;
<a name="l00136"></a>00136       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00137"></a>00137       <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00138"></a>00138         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00139"></a>00139         qm3 = qm1 - 2*stride[dir];
<a name="l00140"></a>00140         qm2 = qm1 -   stride[dir];
<a name="l00141"></a>00141         qp1 = qm1 +   stride[dir];
<a name="l00142"></a>00142         qp2 = qm1 + 2*stride[dir];
<a name="l00143"></a>00143       } <span class="keywordflow">else</span> {
<a name="l00144"></a>00144         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00145"></a>00145         qm3 = qm1 + 2*stride[dir];
<a name="l00146"></a>00146         qm2 = qm1 +   stride[dir];
<a name="l00147"></a>00147         qp1 = qm1 -   stride[dir];
<a name="l00148"></a>00148         qp2 = qm1 - 2*stride[dir];
<a name="l00149"></a>00149       }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151       <span class="comment">/* Defining stencil points */</span>
<a name="l00152"></a>00152       <span class="keywordtype">double</span> *fm3, *fm2, *fm1, *fp1, *fp2;
<a name="l00153"></a>00153       fm3 = fC+qm3*nvars;
<a name="l00154"></a>00154       fm2 = fC+qm2*nvars;
<a name="l00155"></a>00155       fm1 = fC+qm1*nvars;
<a name="l00156"></a>00156       fp1 = fC+qp1*nvars;
<a name="l00157"></a>00157       fp2 = fC+qp2*nvars;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159       <span class="comment">/* Candidate stencils and their optimal weights*/</span>
<a name="l00160"></a>00160       <span class="keywordtype">double</span> f1[nvars], f2[nvars], f3[nvars];
<a name="l00161"></a>00161       <span class="keywordflow">if</span> (   ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == 0                ) &amp;&amp; (indexI[dir] == 0       ))
<a name="l00162"></a>00162           || ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) &amp;&amp; (indexI[dir] == dim[dir])) ) {
<a name="l00163"></a>00163         <span class="comment">/* Use WENO5 at the physical boundaries */</span>
<a name="l00164"></a>00164         <a class="code" href="a00034.html#a7f8e5a8a430e71fd48b436003049d07b">_ArrayAXBYCZ_</a>(f1,(2*one_sixth),fm3,(-7*one_sixth) ,fm2,(11*one_sixth) ,fm1,nvars);
<a name="l00165"></a>00165         <a class="code" href="a00034.html#a7f8e5a8a430e71fd48b436003049d07b">_ArrayAXBYCZ_</a>(f2,(-one_sixth) ,fm2,(5*one_sixth)  ,fm1,(2*one_sixth)  ,fp1,nvars);
<a name="l00166"></a>00166         <a class="code" href="a00034.html#a7f8e5a8a430e71fd48b436003049d07b">_ArrayAXBYCZ_</a>(f3,(2*one_sixth),fm1,(5*one_sixth)  ,fp1,(-one_sixth)   ,fp2,nvars);
<a name="l00167"></a>00167       } <span class="keywordflow">else</span> {
<a name="l00168"></a>00168         <span class="comment">/* CRWENO5 at the interior points */</span>
<a name="l00169"></a>00169         <a class="code" href="a00034.html#ae2829ea36a04607caf64d3a462339af9">_ArrayAXBY_</a>(f1,(one_sixth)  ,fm2,(5*one_sixth),fm1,nvars);
<a name="l00170"></a>00170         <a class="code" href="a00034.html#ae2829ea36a04607caf64d3a462339af9">_ArrayAXBY_</a>(f2,(5*one_sixth),fm1,(one_sixth)  ,fp1,nvars);
<a name="l00171"></a>00171         <a class="code" href="a00034.html#ae2829ea36a04607caf64d3a462339af9">_ArrayAXBY_</a>(f3,(one_sixth)  ,fm1,(5*one_sixth),fp1,nvars);
<a name="l00172"></a>00172       }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174       <span class="comment">/* retrieve the WENO weights */</span>
<a name="l00175"></a>00175       <span class="keywordtype">double</span> *w1, *w2, *w3;
<a name="l00176"></a>00176       w1 = (ww1+p*nvars);
<a name="l00177"></a>00177       w2 = (ww2+p*nvars);
<a name="l00178"></a>00178       w3 = (ww3+p*nvars);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180       <span class="keywordflow">if</span> (   ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == 0                ) &amp;&amp; (indexI[dir] == 0       ))
<a name="l00181"></a>00181           || ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) &amp;&amp; (indexI[dir] == dim[dir])) ) {
<a name="l00182"></a>00182         <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>     ((A+Nsys*indexI[dir]+sys*nvars),nvars,0.0)
<a name="l00183"></a>00183         <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>     ((B+Nsys*indexI[dir]+sys*nvars),nvars,1.0)
<a name="l00184"></a>00184         <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>     ((C+Nsys*indexI[dir]+sys*nvars),nvars,0.0)
<a name="l00185"></a>00185       } else {
<a name="l00186"></a>00186         <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00187"></a>00187           <a class="code" href="a00034.html#ae2829ea36a04607caf64d3a462339af9">_ArrayAXBY_</a>       ((A+Nsys*indexI[dir]+sys*nvars),(2*one_third) ,w1,(one_third)  ,w2,nvars);
<a name="l00188"></a>00188           <a class="code" href="a00034.html#a7f8e5a8a430e71fd48b436003049d07b">_ArrayAXBYCZ_</a>     ((B+Nsys*indexI[dir]+sys*nvars),(one_third)   ,w1,(2*one_third),w2,(2*one_third),w3,nvars);
<a name="l00189"></a>00189           <a class="code" href="a00034.html#a7d97d4914726fa7cca339356dae28473">_ArrayScaleCopy1D_</a>(w3,(one_third),(C+Nsys*indexI[dir]+sys*nvars),nvars);
<a name="l00190"></a>00190         } <span class="keywordflow">else</span> {
<a name="l00191"></a>00191           <a class="code" href="a00034.html#ae2829ea36a04607caf64d3a462339af9">_ArrayAXBY_</a>       ((C+Nsys*indexI[dir]+sys*nvars),(2*one_third) ,w1,(one_third)  ,w2,nvars);
<a name="l00192"></a>00192           <a class="code" href="a00034.html#a7f8e5a8a430e71fd48b436003049d07b">_ArrayAXBYCZ_</a>     ((B+Nsys*indexI[dir]+sys*nvars),(one_third)   ,w1,(2*one_third),w2,(2*one_third),w3,nvars);
<a name="l00193"></a>00193           <a class="code" href="a00034.html#a7d97d4914726fa7cca339356dae28473">_ArrayScaleCopy1D_</a>(w3,(one_third),(A+Nsys*indexI[dir]+sys*nvars),nvars);
<a name="l00194"></a>00194         }
<a name="l00195"></a>00195       }
<a name="l00196"></a>00196       <a class="code" href="a00034.html#a6e9a85d9e2b01e38fecf30887ad7cf17">_ArrayMultiply3Add1D_</a> ((R+Nsys*indexI[dir]+sys*nvars),w1,f1,w2,f2,w3,f3,nvars);
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198   }
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="preprocessor">#ifdef serial</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>
<a name="l00202"></a>00202   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00203"></a>00203   <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU</a>(A,B,C,R,dim[dir]+1,Nsys,lu,NULL); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="preprocessor">#else</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span>
<a name="l00207"></a>00207   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00208"></a>00208   <span class="comment">/* all processes except the last will solve without the last interface to avoid overlap */</span>
<a name="l00209"></a>00209   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1)  { <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU</a>(A,B,C,R,dim[dir]  ,Nsys,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr); }
<a name="l00210"></a>00210   <span class="keywordflow">else</span>                                    { <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU</a>(A,B,C,R,dim[dir]+1,Nsys,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr); }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   <span class="comment">/* Now get the solution to the last interface from the next proc */</span>
<a name="l00213"></a>00213   <span class="keywordtype">double</span> *sendbuf = compact-&gt;<a class="code" href="a00003.html#aba3b15034da676474db917f9f5533085">sendbuf</a>;
<a name="l00214"></a>00214   <span class="keywordtype">double</span> *recvbuf = compact-&gt;<a class="code" href="a00003.html#afc23e46e08649e112e8d64d780cea5cb">recvbuf</a>;
<a name="l00215"></a>00215   MPI_Request req[2] = {MPI_REQUEST_NULL,MPI_REQUEST_NULL};
<a name="l00216"></a>00216   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]) <span class="keywordflow">for</span> (d=0; d&lt;Nsys; d++) sendbuf[d] = R[d];
<a name="l00217"></a>00217   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) MPI_Irecv(recvbuf,Nsys,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]+1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[0]);
<a name="l00218"></a>00218   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir])                      MPI_Isend(sendbuf,Nsys,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]-1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[1]);
<a name="l00219"></a>00219   MPI_Waitall(2,&amp;req[0],MPI_STATUS_IGNORE);
<a name="l00220"></a>00220   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) <span class="keywordflow">for</span> (d=0; d&lt;Nsys; d++) R[d+Nsys*dim[dir]] = recvbuf[d];
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="preprocessor">#endif</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span>
<a name="l00224"></a>00224   <span class="comment">/* save the solution to fI */</span>
<a name="l00225"></a>00225 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,index_outer,indexC,indexI)</span>
<a name="l00226"></a>00226 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys &lt; N_outer; sys++) {
<a name="l00227"></a>00227     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00228"></a>00228     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00229"></a>00229     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00230"></a>00230       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00231"></a>00231       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((R+sys*nvars+Nsys*indexI[dir]),(fI+nvars*p),nvars);
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233   }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="keywordflow">return</span>(0);
<a name="l00236"></a>00236 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad9c611137cfce1c622c2e9838fb523c8"></a><!-- doxytag: member="interpolation.h::Interp1PrimFifthOrderHCWENO" ref="ad9c611137cfce1c622c2e9838fb523c8" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFifthOrderHCWENO </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5th order hybrid compact-WENO reconstruction (component-wise) on a uniform grid </p>
<p>Component-wise interpolation of the first primitive at the cell interfaces using the fifth-order hybrid-compact WENO scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the fifth order hybrid compact-WENO scheme on a uniform grid. The tridiagonal system is solved using <a class="el" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU()</a> (see also <a class="el" href="a00029.html">TridiagLU</a>, <a class="el" href="a00062.html" title="Header file for TridiagLU.">tridiagLU.h</a>). See references below for a complete description of the method implemented here.</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + The scalar interpolation method is applied to the vector function in a component-wise manner. + The WENO weights are computed in <a class="el" href="a00148.html#a91383df8b8b5f32861e2ecb18dab8ab7">WENOFifthOrderCalculateWeights()</a>. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p><b>Reference:</b> + Pirozzoli, S., Conservative Hybrid Compact-WENO Schemes for Shock-Turbulence Interaction, J. Comput. Phys., 178 (1), 2002, pp. 81-117, <a href="http://dx.doi.org/10.1006/jcph.2002.7021">http://dx.doi.org/10.1006/jcph.2002.7021</a> + Ren, Y.-X., Liu, M., Zhang, H., A characteristic-wise hybrid compact-WENO scheme for solving hyperbolic conservation laws, J. Comput. Phys., 192 (2), 2003, pp. 365-386, <a href="http://dx.doi.org/10.1016/j.jcp.2003.07.006">http://dx.doi.org/10.1016/j.jcp.2003.07.006</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00133_source.html#l00063">63</a> of file <a class="el" href="a00133_source.html">Interp1PrimFifthOrderHCWENO.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00065"></a>00065                                                                                                    {\bf f}\left({\bf u}\right)\f$ */
<a name="l00066"></a>00066                                 <span class="keywordtype">double</span> *u,   
<a name="l00067"></a>00067                                 <span class="keywordtype">double</span> *x,   
<a name="l00068"></a>00068                                 <span class="keywordtype">int</span>    upw,  
<a name="l00069"></a>00069                                 <span class="keywordtype">int</span>    dir,  
<a name="l00070"></a>00070                                 <span class="keywordtype">void</span>   *s,   
<a name="l00071"></a>00071                                 <span class="keywordtype">void</span>   *m,   
<a name="l00072"></a>00072                                 <span class="keywordtype">int</span>    uflag 
<a name="l00073"></a>00073                                )
<a name="l00074"></a>00074 {
<a name="l00075"></a>00075   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)          s;
<a name="l00076"></a>00076   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>    *mpi    = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*)   m;
<a name="l00077"></a>00077   <a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>   *compact= (<a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>*)  solver-&gt;<a class="code" href="a00015.html#a56318721d534e74a96b440f8542a0232">compact</a>;
<a name="l00078"></a>00078   <a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>  *weno   = (<a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>*) solver-&gt;<a class="code" href="a00015.html#a29c46b81ad574e4dfbad5a7211487dcb">interp</a>;
<a name="l00079"></a>00079   <a class="code" href="a00029.html">TridiagLU</a>       *lu     = (<a class="code" href="a00029.html">TridiagLU</a>*)      solver-&gt;<a class="code" href="a00015.html#a1dbfa1e479a373073b6ebf72401a7f0f">lusolver</a>;
<a name="l00080"></a>00080   <span class="keywordtype">int</span>             sys,Nsys,d;
<a name="l00081"></a>00081   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00084"></a>00084   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00085"></a>00085   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00086"></a>00086   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088   <span class="comment">/* define some constants */</span>
<a name="l00089"></a>00089   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_half           = 1.0/2.0;
<a name="l00090"></a>00090   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_third          = 1.0/3.0;
<a name="l00091"></a>00091   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_sixth          = 1.0/6.0;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   <span class="keywordtype">double</span> *ww1, *ww2, *ww3;
<a name="l00094"></a>00094   ww1 = weno-&gt;w1 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00095"></a>00095   ww2 = weno-&gt;w2 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00096"></a>00096   ww3 = weno-&gt;w3 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00097"></a>00097 
<a name="l00098"></a>00098   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00099"></a>00099 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00100"></a>00100   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00101"></a>00101   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00102"></a>00102   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00103"></a>00103   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00104"></a>00104 
<a name="l00105"></a>00105   <span class="comment">/* calculate total number of tridiagonal systems to solve */</span>
<a name="l00106"></a>00106   <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,Nsys); Nsys *= nvars;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="comment">/* Allocate arrays for tridiagonal system */</span>
<a name="l00109"></a>00109   <span class="keywordtype">double</span> *A = compact-&gt;<a class="code" href="a00003.html#ac900805a486cbb8489e3c176ed6e0d8e">A</a>;
<a name="l00110"></a>00110   <span class="keywordtype">double</span> *B = compact-&gt;<a class="code" href="a00003.html#ad36954709307649365515214a02ab06d">B</a>;
<a name="l00111"></a>00111   <span class="keywordtype">double</span> *C = compact-&gt;<a class="code" href="a00003.html#a0a26ce8d1878aac6ddc87e3f6290e039">C</a>;
<a name="l00112"></a>00112   <span class="keywordtype">double</span> *R = compact-&gt;<a class="code" href="a00003.html#ac06de847603f5cfaec085f6fe500f3c8">R</a>;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,index_outer,indexC,indexI)</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys &lt; N_outer; sys++) {
<a name="l00116"></a>00116     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00117"></a>00117     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00118"></a>00118     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00119"></a>00119     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00120"></a>00120       <span class="keywordtype">int</span> qm1,qm2,qm3,qp1,qp2,p;
<a name="l00121"></a>00121       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00122"></a>00122       <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00123"></a>00123         indexC[dir] = indexI[dir]-3; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00124"></a>00124         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00125"></a>00125         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00126"></a>00126         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00127"></a>00127         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00128"></a>00128       } <span class="keywordflow">else</span> {
<a name="l00129"></a>00129         indexC[dir] = indexI[dir]+2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00130"></a>00130         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00131"></a>00131         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00132"></a>00132         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00133"></a>00133         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00134"></a>00134       }
<a name="l00135"></a>00135       <span class="keywordtype">int</span> v; 
<a name="l00136"></a>00136       <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++)  {
<a name="l00137"></a>00137         <span class="comment">/* Defining stencil points */</span>
<a name="l00138"></a>00138         <span class="keywordtype">double</span> fm3, fm2, fm1, fp1, fp2;
<a name="l00139"></a>00139         fm3 = fC[qm3*nvars+v];
<a name="l00140"></a>00140         fm2 = fC[qm2*nvars+v];
<a name="l00141"></a>00141         fm1 = fC[qm1*nvars+v];
<a name="l00142"></a>00142         fp1 = fC[qp1*nvars+v];
<a name="l00143"></a>00143         fp2 = fC[qp2*nvars+v];
<a name="l00144"></a>00144 
<a name="l00145"></a>00145         <span class="comment">/* Candidate stencils and their optimal weights*/</span>
<a name="l00146"></a>00146         <span class="keywordtype">double</span> f1, f2, f3;
<a name="l00147"></a>00147         f1 = (2*one_sixth)*fm3 - (7.0*one_sixth)*fm2 + (11.0*one_sixth)*fm1;
<a name="l00148"></a>00148         f2 = (-one_sixth)*fm2 + (5.0*one_sixth)*fm1 + (2*one_sixth)*fp1;
<a name="l00149"></a>00149         f3 = (2*one_sixth)*fm1 + (5*one_sixth)*fp1 - (one_sixth)*fp2;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151         <span class="comment">/* calculate WENO weights */</span>
<a name="l00152"></a>00152         <span class="keywordtype">double</span> w1,w2,w3;
<a name="l00153"></a>00153         w1 = *(ww1+p*nvars+v);
<a name="l00154"></a>00154         w2 = *(ww2+p*nvars+v);
<a name="l00155"></a>00155         w3 = *(ww3+p*nvars+v);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157         <span class="comment">/* calculate the hybridization parameter */</span>
<a name="l00158"></a>00158         <span class="keywordtype">double</span> sigma;
<a name="l00159"></a>00159         <span class="keywordflow">if</span> (   ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == 0                ) &amp;&amp; (indexI[dir] == 0       ))
<a name="l00160"></a>00160             || ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) &amp;&amp; (indexI[dir] == dim[dir])) ) {
<a name="l00161"></a>00161           <span class="comment">/* Standard WENO at physical boundaries */</span>
<a name="l00162"></a>00162           sigma = 0.0;
<a name="l00163"></a>00163         } <span class="keywordflow">else</span> {
<a name="l00164"></a>00164           <span class="keywordtype">double</span> cuckoo, df_jm12, df_jp12, df_jp32, r_j, r_jp1, r_int;
<a name="l00165"></a>00165           cuckoo = (0.9*weno-&gt;rc / (1.0-0.9*weno-&gt;rc)) * weno-&gt;xi * weno-&gt;xi;
<a name="l00166"></a>00166           df_jm12 = fm1 - fm2;
<a name="l00167"></a>00167           df_jp12 = fp1 - fm1;
<a name="l00168"></a>00168           df_jp32 = fp2 - fp1;
<a name="l00169"></a>00169           r_j   = (<a class="code" href="a00043.html#adf1be5ccbb7a2522b4f3a64043c72880">absolute</a>(2*df_jp12*df_jm12)+cuckoo)/(df_jp12*df_jp12+df_jm12*df_jm12+cuckoo);
<a name="l00170"></a>00170           r_jp1 = (<a class="code" href="a00043.html#adf1be5ccbb7a2522b4f3a64043c72880">absolute</a>(2*df_jp32*df_jp12)+cuckoo)/(df_jp32*df_jp32+df_jp12*df_jp12+cuckoo);
<a name="l00171"></a>00171           r_int = <a class="code" href="a00043.html#ac6afabdc09a49a433ee19d8a9486056d">min</a>(r_j, r_jp1);
<a name="l00172"></a>00172           sigma = <a class="code" href="a00043.html#ac6afabdc09a49a433ee19d8a9486056d">min</a>((r_int/weno-&gt;rc), 1.0); 
<a name="l00173"></a>00173         }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175         <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00176"></a>00176           A[sys*nvars+v+Nsys*indexI[dir]] = one_half  * sigma;
<a name="l00177"></a>00177           B[sys*nvars+v+Nsys*indexI[dir]] = 1.0;
<a name="l00178"></a>00178           C[sys*nvars+v+Nsys*indexI[dir]] = one_sixth * sigma;
<a name="l00179"></a>00179         } <span class="keywordflow">else</span> {
<a name="l00180"></a>00180           C[sys*nvars+v+Nsys*indexI[dir]] = one_half  * sigma;
<a name="l00181"></a>00181           B[sys*nvars+v+Nsys*indexI[dir]] = 1.0;
<a name="l00182"></a>00182           A[sys*nvars+v+Nsys*indexI[dir]] = one_sixth * sigma;
<a name="l00183"></a>00183         }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185         <span class="keywordtype">double</span> fWENO, fCompact;
<a name="l00186"></a>00186         fWENO    = w1*f1 + w2*f2 + w3*f3;
<a name="l00187"></a>00187         fCompact = one_sixth * (one_third*fm2 + 19.0*one_third*fm1 + 10.0*one_third*fp1);
<a name="l00188"></a>00188         R[sys*nvars+v+Nsys*indexI[dir]] =   sigma*fCompact + (1.0-sigma)*fWENO;
<a name="l00189"></a>00189       }
<a name="l00190"></a>00190     }
<a name="l00191"></a>00191   }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="preprocessor">#ifdef serial</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>
<a name="l00195"></a>00195   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00196"></a>00196   <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU</a>(A,B,C,R,dim[dir]+1,Nsys,lu,NULL); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <span class="preprocessor">#else</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span>
<a name="l00200"></a>00200   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00201"></a>00201   <span class="comment">/* all processes except the last will solve without the last interface to avoid overlap */</span>
<a name="l00202"></a>00202   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1)  { <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU</a>(A,B,C,R,dim[dir]  ,Nsys,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr); }
<a name="l00203"></a>00203   <span class="keywordflow">else</span>                                    { <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#a83b53dedf034d67bf2dde46eebf492ee">tridiagLU</a>(A,B,C,R,dim[dir]+1,Nsys,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr); }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205   <span class="comment">/* Now get the solution to the last interface from the next proc */</span>
<a name="l00206"></a>00206   <span class="keywordtype">double</span> *sendbuf = compact-&gt;<a class="code" href="a00003.html#aba3b15034da676474db917f9f5533085">sendbuf</a>;
<a name="l00207"></a>00207   <span class="keywordtype">double</span> *recvbuf = compact-&gt;<a class="code" href="a00003.html#afc23e46e08649e112e8d64d780cea5cb">recvbuf</a>;
<a name="l00208"></a>00208   MPI_Request req[2] = {MPI_REQUEST_NULL,MPI_REQUEST_NULL};
<a name="l00209"></a>00209   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]) <span class="keywordflow">for</span> (d=0; d&lt;Nsys; d++) sendbuf[d] = R[d];
<a name="l00210"></a>00210   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) MPI_Irecv(recvbuf,Nsys,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]+1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[0]);
<a name="l00211"></a>00211   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir])                      MPI_Isend(sendbuf,Nsys,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]-1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[1]);
<a name="l00212"></a>00212   MPI_Waitall(2,&amp;req[0],MPI_STATUS_IGNORE);
<a name="l00213"></a>00213   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) <span class="keywordflow">for</span> (d=0; d&lt;Nsys; d++) R[d+Nsys*dim[dir]] = recvbuf[d];
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="preprocessor">#endif</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span>
<a name="l00217"></a>00217   <span class="comment">/* save the solution to fI */</span>
<a name="l00218"></a>00218 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,index_outer,indexC,indexI)</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys &lt; N_outer; sys++) {
<a name="l00220"></a>00220     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00221"></a>00221     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00222"></a>00222     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00223"></a>00223       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00224"></a>00224       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((R+sys*nvars+Nsys*indexI[dir]),(fI+nvars*p),nvars);
<a name="l00225"></a>00225     }
<a name="l00226"></a>00226   }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228   <span class="keywordflow">return</span>(0);
<a name="l00229"></a>00229 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a759e07ba8a484c2c6971fc7c6a81a95a"></a><!-- doxytag: member="interpolation.h::Interp1PrimFirstOrderUpwindChar" ref="a759e07ba8a484c2c6971fc7c6a81a95a" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFirstOrderUpwindChar </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>1st order upwind reconstruction (characteristic-based) on a uniform grid </p>
<p>Characteristic-based interpolation of the first primitive at the cell interfaces using the first-order upwind scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the 1st order upwind scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 1st order upwind numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\alpha}^k_{j+1/2} = \left\{\begin{array}{cc} {\alpha}^k_{j} &amp; {\rm upw} > 0 \\ {\alpha}^k_{j+1} &amp; {\rm upw} \le 0 \end{array}\right.. \end{equation}" src="form_170.png"/>
</p>
<p> where </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \alpha^k = {\bf l}_k \cdot {\bf f},\ k=1,\cdots,n \end{equation}" src="form_155.png"/>
</p>
<p> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th characteristic quantity, and <img class="formulaInl" alt="${\bf l}_k$" src="form_157.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th left eigenvector, <img class="formulaInl" alt="${\bf r}_k$" src="form_158.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th right eigenvector, and <img class="formulaInl" alt="$n$" src="form_141.png"/> is <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>. The final interpolated function is computed from the interpolated characteristic quantities as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = \sum_{k=1}^n \alpha^k_{j+1/2} {\bf r}_k \end{equation}" src="form_159.png"/>
</p>
<p><b>Implementation</b> <b>Notes:</b> + The left and right eigenvectors are computed at an averaged quantity at j+1/2. Thus, this function requires functions to compute the average state, and the left and right eigenvectors. These are provided by the physical model through</p>
<ul>
<li><a class="el" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">HyPar::GetLeftEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a22eef349f191a1aa267e14b08140c823">HyPar::GetRightEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a7331366d789b2995436accbc35e1cc80">HyPar::AveragingFunction()</a></li>
</ul>
<p>If these functions are not provided by the physical model, then a characteristic-based interpolation cannot be used. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00140_source.html#l00076">76</a> of file <a class="el" href="a00140_source.html">Interp1PrimFirstOrderUpwindChar.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00078"></a>00078                                                                                                        {\bf f}\left({\bf u}\right)\f$ */
<a name="l00079"></a>00079                                     <span class="keywordtype">double</span> *u,   
<a name="l00080"></a>00080                                     <span class="keywordtype">double</span> *x,   
<a name="l00081"></a>00081                                     <span class="keywordtype">int</span>    upw,  
<a name="l00082"></a>00082                                     <span class="keywordtype">int</span>    dir,  
<a name="l00083"></a>00083                                     <span class="keywordtype">void</span>   *s,   
<a name="l00084"></a>00084                                     <span class="keywordtype">void</span>   *m,   
<a name="l00085"></a>00085                                     <span class="keywordtype">int</span>    uflag 
<a name="l00086"></a>00086                                   )
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>         *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*) s;
<a name="l00089"></a>00089   <span class="keywordtype">int</span>           i, k, v;
<a name="l00090"></a>00090   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00093"></a>00093   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00094"></a>00094   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00095"></a>00095   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00098"></a>00098 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00099"></a>00099   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00100"></a>00100   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00101"></a>00101   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00102"></a>00102   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="comment">/* allocate arrays for the averaged state, eigenvectors and characteristic interpolated f */</span>
<a name="l00105"></a>00105   <span class="keywordtype">double</span> R[nvars*nvars], L[nvars*nvars], uavg[nvars], fchar[nvars];
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,k,v,R,L,uavg,fchar,index_outer,indexC,indexI)</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00109"></a>00109     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00110"></a>00110     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00111"></a>00111     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00112"></a>00112 
<a name="l00113"></a>00113     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00114"></a>00114 
<a name="l00115"></a>00115       <span class="keywordtype">int</span> pL, pR; <span class="comment">/* 1D index of the left and right cells */</span>
<a name="l00116"></a>00116       indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,pL);
<a name="l00117"></a>00117       indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,pR);
<a name="l00118"></a>00118       <span class="keywordtype">int</span> p; <span class="comment">/* 1D index of the interface */</span>
<a name="l00119"></a>00119       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121       <span class="comment">/* find averaged state at this interface */</span>
<a name="l00122"></a>00122       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a7331366d789b2995436accbc35e1cc80">AveragingFunction</a>(uavg,&amp;u[nvars*pL],&amp;u[nvars*pR],solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00123"></a>00123 
<a name="l00124"></a>00124       <span class="comment">/* Get the left and right eigenvectors */</span>
<a name="l00125"></a>00125       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">GetLeftEigenvectors</a>  (uavg,L,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00126"></a>00126       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a22eef349f191a1aa267e14b08140c823">GetRightEigenvectors</a> (uavg,R,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00127"></a>00127 
<a name="l00128"></a>00128       <span class="comment">/* For each characteristic field */</span>
<a name="l00129"></a>00129       <span class="keywordflow">for</span> (v = 0; v &lt; nvars; v++) {
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         <span class="comment">/* calculate the characteristic flux components along this characteristic */</span>
<a name="l00132"></a>00132         <span class="keywordtype">double</span> fcL = 0, fcR = 0;
<a name="l00133"></a>00133         <span class="keywordflow">for</span> (k = 0; k &lt; nvars; k++) {
<a name="l00134"></a>00134           fcL += L[v*nvars+k] * fC[pL*nvars+k];
<a name="l00135"></a>00135           fcR += L[v*nvars+k] * fC[pR*nvars+k];
<a name="l00136"></a>00136         }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         <span class="comment">/* first order upwind approximation of the characteristic flux */</span>
<a name="l00139"></a>00139         fchar[v] = (upw &gt; 0 ? fcL : fcR);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141       }
<a name="l00142"></a>00142 
<a name="l00143"></a>00143       <span class="comment">/* calculate the interface u from the characteristic u */</span>
<a name="l00144"></a>00144       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00043.html#a3dc53d4eb4ba0f2cfed00aa69617ee84">MatVecMult</a>(nvars,(fI+nvars*p),R,fchar); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147   }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149   <span class="keywordflow">return</span>(0);
<a name="l00150"></a>00150 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a963c82116a2a1d6084af3d519b61b896"></a><!-- doxytag: member="interpolation.h::Interp1PrimSecondOrderCentralChar" ref="a963c82116a2a1d6084af3d519b61b896" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimSecondOrderCentralChar </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>2nd order central reconstruction (characteristic-based) on a uniform grid </p>
<p>Characteristic-based interpolation of the first primitive at the cell interfaces using the second-order central scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the 2nd order central scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 2nd order central numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\alpha}^k_{j+1/2} = \frac{1}{2} \left( {\alpha}^k_{j-1} + {\alpha}^k_j \right), \end{equation}" src="form_172.png"/>
</p>
<p> where </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \alpha^k = {\bf l}_k \cdot {\bf f},\ k=1,\cdots,n \end{equation}" src="form_155.png"/>
</p>
<p> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th characteristic quantity, and <img class="formulaInl" alt="${\bf l}_k$" src="form_157.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th left eigenvector, <img class="formulaInl" alt="${\bf r}_k$" src="form_158.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th right eigenvector, and <img class="formulaInl" alt="$n$" src="form_141.png"/> is <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>. The final interpolated function is computed from the interpolated characteristic quantities as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = \sum_{k=1}^n \alpha^k_{j+1/2} {\bf r}_k \end{equation}" src="form_159.png"/>
</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + Since this is a central scheme, the input argument <b>upw</b> has no effect. + The left and right eigenvectors are computed at an averaged quantity at j+1/2. Thus, this function requires functions to compute the average state, and the left and right eigenvectors. These are provided by the physical model through</p>
<ul>
<li><a class="el" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">HyPar::GetLeftEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a22eef349f191a1aa267e14b08140c823">HyPar::GetRightEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a7331366d789b2995436accbc35e1cc80">HyPar::AveragingFunction()</a></li>
</ul>
<p>If these functions are not provided by the physical model, then a characteristic-based interpolation cannot be used. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00142_source.html#l00078">78</a> of file <a class="el" href="a00142_source.html">Interp1PrimSecondOrderCentralChar.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00080"></a>00080                                                                                                            {\bf f}\left({\bf u}\right)\f$ */
<a name="l00081"></a>00081                                         <span class="keywordtype">double</span> *u,   
<a name="l00082"></a>00082                                         <span class="keywordtype">double</span> *x,   
<a name="l00083"></a>00083                                         <span class="keywordtype">int</span>    upw,  
<a name="l00084"></a>00084                                         <span class="keywordtype">int</span>    dir,  
<a name="l00085"></a>00085                                         <span class="keywordtype">void</span>   *s,   
<a name="l00086"></a>00086                                         <span class="keywordtype">void</span>   *m,   
<a name="l00087"></a>00087                                         <span class="keywordtype">int</span>    uflag 
<a name="l00088"></a>00088                                      )
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>         *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*) s;
<a name="l00091"></a>00091   <span class="keywordtype">int</span>           i, k, v;
<a name="l00092"></a>00092   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00095"></a>00095   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00096"></a>00096   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00097"></a>00097   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00100"></a>00100 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00101"></a>00101   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00102"></a>00102   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00103"></a>00103   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00104"></a>00104   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00105"></a>00105 
<a name="l00106"></a>00106   <span class="comment">/* allocate arrays for the averaged state, eigenvectors and characteristic interpolated f */</span>
<a name="l00107"></a>00107   <span class="keywordtype">double</span> R[nvars*nvars], L[nvars*nvars], uavg[nvars], fchar[nvars];
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,k,v,R,L,uavg,fchar,index_outer,indexC,indexI)</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00111"></a>00111     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00112"></a>00112     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00113"></a>00113     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00114"></a>00114 
<a name="l00115"></a>00115     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00116"></a>00116 
<a name="l00117"></a>00117       <span class="keywordtype">int</span> pL, pR; <span class="comment">/* 1D index of the left and right cells */</span>
<a name="l00118"></a>00118       indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,pL);
<a name="l00119"></a>00119       indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,pR);
<a name="l00120"></a>00120       <span class="keywordtype">int</span> p; <span class="comment">/* 1D index of the interface */</span>
<a name="l00121"></a>00121       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00122"></a>00122 
<a name="l00123"></a>00123       <span class="comment">/* find averaged state at this interface */</span>
<a name="l00124"></a>00124       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a7331366d789b2995436accbc35e1cc80">AveragingFunction</a>(uavg,&amp;u[nvars*pL],&amp;u[nvars*pR],solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00125"></a>00125 
<a name="l00126"></a>00126       <span class="comment">/* Get the left and right eigenvectors */</span>
<a name="l00127"></a>00127       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">GetLeftEigenvectors</a>  (uavg,L,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00128"></a>00128       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a22eef349f191a1aa267e14b08140c823">GetRightEigenvectors</a> (uavg,R,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130       <span class="comment">/* For each characteristic field */</span>
<a name="l00131"></a>00131       <span class="keywordflow">for</span> (v = 0; v &lt; nvars; v++) {
<a name="l00132"></a>00132 
<a name="l00133"></a>00133         <span class="comment">/* calculate the characteristic flux components along this characteristic */</span>
<a name="l00134"></a>00134         <span class="keywordtype">double</span> fcL = 0, fcR = 0;
<a name="l00135"></a>00135         <span class="keywordflow">for</span> (k = 0; k &lt; nvars; k++) {
<a name="l00136"></a>00136           fcL += L[v*nvars+k] * fC[pL*nvars+k];
<a name="l00137"></a>00137           fcR += L[v*nvars+k] * fC[pR*nvars+k];
<a name="l00138"></a>00138         }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         <span class="comment">/* first order upwind approximation of the characteristic flux */</span>
<a name="l00141"></a>00141         fchar[v] = 0.5 * (fcL + fcR);
<a name="l00142"></a>00142 
<a name="l00143"></a>00143       }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145       <span class="comment">/* calculate the interface u from the characteristic u */</span>
<a name="l00146"></a>00146       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00043.html#a3dc53d4eb4ba0f2cfed00aa69617ee84">MatVecMult</a>(nvars,(fI+nvars*p),R,fchar); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00147"></a>00147 
<a name="l00148"></a>00148     }
<a name="l00149"></a>00149   }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151   <span class="keywordflow">return</span>(0);
<a name="l00152"></a>00152 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a985d08c4fb9bcb71875c697f9e00d6eb"></a><!-- doxytag: member="interpolation.h::Interp1PrimThirdOrderMUSCLChar" ref="a985d08c4fb9bcb71875c697f9e00d6eb" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimThirdOrderMUSCLChar </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>3rd order MUSCL scheme with Koren's limiter (characteristic-based) on a uniform grid </p>
<p>Characteristic-based interpolation of the first primitive at the cell interfaces using the third-order MUSCL scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the 3rd order MUSCL scheme with Koren's limiter on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as: using the 3rd order MUSCL scheme with Koren's limiter as follows: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\alpha}^k_{j+1/2} = {\alpha}^k_{j-1} + \phi \left[\frac{1}{3}\left({\alpha}^k_j-{\alpha}^k_{j-1}\right) + \frac{1}{6}\left({\alpha}^k_{j-1}-{\alpha}^k_{j-2}\right)\right] \end{equation}" src="form_176.png"/>
</p>
<p> where </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \phi = \frac {3\left({\alpha}^k_j-{\alpha}^k_{j-1}\right)\left({\alpha}^k_{j-1}-{\alpha}^k_{j-2}\right) + \epsilon} {2\left[\left({\alpha}^k_j-{\alpha}^k_{j-1}\right)-\left({\alpha}^k_{j-1}-{\alpha}^k_{j-2}\right)\right]^2 + 3\left({\alpha}^k_j-{\alpha}^k_{j-1}\right)\left({\alpha}^k_{j-1}-{\alpha}^k_{j-2}\right) + \epsilon}, \end{equation}" src="form_177.png"/>
</p>
<p> <img class="formulaInl" alt="$\epsilon$" src="form_8.png"/> is a small constant (typically <img class="formulaInl" alt="$10^{-3}$" src="form_175.png"/>), and </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \alpha^k = {\bf l}_k \cdot {\bf f},\ k=1,\cdots,n \end{equation}" src="form_155.png"/>
</p>
<p> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th characteristic quantity, and <img class="formulaInl" alt="${\bf l}_k$" src="form_157.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th left eigenvector, <img class="formulaInl" alt="${\bf r}_k$" src="form_158.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th right eigenvector, and <img class="formulaInl" alt="$n$" src="form_141.png"/> is <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>. The final interpolated function is computed from the interpolated characteristic quantities as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = \sum_{k=1}^n \alpha^k_{j+1/2} {\bf r}_k \end{equation}" src="form_159.png"/>
</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + The method described above corresponds to a left-biased interpolation. The corresponding right-biased interpolation can be obtained by reflecting the equations about interface j+1/2. + The left and right eigenvectors are computed at an averaged quantity at j+1/2. Thus, this function requires functions to compute the average state, and the left and right eigenvectors. These are provided by the physical model through</p>
<ul>
<li><a class="el" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">HyPar::GetLeftEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a22eef349f191a1aa267e14b08140c823">HyPar::GetRightEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a7331366d789b2995436accbc35e1cc80">HyPar::AveragingFunction()</a></li>
</ul>
<p>If these functions are not provided by the physical model, then a characteristic-based interpolation cannot be used. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p>Reference: + van Leer, B., Towards the Ultimate Conservative Difference Scheme. 2: Monotonicity and Conservation Combined in a Second-Order Scheme, J. of Comput. Phys., 14 (4), 1974, pp.361-370, <a href="http://dx.doi.org/10.1016/0021-9991(74)">http://dx.doi.org/10.1016/0021-9991(74)</a>90019-9 + Koren, B., A Robust Upwind Discretization Method for Advection, Diffusion and Source Terms, Centrum voor Wiskunde en Informatica, Amsterdam, 1993 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00144_source.html#l00090">90</a> of file <a class="el" href="a00144_source.html">Interp1PrimThirdOrderMUSCLChar.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00092"></a>00092                                                                                                        {\bf f}\left({\bf u}\right)\f$ */
<a name="l00093"></a>00093                                     <span class="keywordtype">double</span> *u,   
<a name="l00094"></a>00094                                     <span class="keywordtype">double</span> *x,   
<a name="l00095"></a>00095                                     <span class="keywordtype">int</span>    upw,  
<a name="l00096"></a>00096                                     <span class="keywordtype">int</span>    dir,  
<a name="l00097"></a>00097                                     <span class="keywordtype">void</span>   *s,   
<a name="l00098"></a>00098                                     <span class="keywordtype">void</span>   *m,   
<a name="l00099"></a>00099                                     <span class="keywordtype">int</span>    uflag 
<a name="l00100"></a>00100                                   )
<a name="l00101"></a>00101 {
<a name="l00102"></a>00102   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>             *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*) s;
<a name="l00103"></a>00103   <a class="code" href="a00020.html" title="Structure of variables/parameters needed by the MUSCL scheme.">MUSCLParameters</a>   *muscl   = (<a class="code" href="a00020.html" title="Structure of variables/parameters needed by the MUSCL scheme.">MUSCLParameters</a>*) solver-&gt;<a class="code" href="a00015.html#a29c46b81ad574e4dfbad5a7211487dcb">interp</a>;
<a name="l00104"></a>00104   <span class="keywordtype">int</span>               i, k, v;
<a name="l00105"></a>00105   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00108"></a>00108   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00109"></a>00109   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00110"></a>00110   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   <span class="comment">/* define some constants */</span>
<a name="l00113"></a>00113   <span class="keywordtype">double</span> one_third = 1.0/3.0;
<a name="l00114"></a>00114   <span class="keywordtype">double</span> one_sixth = 1.0/6.0;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00117"></a>00117 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00118"></a>00118   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00119"></a>00119   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00120"></a>00120   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00121"></a>00121   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   <span class="comment">/* allocate arrays for the averaged state, eigenvectors and characteristic interpolated f */</span>
<a name="l00124"></a>00124   <span class="keywordtype">double</span> R[nvars*nvars], L[nvars*nvars], uavg[nvars], fchar[nvars];
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00127"></a>00127 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,k,v,R,L,uavg,fchar,index_outer,indexC,indexI)</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00129"></a>00129       <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00130"></a>00130       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00131"></a>00131       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133       <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00134"></a>00134 
<a name="l00135"></a>00135         <span class="comment">/* 1D indices of the stencil grid points */</span>
<a name="l00136"></a>00136         <span class="keywordtype">int</span> qm1,qm2,qp1;
<a name="l00137"></a>00137         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00138"></a>00138         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00139"></a>00139         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141         <span class="keywordtype">int</span> p; <span class="comment">/* 1D index of the interface */</span>
<a name="l00142"></a>00142         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144         <span class="comment">/* find averaged state at this interface */</span>
<a name="l00145"></a>00145         <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a7331366d789b2995436accbc35e1cc80">AveragingFunction</a>(uavg,&amp;u[nvars*qm1],&amp;u[nvars*qp1],solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>);
<a name="l00146"></a>00146         <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00147"></a>00147 
<a name="l00148"></a>00148         <span class="comment">/* Get the left and right eigenvectors */</span>
<a name="l00149"></a>00149         <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">GetLeftEigenvectors</a>  (uavg,L,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00150"></a>00150         <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a22eef349f191a1aa267e14b08140c823">GetRightEigenvectors</a> (uavg,R,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00151"></a>00151 
<a name="l00152"></a>00152         <span class="comment">/* For each characteristic field */</span>
<a name="l00153"></a>00153         <span class="keywordflow">for</span> (v = 0; v &lt; nvars; v++) {
<a name="l00154"></a>00154           <span class="comment">/* calculate the characteristic flux components along this characteristic */</span>
<a name="l00155"></a>00155           <span class="keywordtype">double</span> m2, m1, p1;
<a name="l00156"></a>00156           m2 = m1 = p1 = 0;
<a name="l00157"></a>00157           <span class="keywordflow">for</span> (k = 0; k &lt; nvars; k++) {
<a name="l00158"></a>00158             m2 += L[v*nvars+k] * fC[qm2*nvars+k];
<a name="l00159"></a>00159             m1 += L[v*nvars+k] * fC[qm1*nvars+k];
<a name="l00160"></a>00160             p1 += L[v*nvars+k] * fC[qp1*nvars+k];
<a name="l00161"></a>00161           }
<a name="l00162"></a>00162           <span class="keywordtype">double</span> fdiff = p1 - m1;
<a name="l00163"></a>00163           <span class="keywordtype">double</span> bdiff = m1 - m2;
<a name="l00164"></a>00164           <span class="keywordtype">double</span> limit =  (3*fdiff*bdiff + muscl-&gt;<a class="code" href="a00020.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>) 
<a name="l00165"></a>00165                         / (2*(fdiff-bdiff)*(fdiff-bdiff) + 3*fdiff*bdiff + muscl-&gt;<a class="code" href="a00020.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>);
<a name="l00166"></a>00166           fchar[v] = m1 +  limit * (one_third*fdiff + one_sixth*bdiff);
<a name="l00167"></a>00167         }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         <span class="comment">/* calculate the interface u from the characteristic u */</span>
<a name="l00170"></a>00170         <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00043.html#a3dc53d4eb4ba0f2cfed00aa69617ee84">MatVecMult</a>(nvars,(fI+nvars*p),R,fchar); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00171"></a>00171       }
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173   } <span class="keywordflow">else</span> {
<a name="l00174"></a>00174 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,k,v,R,L,uavg,fchar,index_outer,indexC,indexI)</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00176"></a>00176       <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00177"></a>00177       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00178"></a>00178       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180       <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00181"></a>00181 
<a name="l00182"></a>00182         <span class="comment">/* 1D indices of the stencil grid points */</span>
<a name="l00183"></a>00183         <span class="keywordtype">int</span> qm1,qp1,qp2;
<a name="l00184"></a>00184         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00185"></a>00185         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00186"></a>00186         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00187"></a>00187 
<a name="l00188"></a>00188         <span class="keywordtype">int</span> p; <span class="comment">/* 1D index of the interface */</span>
<a name="l00189"></a>00189         <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         <span class="comment">/* find averaged state at this interface */</span>
<a name="l00192"></a>00192         <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a7331366d789b2995436accbc35e1cc80">AveragingFunction</a>(uavg,&amp;u[nvars*qm1],&amp;u[nvars*qp1],solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>);
<a name="l00193"></a>00193         <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         <span class="comment">/* Get the left and right eigenvectors */</span>
<a name="l00196"></a>00196         <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">GetLeftEigenvectors</a>  (uavg,L,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00197"></a>00197         <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a22eef349f191a1aa267e14b08140c823">GetRightEigenvectors</a> (uavg,R,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00198"></a>00198 
<a name="l00199"></a>00199         <span class="comment">/* For each characteristic field */</span>
<a name="l00200"></a>00200         <span class="keywordflow">for</span> (v = 0; v &lt; nvars; v++) {
<a name="l00201"></a>00201           <span class="comment">/* calculate the characteristic flux components along this characteristic */</span>
<a name="l00202"></a>00202           <span class="keywordtype">double</span> m1, p1, p2;
<a name="l00203"></a>00203           m1 = p1 = p2 = 0;
<a name="l00204"></a>00204           <span class="keywordflow">for</span> (k = 0; k &lt; nvars; k++) {
<a name="l00205"></a>00205             m1 += L[v*nvars+k] * fC[qm1*nvars+k];
<a name="l00206"></a>00206             p1 += L[v*nvars+k] * fC[qp1*nvars+k];
<a name="l00207"></a>00207             p2 += L[v*nvars+k] * fC[qp2*nvars+k];
<a name="l00208"></a>00208           }
<a name="l00209"></a>00209           <span class="keywordtype">double</span> fdiff = p2 - p1;
<a name="l00210"></a>00210           <span class="keywordtype">double</span> bdiff = p1 - m1;
<a name="l00211"></a>00211           <span class="keywordtype">double</span> limit =  (3*fdiff*bdiff + muscl-&gt;<a class="code" href="a00020.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>) 
<a name="l00212"></a>00212                         / (2*(fdiff-bdiff)*(fdiff-bdiff) + 3*fdiff*bdiff + muscl-&gt;<a class="code" href="a00020.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>);
<a name="l00213"></a>00213           fchar[v] = p1 -  limit * (one_third*fdiff + one_sixth*bdiff);
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         <span class="comment">/* calculate the interface u from the characteristic u */</span>
<a name="l00217"></a>00217         <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00043.html#a3dc53d4eb4ba0f2cfed00aa69617ee84">MatVecMult</a>(nvars,(fI+nvars*p),R,fchar); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00218"></a>00218       }
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220   }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222   <span class="keywordflow">return</span>(0);
<a name="l00223"></a>00223 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ade9ece6e934d70cdf29090494440f505"></a><!-- doxytag: member="interpolation.h::Interp1PrimFifthOrderUpwindChar" ref="ade9ece6e934d70cdf29090494440f505" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFifthOrderUpwindChar </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5th order upwind reconstruction (characteristic-based) on a uniform grid </p>
<p>Characteristic-based interpolation of the first primitive at the cell interfaces using the fifth-order upwind scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the fifth order upwind scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 5th order upwind numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \hat{\alpha}^k_{j+1/2} = \frac{1}{30} {\alpha}^k_{j-2} - \frac{13}{60}{\alpha}^k_{j-1} + \frac{47}{60}{\alpha}^k_j + \frac{27}{60}{\alpha}^k_{j+1} - \frac{1}{20}{\alpha}^k_{j+2}, \end{align}" src="form_166.png"/>
</p>
<p> where </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \alpha^k = {\bf l}_k \cdot {\bf f},\ k=1,\cdots,n \end{equation}" src="form_155.png"/>
</p>
<p> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th characteristic quantity, and <img class="formulaInl" alt="${\bf l}_k$" src="form_157.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th left eigenvector, <img class="formulaInl" alt="${\bf r}_k$" src="form_158.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th right eigenvector, and <img class="formulaInl" alt="$n$" src="form_141.png"/> is <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>. The final interpolated function is computed from the interpolated characteristic quantities as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = \sum_{k=1}^n \alpha^k_{j+1/2} {\bf r}_k \end{equation}" src="form_159.png"/>
</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + The method described above corresponds to a left-biased interpolation. The corresponding right-biased interpolation can be obtained by reflecting the equations about interface j+1/2. + The left and right eigenvectors are computed at an averaged quantity at j+1/2. Thus, this function requires functions to compute the average state, and the left and right eigenvectors. These are provided by the physical model through</p>
<ul>
<li><a class="el" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">HyPar::GetLeftEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a22eef349f191a1aa267e14b08140c823">HyPar::GetRightEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a7331366d789b2995436accbc35e1cc80">HyPar::AveragingFunction()</a></li>
</ul>
<p>If these functions are not provided by the physical model, then a characteristic-based interpolation cannot be used. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p><b>Reference:</b> + Jiang, G.-S., Shu, C.-W., Efficient Implementation of Weighted ENO Schemes, J. Comput. Phys., 126 (1), 1996, pp. 202-228, <a href="http://dx.doi.org/10.1006/jcph.1996.0130">http://dx.doi.org/10.1006/jcph.1996.0130</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00136_source.html#l00083">83</a> of file <a class="el" href="a00136_source.html">Interp1PrimFifthOrderUpwindChar.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00085"></a>00085                                                                                                        {\bf f}\left({\bf u}\right)\f$ */
<a name="l00086"></a>00086                                     <span class="keywordtype">double</span> *u,   
<a name="l00087"></a>00087                                     <span class="keywordtype">double</span> *x,   
<a name="l00088"></a>00088                                     <span class="keywordtype">int</span>    upw,  
<a name="l00089"></a>00089                                     <span class="keywordtype">int</span>    dir,  
<a name="l00090"></a>00090                                     <span class="keywordtype">void</span>   *s,   
<a name="l00091"></a>00091                                     <span class="keywordtype">void</span>   *m,   
<a name="l00092"></a>00092                                     <span class="keywordtype">int</span>    uflag 
<a name="l00093"></a>00093                                    )
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*) s;
<a name="l00096"></a>00096   <span class="keywordtype">int</span>             i, k, v;
<a name="l00097"></a>00097   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00100"></a>00100   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00101"></a>00101   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00102"></a>00102   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="comment">/* define some constants */</span>
<a name="l00105"></a>00105   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_by_thirty        = 1.0/30.0,
<a name="l00106"></a>00106                       thirteen_by_sixty    = 13.0/60.0,
<a name="l00107"></a>00107                       fortyseven_by_sixty  = 47.0/60.0,
<a name="l00108"></a>00108                       twentyseven_by_sixty = 27.0/60.0,
<a name="l00109"></a>00109                       one_by_twenty        = 1.0/20.0;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00112"></a>00112 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00113"></a>00113   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00114"></a>00114   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00115"></a>00115   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00116"></a>00116   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118   <span class="comment">/* allocate arrays for the averaged state, eigenvectors and characteristic interpolated f */</span>
<a name="l00119"></a>00119   <span class="keywordtype">double</span> R[nvars*nvars], L[nvars*nvars], uavg[nvars], fchar[nvars];
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,k,v,R,L,uavg,fchar,index_outer,indexC,indexI)</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00123"></a>00123     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00124"></a>00124     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00125"></a>00125     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00126"></a>00126 
<a name="l00127"></a>00127     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00128"></a>00128 
<a name="l00129"></a>00129       <span class="comment">/* 1D indices of the stencil grid points */</span>
<a name="l00130"></a>00130       <span class="keywordtype">int</span> qm1,qm2,qm3,qp1,qp2;
<a name="l00131"></a>00131       <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00132"></a>00132         indexC[dir] = indexI[dir]-3; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00133"></a>00133         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00134"></a>00134         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00135"></a>00135         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00136"></a>00136         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00137"></a>00137       } <span class="keywordflow">else</span> {
<a name="l00138"></a>00138         indexC[dir] = indexI[dir]+2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00139"></a>00139         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00140"></a>00140         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00141"></a>00141         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00142"></a>00142         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00143"></a>00143       }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145       <span class="keywordtype">int</span> p; <span class="comment">/* 1D index of the interface */</span>
<a name="l00146"></a>00146       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00147"></a>00147 
<a name="l00148"></a>00148       <span class="comment">/* find averaged state at this interface */</span>
<a name="l00149"></a>00149       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a7331366d789b2995436accbc35e1cc80">AveragingFunction</a>(uavg,&amp;u[nvars*qm1],&amp;u[nvars*qp1],solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00150"></a>00150 
<a name="l00151"></a>00151       <span class="comment">/* Get the left and right eigenvectors */</span>
<a name="l00152"></a>00152       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">GetLeftEigenvectors</a>  (uavg,L,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00153"></a>00153       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a22eef349f191a1aa267e14b08140c823">GetRightEigenvectors</a> (uavg,R,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155       <span class="comment">/* For each characteristic field */</span>
<a name="l00156"></a>00156       <span class="keywordflow">for</span> (v = 0; v &lt; nvars; v++) {
<a name="l00157"></a>00157 
<a name="l00158"></a>00158         <span class="comment">/* calculate the characteristic flux components along this characteristic */</span>
<a name="l00159"></a>00159         <span class="keywordtype">double</span> fm3, fm2, fm1, fp1, fp2;
<a name="l00160"></a>00160         fm3 = fm2 = fm1 = fp1 = fp2 = 0;
<a name="l00161"></a>00161         <span class="keywordflow">for</span> (k = 0; k &lt; nvars; k++) {
<a name="l00162"></a>00162           fm3 += L[v*nvars+k] * fC[qm3*nvars+k];
<a name="l00163"></a>00163           fm2 += L[v*nvars+k] * fC[qm2*nvars+k];
<a name="l00164"></a>00164           fm1 += L[v*nvars+k] * fC[qm1*nvars+k];
<a name="l00165"></a>00165           fp1 += L[v*nvars+k] * fC[qp1*nvars+k];
<a name="l00166"></a>00166           fp2 += L[v*nvars+k] * fC[qp2*nvars+k];
<a name="l00167"></a>00167         }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         <span class="comment">/* fifth order upwind approximation of the characteristic flux */</span>
<a name="l00170"></a>00170         fchar[v] =    one_by_thirty         * fm3
<a name="l00171"></a>00171                    -  thirteen_by_sixty     * fm2
<a name="l00172"></a>00172                    +  fortyseven_by_sixty   * fm1
<a name="l00173"></a>00173                    +  twentyseven_by_sixty  * fp1
<a name="l00174"></a>00174                    -  one_by_twenty         * fp2;
<a name="l00175"></a>00175       }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177       <span class="comment">/* calculate the interface u from the characteristic u */</span>
<a name="l00178"></a>00178       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00043.html#a3dc53d4eb4ba0f2cfed00aa69617ee84">MatVecMult</a>(nvars,(fI+nvars*p),R,fchar); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181   }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183   <span class="keywordflow">return</span>(0);
<a name="l00184"></a>00184 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a28b8d3ce17676cec19de4f91f989042d"></a><!-- doxytag: member="interpolation.h::Interp1PrimFifthOrderCompactUpwindChar" ref="a28b8d3ce17676cec19de4f91f989042d" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFifthOrderCompactUpwindChar </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5th order compact upwind reconstruction (characteristic-based) on a uniform grid </p>
<p>Characteristic-based interpolation of the first primitive at the cell interfaces using the fifth-order compact upwind scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the fifth order compact upwind scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 5th order compact upwind numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \frac{3}{10}\hat{\alpha}^k_{j-1/2} + \frac{6}{10}\hat{\alpha}^k_{j+1/2} + \frac{1}{10}\hat{\alpha}^k_{j+3/2} = \frac{}{30}{\alpha}^k_{j-1} + \frac{19}{30}{\alpha}^k_j + \frac{1}{3}{\alpha}^k_{j+1}, \end{align}" src="form_154.png"/>
</p>
<p> where </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \alpha^k = {\bf l}_k \cdot {\bf f},\ k=1,\cdots,n \end{equation}" src="form_155.png"/>
</p>
<p> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th characteristic quantity, and <img class="formulaInl" alt="${\bf l}_k$" src="form_157.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th left eigenvector, <img class="formulaInl" alt="${\bf r}_k$" src="form_158.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th right eigenvector, and <img class="formulaInl" alt="$n$" src="form_141.png"/> is <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>. The resulting block tridiagonal system is solved using <a class="el" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU()</a> (see also <a class="el" href="a00029.html">TridiagLU</a>, <a class="el" href="a00062.html" title="Header file for TridiagLU.">tridiagLU.h</a>). The final interpolated function is computed from the interpolated characteristic quantities as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = \sum_{k=1}^n \alpha^k_{j+1/2} {\bf r}_k \end{equation}" src="form_159.png"/>
</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + The method described above corresponds to a left-biased interpolation. The corresponding right-biased interpolation can be obtained by reflecting the equations about interface j+1/2. + The left and right eigenvectors are computed at an averaged quantity at j+1/2. Thus, this function requires functions to compute the average state, and the left and right eigenvectors. These are provided by the physical model through</p>
<ul>
<li><a class="el" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">HyPar::GetLeftEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a22eef349f191a1aa267e14b08140c823">HyPar::GetRightEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a7331366d789b2995436accbc35e1cc80">HyPar::AveragingFunction()</a></li>
</ul>
<p>If these functions are not provided by the physical model, then a characteristic-based interpolation cannot be used. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p><b>Reference:</b> + Ghosh, D., Baeder, J. D., Compact Reconstruction Schemes with Weighted ENO Limiting for Hyperbolic Conservation Laws, SIAM Journal on Scientific Computing, 34 (3), 2012, A1678–A1706, <a href="http://dx.doi.org/10.1137/110857659">http://dx.doi.org/10.1137/110857659</a> + Ghosh, D., Constantinescu, E. M., Brown, J., Efficient Implementation of Nonlinear Compact Schemes on Massively Parallel Platforms, SIAM Journal on Scientific Computing, 37 (3), 2015, C354–C383, <a href="http://dx.doi.org/10.1137/140989261">http://dx.doi.org/10.1137/140989261</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00130_source.html#l00089">89</a> of file <a class="el" href="a00130_source.html">Interp1PrimFifthOrderCompactUpwindChar.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00091"></a>00091                                                                                                                {\bf f}\left({\bf u}\right)\f$ */
<a name="l00092"></a>00092                                             <span class="keywordtype">double</span> *u,   
<a name="l00093"></a>00093                                             <span class="keywordtype">double</span> *x,   
<a name="l00094"></a>00094                                             <span class="keywordtype">int</span>    upw,  
<a name="l00095"></a>00095                                             <span class="keywordtype">int</span>    dir,  
<a name="l00096"></a>00096                                             <span class="keywordtype">void</span>   *s,   
<a name="l00097"></a>00097                                             <span class="keywordtype">void</span>   *m,   
<a name="l00098"></a>00098                                             <span class="keywordtype">int</span>    uflag 
<a name="l00099"></a>00099                                           )
<a name="l00100"></a>00100 {
<a name="l00101"></a>00101   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)          s;
<a name="l00102"></a>00102   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>    *mpi    = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*)   m;
<a name="l00103"></a>00103   <a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>   *compact= (<a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>*)  solver-&gt;<a class="code" href="a00015.html#a56318721d534e74a96b440f8542a0232">compact</a>;
<a name="l00104"></a>00104   <a class="code" href="a00029.html">TridiagLU</a>       *lu     = (<a class="code" href="a00029.html">TridiagLU</a>*)      solver-&gt;<a class="code" href="a00015.html#a1dbfa1e479a373073b6ebf72401a7f0f">lusolver</a>;
<a name="l00105"></a>00105   <span class="keywordtype">int</span>             sys,Nsys,d,v,k;
<a name="l00106"></a>00106   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00109"></a>00109   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00110"></a>00110   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00111"></a>00111   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   <span class="comment">/* define some constants */</span>
<a name="l00114"></a>00114   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> three_by_ten          = 3.0/10.0,
<a name="l00115"></a>00115                       six_by_ten            = 6.0/10.0,
<a name="l00116"></a>00116                       one_by_ten            = 1.0/10.0,
<a name="l00117"></a>00117                       one_by_thirty         = 1.0/30.0,
<a name="l00118"></a>00118                       nineteen_by_thirty    = 19.0/30.0,
<a name="l00119"></a>00119                       one_third             = 1.0/3.0,
<a name="l00120"></a>00120                       thirteen_by_sixty     = 13.0/60.0,
<a name="l00121"></a>00121                       fortyseven_by_sixty   = 47.0/60.0,
<a name="l00122"></a>00122                       twentyseven_by_sixty  = 27.0/60.0,
<a name="l00123"></a>00123                       one_by_twenty         = 1.0/20.0;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00126"></a>00126 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00127"></a>00127   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00128"></a>00128   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00129"></a>00129   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131   <span class="comment">/* calculate total number of block tridiagonal systems to solve */</span>
<a name="l00132"></a>00132   <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,Nsys);
<a name="l00133"></a>00133 
<a name="l00134"></a>00134   <span class="comment">/* allocate arrays for the averaged state, eigenvectors and characteristic interpolated f */</span>
<a name="l00135"></a>00135   <span class="keywordtype">double</span> R[nvars*nvars], L[nvars*nvars], uavg[nvars];
<a name="l00136"></a>00136 
<a name="l00137"></a>00137   <span class="comment">/* Allocate arrays for tridiagonal system */</span>
<a name="l00138"></a>00138   <span class="keywordtype">double</span> *A = compact-&gt;<a class="code" href="a00003.html#ac900805a486cbb8489e3c176ed6e0d8e">A</a>;
<a name="l00139"></a>00139   <span class="keywordtype">double</span> *B = compact-&gt;<a class="code" href="a00003.html#ad36954709307649365515214a02ab06d">B</a>;
<a name="l00140"></a>00140   <span class="keywordtype">double</span> *C = compact-&gt;<a class="code" href="a00003.html#a0a26ce8d1878aac6ddc87e3f6290e039">C</a>;
<a name="l00141"></a>00141   <span class="keywordtype">double</span> *F = compact-&gt;<a class="code" href="a00003.html#ac06de847603f5cfaec085f6fe500f3c8">R</a>;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,v,k,R,L,uavg,index_outer,indexC,indexI)</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys&lt;Nsys; sys++) {
<a name="l00145"></a>00145     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00146"></a>00146     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00147"></a>00147     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00148"></a>00148     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00149"></a>00149       <span class="keywordtype">int</span> qm1,qm2,qm3,qp1,qp2;
<a name="l00150"></a>00150       <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00151"></a>00151         indexC[dir] = indexI[dir]-3; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00152"></a>00152         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00153"></a>00153         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00154"></a>00154         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00155"></a>00155         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00156"></a>00156       } <span class="keywordflow">else</span> {
<a name="l00157"></a>00157         indexC[dir] = indexI[dir]+2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00158"></a>00158         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00159"></a>00159         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00160"></a>00160         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00161"></a>00161         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00162"></a>00162       }
<a name="l00163"></a>00163 
<a name="l00164"></a>00164       <span class="keywordtype">int</span> p; <span class="comment">/* 1D index of the interface */</span>
<a name="l00165"></a>00165       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167       <span class="comment">/* find averaged state at this interface */</span>
<a name="l00168"></a>00168       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a7331366d789b2995436accbc35e1cc80">AveragingFunction</a>(uavg,&amp;u[nvars*qm1],&amp;u[nvars*qp1],solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170       <span class="comment">/* Get the left and right eigenvectors */</span>
<a name="l00171"></a>00171       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">GetLeftEigenvectors</a>  (uavg,L,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00172"></a>00172       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a22eef349f191a1aa267e14b08140c823">GetRightEigenvectors</a> (uavg,R,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00173"></a>00173 
<a name="l00174"></a>00174       <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++)  {
<a name="l00175"></a>00175 
<a name="l00176"></a>00176         <span class="comment">/* calculate the characteristic flux components along this characteristic */</span>
<a name="l00177"></a>00177         <span class="keywordtype">double</span> fm3, fm2, fm1, fp1, fp2;
<a name="l00178"></a>00178         fm3 = fm2 = fm1 = fp1 = fp2 = 0;
<a name="l00179"></a>00179         <span class="keywordflow">for</span> (k = 0; k &lt; nvars; k++) {
<a name="l00180"></a>00180           fm3 += L[v*nvars+k] * fC[qm3*nvars+k];
<a name="l00181"></a>00181           fm2 += L[v*nvars+k] * fC[qm2*nvars+k];
<a name="l00182"></a>00182           fm1 += L[v*nvars+k] * fC[qm1*nvars+k];
<a name="l00183"></a>00183           fp1 += L[v*nvars+k] * fC[qp1*nvars+k];
<a name="l00184"></a>00184           fp2 += L[v*nvars+k] * fC[qp2*nvars+k];
<a name="l00185"></a>00185         }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         <span class="keywordflow">if</span> (   ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == 0                ) &amp;&amp; (indexI[dir] == 0       ))
<a name="l00188"></a>00188             || ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) &amp;&amp; (indexI[dir] == dim[dir])) ) {
<a name="l00189"></a>00189           <span class="comment">/* Use 5th order upwind at the physical boundaries */</span>
<a name="l00190"></a>00190           <span class="keywordflow">for</span> (k=0; k&lt;nvars; k++) {
<a name="l00191"></a>00191             A[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = 0.0;
<a name="l00192"></a>00192             C[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = 0.0;
<a name="l00193"></a>00193             B[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = L[v*nvars+k];
<a name="l00194"></a>00194           }
<a name="l00195"></a>00195           F[(Nsys*indexI[dir]+sys)*nvars+v] =   one_by_thirty         * fm3
<a name="l00196"></a>00196                                               - thirteen_by_sixty     * fm2
<a name="l00197"></a>00197                                               + fortyseven_by_sixty   * fm1
<a name="l00198"></a>00198                                               + twentyseven_by_sixty  * fp1
<a name="l00199"></a>00199                                               - one_by_twenty         * fp2;
<a name="l00200"></a>00200         } <span class="keywordflow">else</span> {
<a name="l00201"></a>00201           <span class="comment">/* 5th order compact upwind at the interior points */</span>
<a name="l00202"></a>00202           <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00203"></a>00203             <span class="keywordflow">for</span> (k=0; k&lt;nvars; k++) {
<a name="l00204"></a>00204               A[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = three_by_ten * L[v*nvars+k];
<a name="l00205"></a>00205               B[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = six_by_ten   * L[v*nvars+k];
<a name="l00206"></a>00206               C[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = one_by_ten   * L[v*nvars+k];
<a name="l00207"></a>00207             }
<a name="l00208"></a>00208           } <span class="keywordflow">else</span> {
<a name="l00209"></a>00209             <span class="keywordflow">for</span> (k=0; k&lt;nvars; k++) {
<a name="l00210"></a>00210               C[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = three_by_ten * L[v*nvars+k];
<a name="l00211"></a>00211               B[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = six_by_ten   * L[v*nvars+k];
<a name="l00212"></a>00212               A[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = one_by_ten   * L[v*nvars+k];
<a name="l00213"></a>00213             }
<a name="l00214"></a>00214           }
<a name="l00215"></a>00215           F[(Nsys*indexI[dir]+sys)*nvars+v] =   one_by_thirty      * fm2
<a name="l00216"></a>00216                                               + nineteen_by_thirty * fm1
<a name="l00217"></a>00217                                               + one_third          * fp1;
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219       }
<a name="l00220"></a>00220     }
<a name="l00221"></a>00221   }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 <span class="preprocessor">#ifdef serial</span>
<a name="l00224"></a>00224 <span class="preprocessor"></span>
<a name="l00225"></a>00225   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00226"></a>00226   <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU</a>(A,B,C,F,dim[dir]+1,Nsys,nvars,lu,NULL); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="preprocessor">#else</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span>
<a name="l00230"></a>00230   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00231"></a>00231   <span class="comment">/* all processes except the last will solve without the last interface to avoid overlap */</span>
<a name="l00232"></a>00232   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1)  { 
<a name="l00233"></a>00233     <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU</a>(A,B,C,F,dim[dir]  ,Nsys,nvars,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr); 
<a name="l00234"></a>00234   } <span class="keywordflow">else</span> { 
<a name="l00235"></a>00235     <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU</a>(A,B,C,F,dim[dir]+1,Nsys,nvars,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00236"></a>00236   }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238   <span class="comment">/* Now get the solution to the last interface from the next proc */</span>
<a name="l00239"></a>00239   <span class="keywordtype">double</span> *sendbuf = compact-&gt;<a class="code" href="a00003.html#aba3b15034da676474db917f9f5533085">sendbuf</a>;
<a name="l00240"></a>00240   <span class="keywordtype">double</span> *recvbuf = compact-&gt;<a class="code" href="a00003.html#afc23e46e08649e112e8d64d780cea5cb">recvbuf</a>;
<a name="l00241"></a>00241   MPI_Request req[2] = {MPI_REQUEST_NULL,MPI_REQUEST_NULL};
<a name="l00242"></a>00242   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]) <span class="keywordflow">for</span> (d=0; d&lt;Nsys*nvars; d++) sendbuf[d] = F[d];
<a name="l00243"></a>00243   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) MPI_Irecv(recvbuf,Nsys*nvars,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]+1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[0]);
<a name="l00244"></a>00244   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir])                      MPI_Isend(sendbuf,Nsys*nvars,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]-1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[1]);
<a name="l00245"></a>00245   MPI_Waitall(2,&amp;req[0],MPI_STATUS_IGNORE);
<a name="l00246"></a>00246   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) <span class="keywordflow">for</span> (d=0; d&lt;Nsys*nvars; d++) F[d+Nsys*nvars*dim[dir]] = recvbuf[d];
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="preprocessor">#endif</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span>
<a name="l00250"></a>00250   <span class="comment">/* save the solution to fI */</span>
<a name="l00251"></a>00251 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,v,k,R,L,uavg,index_outer,indexC,indexI)</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys&lt;Nsys; sys++) {
<a name="l00253"></a>00253     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00254"></a>00254     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00255"></a>00255     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00256"></a>00256       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00257"></a>00257       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((F+sys*nvars+Nsys*nvars*indexI[dir]),(fI+nvars*p),nvars);
<a name="l00258"></a>00258     }
<a name="l00259"></a>00259   }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261   <span class="keywordflow">return</span>(0);
<a name="l00262"></a>00262 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abf3b032fdc8c0e84b86909db9e0b93c3"></a><!-- doxytag: member="interpolation.h::Interp1PrimFifthOrderWENOChar" ref="abf3b032fdc8c0e84b86909db9e0b93c3" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFifthOrderWENOChar </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5th order WENO reconstruction (characteristic-based) on a uniform grid </p>
<p>Characteristic-based interpolation of the first primitive at the cell interfaces using the fifth-order WENO scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the fifth order WENO scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 5th order WENO numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as the convex combination of three 3rd order methods: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} &amp;\ \omega_1\ \times\ \left[ \hat{\alpha}^k_{j+1/2} = \frac{1}{3} {\alpha}^k_{j-2} - \frac{7}{6} {\alpha}^k_{j-1} + \frac{11}{6} {\alpha}^k_j \right]\\ + &amp;\ \omega_2\ \times\ \left[ \hat{\alpha}^k_{j+1/2} = -\frac{1}{6} {\alpha}^k_{j-1} + \frac{5}{6} {\alpha}^k_j + \frac{1}{3} {\alpha}^k_{j+1} \right]\\ + &amp;\ \omega_3\ \times\ \left[ \hat{\alpha}^k_{j+1/2} = \frac{1}{3} {\alpha}^k_j + \frac{5}{6} {\alpha}^k_{j+1} - \frac{1}{6} {\alpha}^k_{j+2} \right]\\ \Rightarrow &amp;\ \hat{\alpha}^k_{j+1/2} = \frac{\omega_1}{3} {\alpha}^k_{j-2} - \frac{1}{6}(7\omega_1+\omega_2){\alpha}^k_{j-1} + \frac{1}{6}(11\omega_1+5\omega_2+2\omega_3){\alpha}^k_j + \frac{1}{6}(2\omega_2+5\omega_3){\alpha}^k_{j+1} - \frac{\omega_3}{6}{\alpha}^k_{j+2}, \end{align}" src="form_168.png"/>
</p>
<p> where </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \alpha^k = {\bf l}_k \cdot {\bf f},\ k=1,\cdots,n \end{equation}" src="form_155.png"/>
</p>
<p> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th characteristic quantity, and <img class="formulaInl" alt="${\bf l}_k$" src="form_157.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th left eigenvector, <img class="formulaInl" alt="${\bf r}_k$" src="form_158.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th right eigenvector, and <img class="formulaInl" alt="$n$" src="form_141.png"/> is <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>. The nonlinear weights <img class="formulaInl" alt="$\omega_k; k=1,2,3$" src="form_161.png"/> are the WENO weights computed in <a class="el" href="a00148.html#a6f1f5da1b6e5134bb1deccfad05a506d">WENOFifthOrderCalculateWeightsChar()</a>. The final interpolated function is computed from the interpolated characteristic quantities as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = \sum_{k=1}^n \alpha^k_{j+1/2} {\bf r}_k \end{equation}" src="form_159.png"/>
</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + The method described above corresponds to a left-biased interpolation. The corresponding right-biased interpolation can be obtained by reflecting the equations about interface j+1/2. + The left and right eigenvectors are computed at an averaged quantity at j+1/2. Thus, this function requires functions to compute the average state, and the left and right eigenvectors. These are provided by the physical model through</p>
<ul>
<li><a class="el" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">HyPar::GetLeftEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a22eef349f191a1aa267e14b08140c823">HyPar::GetRightEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a7331366d789b2995436accbc35e1cc80">HyPar::AveragingFunction()</a></li>
</ul>
<p>If these functions are not provided by the physical model, then a characteristic-based interpolation cannot be used. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p><b>Reference:</b> + Jiang, G.-S., Shu, C.-W., Efficient Implementation of Weighted ENO Schemes, J. Comput. Phys., 126 (1), 1996, pp. 202-228, <a href="http://dx.doi.org/10.1006/jcph.1996.0130">http://dx.doi.org/10.1006/jcph.1996.0130</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00138_source.html#l00085">85</a> of file <a class="el" href="a00138_source.html">Interp1PrimFifthOrderWENOChar.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00087"></a>00087                                                                                                        {\bf f}\left({\bf u}\right)\f$ */
<a name="l00088"></a>00088                                     <span class="keywordtype">double</span> *u,   
<a name="l00089"></a>00089                                     <span class="keywordtype">double</span> *x,   
<a name="l00090"></a>00090                                     <span class="keywordtype">int</span>    upw,  
<a name="l00091"></a>00091                                     <span class="keywordtype">int</span>    dir,  
<a name="l00092"></a>00092                                     <span class="keywordtype">void</span>   *s,   
<a name="l00093"></a>00093                                     <span class="keywordtype">void</span>   *m,   
<a name="l00094"></a>00094                                     <span class="keywordtype">int</span>    uflag 
<a name="l00095"></a>00095                                  )
<a name="l00096"></a>00096 {
<a name="l00097"></a>00097   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*) s;
<a name="l00098"></a>00098   <a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>  *weno   = (<a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>*) solver-&gt;<a class="code" href="a00015.html#a29c46b81ad574e4dfbad5a7211487dcb">interp</a>;
<a name="l00099"></a>00099   <span class="keywordtype">int</span>             i, k, v;
<a name="l00100"></a>00100   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00101"></a>00101 
<a name="l00102"></a>00102   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00103"></a>00103   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00104"></a>00104   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00105"></a>00105   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107   <span class="comment">/* define some constants */</span>
<a name="l00108"></a>00108   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_sixth          = 1.0/6.0;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110   <span class="keywordtype">double</span> *ww1, *ww2, *ww3;
<a name="l00111"></a>00111   ww1 = weno-&gt;<a class="code" href="a00030.html#a3ee56e3d8244b3d4582f1396a79f9791">w1</a> + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;<a class="code" href="a00030.html#a439227feff9d7f55384e8780cfc2eb82">size</a> : 0) + weno-&gt;<a class="code" href="a00030.html#ad0c30ee1add42468a6d7c022f2efdf70">offset</a>[dir];
<a name="l00112"></a>00112   ww2 = weno-&gt;<a class="code" href="a00030.html#a31eb3c1fcb3bc85ab4fa156325a1f849">w2</a> + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;<a class="code" href="a00030.html#a439227feff9d7f55384e8780cfc2eb82">size</a> : 0) + weno-&gt;<a class="code" href="a00030.html#ad0c30ee1add42468a6d7c022f2efdf70">offset</a>[dir];
<a name="l00113"></a>00113   ww3 = weno-&gt;<a class="code" href="a00030.html#aabd83eb3f8a7e3bb9f79a4a943bbd508">w3</a> + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;<a class="code" href="a00030.html#a439227feff9d7f55384e8780cfc2eb82">size</a> : 0) + weno-&gt;<a class="code" href="a00030.html#ad0c30ee1add42468a6d7c022f2efdf70">offset</a>[dir];
<a name="l00114"></a>00114 
<a name="l00115"></a>00115   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00116"></a>00116 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00117"></a>00117   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00118"></a>00118   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00119"></a>00119   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00120"></a>00120   <span class="keywordtype">int</span> N_outer; <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,N_outer);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122   <span class="comment">/* allocate arrays for the averaged state, eigenvectors and characteristic interpolated f */</span>
<a name="l00123"></a>00123   <span class="keywordtype">double</span> R[nvars*nvars], L[nvars*nvars], uavg[nvars], fchar[nvars];
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(i,k,v,R,L,uavg,fchar,index_outer,indexC,indexI)</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (i=0; i&lt;N_outer; i++) {
<a name="l00127"></a>00127     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,i,bounds_outer,index_outer,0);
<a name="l00128"></a>00128     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00129"></a>00129     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00132"></a>00132 
<a name="l00133"></a>00133       <span class="comment">/* 1D indices of the stencil grid points */</span>
<a name="l00134"></a>00134       <span class="keywordtype">int</span> qm1,qm2,qm3,qp1,qp2;
<a name="l00135"></a>00135       <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00136"></a>00136         indexC[dir] = indexI[dir]-3; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00137"></a>00137         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00138"></a>00138         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00139"></a>00139         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00140"></a>00140         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00141"></a>00141       } <span class="keywordflow">else</span> {
<a name="l00142"></a>00142         indexC[dir] = indexI[dir]+2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00143"></a>00143         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00144"></a>00144         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00145"></a>00145         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00146"></a>00146         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00147"></a>00147       }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149       <span class="keywordtype">int</span> p; <span class="comment">/* 1D index of the interface */</span>
<a name="l00150"></a>00150       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00151"></a>00151 
<a name="l00152"></a>00152       <span class="comment">/* find averaged state at this interface */</span>
<a name="l00153"></a>00153       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a7331366d789b2995436accbc35e1cc80">AveragingFunction</a>(uavg,&amp;u[nvars*qm1],&amp;u[nvars*qp1],solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155       <span class="comment">/* Get the left and right eigenvectors */</span>
<a name="l00156"></a>00156       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">GetLeftEigenvectors</a>  (uavg,L,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00157"></a>00157       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a22eef349f191a1aa267e14b08140c823">GetRightEigenvectors</a> (uavg,R,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00158"></a>00158 
<a name="l00159"></a>00159       <span class="comment">/* For each characteristic field */</span>
<a name="l00160"></a>00160       <span class="keywordflow">for</span> (v = 0; v &lt; nvars; v++) {
<a name="l00161"></a>00161 
<a name="l00162"></a>00162         <span class="comment">/* calculate the characteristic flux components along this characteristic */</span>
<a name="l00163"></a>00163         <span class="keywordtype">double</span> fm3, fm2, fm1, fp1, fp2;
<a name="l00164"></a>00164         fm3 = fm2 = fm1 = fp1 = fp2 = 0;
<a name="l00165"></a>00165         <span class="keywordflow">for</span> (k = 0; k &lt; nvars; k++) {
<a name="l00166"></a>00166           fm3 += L[v*nvars+k] * fC[qm3*nvars+k];
<a name="l00167"></a>00167           fm2 += L[v*nvars+k] * fC[qm2*nvars+k];
<a name="l00168"></a>00168           fm1 += L[v*nvars+k] * fC[qm1*nvars+k];
<a name="l00169"></a>00169           fp1 += L[v*nvars+k] * fC[qp1*nvars+k];
<a name="l00170"></a>00170           fp2 += L[v*nvars+k] * fC[qp2*nvars+k];
<a name="l00171"></a>00171         }
<a name="l00172"></a>00172 
<a name="l00173"></a>00173         <span class="comment">/* Candidate stencils and their optimal weights*/</span>
<a name="l00174"></a>00174         <span class="keywordtype">double</span> f1, f2, f3;
<a name="l00175"></a>00175         f1 = (2*one_sixth)*fm3 - (7.0*one_sixth)*fm2 + (11.0*one_sixth)*fm1;
<a name="l00176"></a>00176         f2 = (-one_sixth)*fm2 + (5.0*one_sixth)*fm1 + (2*one_sixth)*fp1;
<a name="l00177"></a>00177         f3 = (2*one_sixth)*fm1 + (5*one_sixth)*fp1 - (one_sixth)*fp2;
<a name="l00178"></a>00178 
<a name="l00179"></a>00179         <span class="comment">/* calculate WENO weights */</span>
<a name="l00180"></a>00180         <span class="keywordtype">double</span> w1,w2,w3;
<a name="l00181"></a>00181         w1 = *(ww1+p*nvars+v);
<a name="l00182"></a>00182         w2 = *(ww2+p*nvars+v);
<a name="l00183"></a>00183         w3 = *(ww3+p*nvars+v);
<a name="l00184"></a>00184 
<a name="l00185"></a>00185         <span class="comment">/* fifth order WENO approximation of the characteristic flux */</span>
<a name="l00186"></a>00186         fchar[v] = w1*f1 + w2*f2 + w3*f3;
<a name="l00187"></a>00187 
<a name="l00188"></a>00188       }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190       <span class="comment">/* calculate the interface u from the characteristic u */</span>
<a name="l00191"></a>00191       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00043.html#a3dc53d4eb4ba0f2cfed00aa69617ee84">MatVecMult</a>(nvars,(fI+nvars*p),R,fchar); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194   }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   <span class="keywordflow">return</span>(0);
<a name="l00197"></a>00197 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae2b27971cc952cf3b4959128bef6174b"></a><!-- doxytag: member="interpolation.h::Interp1PrimFifthOrderCRWENOChar" ref="ae2b27971cc952cf3b4959128bef6174b" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFifthOrderCRWENOChar </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5th order CRWENO reconstruction (characteristic-based) on a uniform grid </p>
<p>Characteristic-based interpolation of the first primitive at the cell interfaces using the fifth-order CRWENO scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the fifth order CRWENO scheme on a uniform grid. The first primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x} \int_{x-\Delta x/2}^{x+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right)d\zeta, \end{equation}" src="form_147.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function computes the 5th order CRWENO numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as the convex combination of three 3rd order methods: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} &amp;\ \omega_1\ \times\ \left[ \frac{2}{3}\hat{\alpha}^k_{j-1/2} + \frac{1}{3}\hat{\alpha}^k_{j+1/2} = \frac{1}{6} \left( f_{j-1} + 5f_j \right) \right]\\ + &amp;\ \omega_2\ \times\ \left[ \frac{1}{3}\hat{\alpha}^k_{j-1/2}+\frac{2}{3}\hat{\alpha}^k_{j+1/2} = \frac{1}{6} \left( 5f_j + f_{j+1} \right) \right] \\ + &amp;\ \omega_3\ \times\ \left[ \frac{2}{3}\hat{\alpha}^k_{j+1/2} + \frac{1}{3}\hat{\alpha}^k_{j+3/2} = \frac{1}{6} \left( f_j + 5f_{j+1} \right) \right] \\ \Rightarrow &amp;\ \left(\frac{2}{3}\omega_1+\frac{1}{3}\omega_2\right)\hat{\alpha}^k_{j-1/2} + \left[\frac{1}{3}\omega_1+\frac{2}{3}(\omega_2+\omega_3)\right]\hat{\alpha}^k_{j+1/2} + \frac{1}{3}\omega_3\hat{\alpha}^k_{j+3/2} = \frac{\omega_1}{6}{\alpha}^k_{j-1} + \frac{5(\omega_1+\omega_2)+\omega_3}{6}{\alpha}^k_j + \frac{\omega_2+5\omega_3}{6}{\alpha}^k_{j+1}, \end{align}" src="form_163.png"/>
</p>
<p> where </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \alpha^k = {\bf l}_k \cdot {\bf f},\ k=1,\cdots,n \end{equation}" src="form_155.png"/>
</p>
<p> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th characteristic quantity, and <img class="formulaInl" alt="${\bf l}_k$" src="form_157.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th left eigenvector, <img class="formulaInl" alt="${\bf r}_k$" src="form_158.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th right eigenvector, and <img class="formulaInl" alt="$n$" src="form_141.png"/> is <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>. The nonlinear weights <img class="formulaInl" alt="$\omega_k; k=1,2,3$" src="form_161.png"/> are the WENO weights computed in <a class="el" href="a00148.html#a6f1f5da1b6e5134bb1deccfad05a506d">WENOFifthOrderCalculateWeightsChar()</a>. The resulting block tridiagonal system is solved using <a class="el" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU()</a> (see also <a class="el" href="a00029.html">TridiagLU</a>, <a class="el" href="a00062.html" title="Header file for TridiagLU.">tridiagLU.h</a>). The final interpolated function is computed from the interpolated characteristic quantities as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = \sum_{k=1}^n \alpha^k_{j+1/2} {\bf r}_k \end{equation}" src="form_159.png"/>
</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + The method described above corresponds to a left-biased interpolation. The corresponding right-biased interpolation can be obtained by reflecting the equations about interface j+1/2. + The left and right eigenvectors are computed at an averaged quantity at j+1/2. Thus, this function requires functions to compute the average state, and the left and right eigenvectors. These are provided by the physical model through</p>
<ul>
<li><a class="el" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">HyPar::GetLeftEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a22eef349f191a1aa267e14b08140c823">HyPar::GetRightEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a7331366d789b2995436accbc35e1cc80">HyPar::AveragingFunction()</a></li>
</ul>
<p>If these functions are not provided by the physical model, then a characteristic-based interpolation cannot be used. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p><b>Reference:</b> + Ghosh, D., Baeder, J. D., Compact Reconstruction Schemes with Weighted ENO Limiting for Hyperbolic Conservation Laws, SIAM Journal on Scientific Computing, 34 (3), 2012, A1678–A1706, <a href="http://dx.doi.org/10.1137/110857659">http://dx.doi.org/10.1137/110857659</a> + Ghosh, D., Constantinescu, E. M., Brown, J., Efficient Implementation of Nonlinear Compact Schemes on Massively Parallel Platforms, SIAM Journal on Scientific Computing, 37 (3), 2015, C354–C383, <a href="http://dx.doi.org/10.1137/140989261">http://dx.doi.org/10.1137/140989261</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00132_source.html#l00092">92</a> of file <a class="el" href="a00132_source.html">Interp1PrimFifthOrderCRWENOChar.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00094"></a>00094                                                                                                        {\bf f}\left({\bf u}\right)\f$ */
<a name="l00095"></a>00095                                     <span class="keywordtype">double</span> *u,   
<a name="l00096"></a>00096                                     <span class="keywordtype">double</span> *x,   
<a name="l00097"></a>00097                                     <span class="keywordtype">int</span>    upw,  
<a name="l00098"></a>00098                                     <span class="keywordtype">int</span>    dir,  
<a name="l00099"></a>00099                                     <span class="keywordtype">void</span>   *s,   
<a name="l00100"></a>00100                                     <span class="keywordtype">void</span>   *m,   
<a name="l00101"></a>00101                                     <span class="keywordtype">int</span>    uflag 
<a name="l00102"></a>00102                                    )
<a name="l00103"></a>00103 {
<a name="l00104"></a>00104   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)          s;
<a name="l00105"></a>00105   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>    *mpi    = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*)   m;
<a name="l00106"></a>00106   <a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>   *compact= (<a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>*)  solver-&gt;<a class="code" href="a00015.html#a56318721d534e74a96b440f8542a0232">compact</a>;
<a name="l00107"></a>00107   <a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>  *weno   = (<a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>*) solver-&gt;<a class="code" href="a00015.html#a29c46b81ad574e4dfbad5a7211487dcb">interp</a>;
<a name="l00108"></a>00108   <a class="code" href="a00029.html">TridiagLU</a>       *lu     = (<a class="code" href="a00029.html">TridiagLU</a>*)      solver-&gt;<a class="code" href="a00015.html#a1dbfa1e479a373073b6ebf72401a7f0f">lusolver</a>;
<a name="l00109"></a>00109   <span class="keywordtype">int</span>             sys,Nsys,d,v,k;
<a name="l00110"></a>00110   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00113"></a>00113   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00114"></a>00114   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00115"></a>00115   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117   <span class="comment">/* define some constants */</span>
<a name="l00118"></a>00118   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_third          = 1.0/3.0;
<a name="l00119"></a>00119   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_sixth          = 1.0/6.0;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <span class="keywordtype">double</span> *ww1, *ww2, *ww3;
<a name="l00122"></a>00122   ww1 = weno-&gt;w1 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00123"></a>00123   ww2 = weno-&gt;w2 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00124"></a>00124   ww3 = weno-&gt;w3 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00127"></a>00127 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00128"></a>00128   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00129"></a>00129   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00130"></a>00130   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132   <span class="comment">/* calculate total number of block tridiagonal systems to solve */</span>
<a name="l00133"></a>00133   <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,Nsys);
<a name="l00134"></a>00134 
<a name="l00135"></a>00135   <span class="comment">/* allocate arrays for the averaged state, eigenvectors and characteristic interpolated f */</span>
<a name="l00136"></a>00136   <span class="keywordtype">double</span> R[nvars*nvars], L[nvars*nvars], uavg[nvars];
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   <span class="comment">/* Allocate arrays for tridiagonal system */</span>
<a name="l00139"></a>00139   <span class="keywordtype">double</span> *A = compact-&gt;<a class="code" href="a00003.html#ac900805a486cbb8489e3c176ed6e0d8e">A</a>;
<a name="l00140"></a>00140   <span class="keywordtype">double</span> *B = compact-&gt;<a class="code" href="a00003.html#ad36954709307649365515214a02ab06d">B</a>;
<a name="l00141"></a>00141   <span class="keywordtype">double</span> *C = compact-&gt;<a class="code" href="a00003.html#a0a26ce8d1878aac6ddc87e3f6290e039">C</a>;
<a name="l00142"></a>00142   <span class="keywordtype">double</span> *F = compact-&gt;<a class="code" href="a00003.html#ac06de847603f5cfaec085f6fe500f3c8">R</a>;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,v,k,R,L,uavg,index_outer,indexC,indexI)</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys&lt;Nsys; sys++) {
<a name="l00146"></a>00146     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00147"></a>00147     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00148"></a>00148     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00149"></a>00149     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00150"></a>00150       <span class="keywordtype">int</span> qm1,qm2,qm3,qp1,qp2;
<a name="l00151"></a>00151       <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00152"></a>00152         indexC[dir] = indexI[dir]-3; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00153"></a>00153         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00154"></a>00154         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00155"></a>00155         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00156"></a>00156         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00157"></a>00157       } <span class="keywordflow">else</span> {
<a name="l00158"></a>00158         indexC[dir] = indexI[dir]+2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00159"></a>00159         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00160"></a>00160         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00161"></a>00161         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00162"></a>00162         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00163"></a>00163       }
<a name="l00164"></a>00164 
<a name="l00165"></a>00165       <span class="keywordtype">int</span> p; <span class="comment">/* 1D index of the interface */</span>
<a name="l00166"></a>00166       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168       <span class="comment">/* find averaged state at this interface */</span>
<a name="l00169"></a>00169       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a7331366d789b2995436accbc35e1cc80">AveragingFunction</a>(uavg,&amp;u[nvars*qm1],&amp;u[nvars*qp1],solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171       <span class="comment">/* Get the left and right eigenvectors */</span>
<a name="l00172"></a>00172       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">GetLeftEigenvectors</a>  (uavg,L,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00173"></a>00173       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a22eef349f191a1aa267e14b08140c823">GetRightEigenvectors</a> (uavg,R,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175       <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++)  {
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         <span class="comment">/* calculate the characteristic flux components along this characteristic */</span>
<a name="l00178"></a>00178         <span class="keywordtype">double</span> fm3, fm2, fm1, fp1, fp2;
<a name="l00179"></a>00179         fm3 = fm2 = fm1 = fp1 = fp2 = 0;
<a name="l00180"></a>00180         <span class="keywordflow">for</span> (k = 0; k &lt; nvars; k++) {
<a name="l00181"></a>00181           fm3 += L[v*nvars+k] * fC[qm3*nvars+k];
<a name="l00182"></a>00182           fm2 += L[v*nvars+k] * fC[qm2*nvars+k];
<a name="l00183"></a>00183           fm1 += L[v*nvars+k] * fC[qm1*nvars+k];
<a name="l00184"></a>00184           fp1 += L[v*nvars+k] * fC[qp1*nvars+k];
<a name="l00185"></a>00185           fp2 += L[v*nvars+k] * fC[qp2*nvars+k];
<a name="l00186"></a>00186         }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188         <span class="comment">/* Candidate stencils and their optimal weights*/</span>
<a name="l00189"></a>00189         <span class="keywordtype">double</span> f1, f2, f3;
<a name="l00190"></a>00190         <span class="keywordflow">if</span> (   ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == 0                ) &amp;&amp; (indexI[dir] == 0       ))
<a name="l00191"></a>00191             || ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) &amp;&amp; (indexI[dir] == dim[dir])) ) {
<a name="l00192"></a>00192           <span class="comment">/* Use WENO5 at the physical boundaries */</span>
<a name="l00193"></a>00193           f1 = (2*one_sixth)*fm3 - (7.0*one_sixth)*fm2 + (11.0*one_sixth)*fm1;
<a name="l00194"></a>00194           f2 = (-one_sixth)*fm2 + (5.0*one_sixth)*fm1 + (2*one_sixth)*fp1;
<a name="l00195"></a>00195           f3 = (2*one_sixth)*fm1 + (5*one_sixth)*fp1 - (one_sixth)*fp2;
<a name="l00196"></a>00196         } <span class="keywordflow">else</span> {
<a name="l00197"></a>00197           <span class="comment">/* CRWENO5 at the interior points */</span>
<a name="l00198"></a>00198           f1 = (one_sixth) * (fm2 + 5*fm1);
<a name="l00199"></a>00199           f2 = (one_sixth) * (5*fm1 + fp1);
<a name="l00200"></a>00200           f3 = (one_sixth) * (fm1 + 5*fp1);
<a name="l00201"></a>00201         }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         <span class="comment">/* calculate WENO weights */</span>
<a name="l00204"></a>00204         <span class="keywordtype">double</span> w1,w2,w3;
<a name="l00205"></a>00205         w1 = *(ww1+p*nvars+v);
<a name="l00206"></a>00206         w2 = *(ww2+p*nvars+v);
<a name="l00207"></a>00207         w3 = *(ww3+p*nvars+v);
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         <span class="keywordflow">if</span> (   ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == 0                ) &amp;&amp; (indexI[dir] == 0       ))
<a name="l00210"></a>00210             || ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) &amp;&amp; (indexI[dir] == dim[dir])) ) {
<a name="l00211"></a>00211           <span class="keywordflow">for</span> (k=0; k&lt;nvars; k++) {
<a name="l00212"></a>00212             A[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = 0.0;
<a name="l00213"></a>00213             C[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = 0.0;
<a name="l00214"></a>00214             B[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = L[v*nvars+k];
<a name="l00215"></a>00215           }
<a name="l00216"></a>00216         } <span class="keywordflow">else</span> {
<a name="l00217"></a>00217           <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00218"></a>00218             <span class="keywordflow">for</span> (k=0; k&lt;nvars; k++) {
<a name="l00219"></a>00219               A[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = ((2*one_third)*w1 + (one_third)*w2)      * L[v*nvars+k];
<a name="l00220"></a>00220               B[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = ((one_third)*w1 + (2*one_third)*(w2+w3)) * L[v*nvars+k];
<a name="l00221"></a>00221               C[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = ((one_third)*w3)                         * L[v*nvars+k];
<a name="l00222"></a>00222             }
<a name="l00223"></a>00223           } <span class="keywordflow">else</span> {
<a name="l00224"></a>00224             <span class="keywordflow">for</span> (k=0; k&lt;nvars; k++) {
<a name="l00225"></a>00225               C[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = ((2*one_third)*w1 + (one_third)*w2)      * L[v*nvars+k];
<a name="l00226"></a>00226               B[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = ((one_third)*w1 + (2*one_third)*(w2+w3)) * L[v*nvars+k];
<a name="l00227"></a>00227               A[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = ((one_third)*w3)                         * L[v*nvars+k];
<a name="l00228"></a>00228             }
<a name="l00229"></a>00229           }
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231         F[(Nsys*indexI[dir]+sys)*nvars+v] = w1*f1 + w2*f2 + w3*f3;
<a name="l00232"></a>00232       }
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234   }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="preprocessor">#ifdef serial</span>
<a name="l00237"></a>00237 <span class="preprocessor"></span>
<a name="l00238"></a>00238   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00239"></a>00239   <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU</a>(A,B,C,F,dim[dir]+1,Nsys,nvars,lu,NULL); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="preprocessor">#else</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span>
<a name="l00243"></a>00243   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00244"></a>00244   <span class="comment">/* all processes except the last will solve without the last interface to avoid overlap */</span>
<a name="l00245"></a>00245   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1)  { 
<a name="l00246"></a>00246     <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU</a>(A,B,C,F,dim[dir]  ,Nsys,nvars,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr); 
<a name="l00247"></a>00247   } <span class="keywordflow">else</span> { 
<a name="l00248"></a>00248     <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU</a>(A,B,C,F,dim[dir]+1,Nsys,nvars,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00249"></a>00249   }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   <span class="comment">/* Now get the solution to the last interface from the next proc */</span>
<a name="l00252"></a>00252   <span class="keywordtype">double</span> *sendbuf = compact-&gt;<a class="code" href="a00003.html#aba3b15034da676474db917f9f5533085">sendbuf</a>;
<a name="l00253"></a>00253   <span class="keywordtype">double</span> *recvbuf = compact-&gt;<a class="code" href="a00003.html#afc23e46e08649e112e8d64d780cea5cb">recvbuf</a>;
<a name="l00254"></a>00254   MPI_Request req[2] = {MPI_REQUEST_NULL,MPI_REQUEST_NULL};
<a name="l00255"></a>00255   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]) <span class="keywordflow">for</span> (d=0; d&lt;Nsys*nvars; d++) sendbuf[d] = F[d];
<a name="l00256"></a>00256   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) MPI_Irecv(recvbuf,Nsys*nvars,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]+1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[0]);
<a name="l00257"></a>00257   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir])                      MPI_Isend(sendbuf,Nsys*nvars,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]-1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[1]);
<a name="l00258"></a>00258   MPI_Waitall(2,&amp;req[0],MPI_STATUS_IGNORE);
<a name="l00259"></a>00259   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) <span class="keywordflow">for</span> (d=0; d&lt;Nsys*nvars; d++) F[d+Nsys*nvars*dim[dir]] = recvbuf[d];
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="preprocessor">#endif</span>
<a name="l00262"></a>00262 <span class="preprocessor"></span>
<a name="l00263"></a>00263   <span class="comment">/* save the solution to fI */</span>
<a name="l00264"></a>00264 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,v,k,R,L,uavg,index_outer,indexC,indexI)</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys&lt;Nsys; sys++) {
<a name="l00266"></a>00266     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00267"></a>00267     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00268"></a>00268     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00269"></a>00269       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00270"></a>00270       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((F+sys*nvars+Nsys*nvars*indexI[dir]),(fI+nvars*p),nvars);
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272   }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274   <span class="keywordflow">return</span>(0);
<a name="l00275"></a>00275 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a91fbe118c8c01fe1d5efa3cea4930589"></a><!-- doxytag: member="interpolation.h::Interp1PrimFifthOrderHCWENOChar" ref="a91fbe118c8c01fe1d5efa3cea4930589" args="(double *, double *, double *, double *, int, int, void *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp1PrimFifthOrderHCWENOChar </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>upw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>uflag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>5th order hybrid compact-WENO reconstruction (characteristic-based) on a uniform grid </p>
<p>Characteristic-based interpolation of the first primitive at the cell interfaces using the fifth-order hybrid-compact WENO scheme</p>
<p>Computes the interpolated values of the first primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the fifth hybrid compact-WENO order scheme on a uniform grid. The reconstruction is carried out in terms of </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \alpha^k = {\bf l}_k \cdot {\bf f},\ k=1,\cdots,n, \end{equation}" src="form_164.png"/>
</p>
<p> which is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th characteristic quantity, and <img class="formulaInl" alt="${\bf l}_k$" src="form_157.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th left eigenvector, <img class="formulaInl" alt="${\bf r}_k$" src="form_158.png"/> is the <img class="formulaInl" alt="$k$" src="form_156.png"/>-th right eigenvector, and <img class="formulaInl" alt="$n$" src="form_141.png"/> is <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>. The block tridiagonal system is solved using <a class="el" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU()</a> (see also <a class="el" href="a00029.html">TridiagLU</a>, <a class="el" href="a00062.html" title="Header file for TridiagLU.">tridiagLU.h</a>). The final interpolated function is computed from the interpolated characteristic quantities as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = \sum_{k=1}^n \alpha^k_{j+1/2} {\bf r}_k \end{equation}" src="form_159.png"/>
</p>
<p> See the references below for details of the hybrid compact-WENO scheme.</p>
<p><b>Implementation</b> <b>Notes:</b> + This method assumes a uniform grid in the spatial dimension corresponding to the interpolation. + The method described above corresponds to a left-biased interpolation. The corresponding right-biased interpolation can be obtained by reflecting the equations about interface j+1/2. + The WENO weights are computed in <a class="el" href="a00148.html#a6f1f5da1b6e5134bb1deccfad05a506d">WENOFifthOrderCalculateWeightsChar()</a>. + The left and right eigenvectors are computed at an averaged quantity at j+1/2. Thus, this function requires functions to compute the average state, and the left and right eigenvectors. These are provided by the physical model through</p>
<ul>
<li><a class="el" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">HyPar::GetLeftEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a22eef349f191a1aa267e14b08140c823">HyPar::GetRightEigenvectors()</a></li>
<li><a class="el" href="a00015.html#a7331366d789b2995436accbc35e1cc80">HyPar::AveragingFunction()</a></li>
</ul>
<p>If these functions are not provided by the physical model, then a characteristic-based interpolation cannot be used. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. u | double* | The solution array <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (with ghost points). If the interpolation is characteristic based, this is needed to compute the eigendecomposition. For a multidimensional problem, the layout is as follows: u is a contiguous 1D array of size (nvars*dim[0]*dim[1]*...*dim[D-1]) corresponding to the multi-dimensional solution, with the following ordering - nvars, dim[0], dim[1], ..., dim[D-1], where nvars is the number of solution components (<a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>), dim is the local size (<a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>), D is the number of spatial dimensions. x | double* | The grid array (with ghost points). This is used only by non-uniform-grid interpolation methods. For multidimensional problems, the layout is as follows: x is a contiguous 1D array of size (dim[0]+dim[1]+...+dim[D-1]), with the spatial coordinates along dim[0] stored from 0,...,dim[0]-1, the spatial coordinates along dim[1] stored along dim[0],...,dim[0]+dim[1]-1, and so forth. upw | int | Upwinding direction: if positive, a left-biased interpolant will be computed; if negative, a right-biased interpolant will be computed. If the interpolation method is central, then this has no effect. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. uflag | int | A flag indicating if the function being interpolated <img class="formulaInl" alt="${\bf f}$" src="form_151.png"/> is the solution itself <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> (if 1, <img class="formulaInl" alt="${\bf f}\left({\bf u}\right) \equiv {\bf u}$" src="form_152.png"/>).</p>
<p><b>Reference:</b> + Pirozzoli, S., Conservative Hybrid Compact-WENO Schemes for Shock-Turbulence Interaction, J. Comput. Phys., 178 (1), 2002, pp. 81-117, <a href="http://dx.doi.org/10.1006/jcph.2002.7021">http://dx.doi.org/10.1006/jcph.2002.7021</a> + Ren, Y.-X., Liu, M., Zhang, H., A characteristic-wise hybrid compact-WENO scheme for solving hyperbolic conservation laws, J. Comput. Phys., 192 (2), 2003, pp. 365-386, </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Array of cell-centered values of the solution <img class="formulaInl" alt="${\bf u}$" src="form_150.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Grid coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upw</em>&nbsp;</td><td>Upwind direction (left or right biased) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uflag</em>&nbsp;</td><td>Flag to indicate if <img class="formulaInl" alt="$f(u) \equiv u$" src="form_153.png"/>, <a class="el" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">i.e</a>, if the solution is being reconstructed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00134_source.html#l00078">78</a> of file <a class="el" href="a00134_source.html">Interp1PrimFifthOrderHCWENOChar.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00080"></a>00080                                                                                                        {\bf f}\left({\bf u}\right)\f$ */
<a name="l00081"></a>00081                                     <span class="keywordtype">double</span> *u,   
<a name="l00082"></a>00082                                     <span class="keywordtype">double</span> *x,   
<a name="l00083"></a>00083                                     <span class="keywordtype">int</span>    upw,  
<a name="l00084"></a>00084                                     <span class="keywordtype">int</span>    dir,  
<a name="l00085"></a>00085                                     <span class="keywordtype">void</span>   *s,   
<a name="l00086"></a>00086                                     <span class="keywordtype">void</span>   *m,   
<a name="l00087"></a>00087                                     <span class="keywordtype">int</span>    uflag 
<a name="l00088"></a>00088                                    )
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)          s;
<a name="l00091"></a>00091   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>    *mpi    = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*)   m;
<a name="l00092"></a>00092   <a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>   *compact= (<a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>*)  solver-&gt;<a class="code" href="a00015.html#a56318721d534e74a96b440f8542a0232">compact</a>;
<a name="l00093"></a>00093   <a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>  *weno   = (<a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>*) solver-&gt;<a class="code" href="a00015.html#a29c46b81ad574e4dfbad5a7211487dcb">interp</a>;
<a name="l00094"></a>00094   <a class="code" href="a00029.html">TridiagLU</a>       *lu     = (<a class="code" href="a00029.html">TridiagLU</a>*)      solver-&gt;<a class="code" href="a00015.html#a1dbfa1e479a373073b6ebf72401a7f0f">lusolver</a>;
<a name="l00095"></a>00095   <span class="keywordtype">int</span>             sys,Nsys,d,v,k;
<a name="l00096"></a>00096   <a class="code" href="a00036.html#a68f50121fb9a7daeaf60e50cdef82ef3">_DECLARE_IERR_</a>;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00099"></a>00099   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00100"></a>00100   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00101"></a>00101   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103   <span class="comment">/* define some constants */</span>
<a name="l00104"></a>00104   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_half           = 1.0/2.0;
<a name="l00105"></a>00105   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_third          = 1.0/3.0;
<a name="l00106"></a>00106   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> one_sixth          = 1.0/6.0;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="keywordtype">double</span> *ww1, *ww2, *ww3;
<a name="l00109"></a>00109   ww1 = weno-&gt;w1 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00110"></a>00110   ww2 = weno-&gt;w2 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00111"></a>00111   ww3 = weno-&gt;w3 + (upw &lt; 0 ? 2*weno-&gt;size : 0) + (uflag ? weno-&gt;size : 0) + weno-&gt;offset[dir];
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00114"></a>00114 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00115"></a>00115   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00116"></a>00116   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00117"></a>00117   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119   <span class="comment">/* calculate total number of block tridiagonal systems to solve */</span>
<a name="l00120"></a>00120   <a class="code" href="a00034.html#abc65e9c6a51b875f46fdb054a0ecf604">_ArrayProduct1D_</a>(bounds_outer,ndims,Nsys);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122   <span class="comment">/* allocate arrays for the averaged state, eigenvectors and characteristic interpolated f */</span>
<a name="l00123"></a>00123   <span class="keywordtype">double</span> R[nvars*nvars], L[nvars*nvars], uavg[nvars];
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <span class="comment">/* Allocate arrays for tridiagonal system */</span>
<a name="l00126"></a>00126   <span class="keywordtype">double</span> *A = compact-&gt;<a class="code" href="a00003.html#ac900805a486cbb8489e3c176ed6e0d8e">A</a>;
<a name="l00127"></a>00127   <span class="keywordtype">double</span> *B = compact-&gt;<a class="code" href="a00003.html#ad36954709307649365515214a02ab06d">B</a>;
<a name="l00128"></a>00128   <span class="keywordtype">double</span> *C = compact-&gt;<a class="code" href="a00003.html#a0a26ce8d1878aac6ddc87e3f6290e039">C</a>;
<a name="l00129"></a>00129   <span class="keywordtype">double</span> *F = compact-&gt;<a class="code" href="a00003.html#ac06de847603f5cfaec085f6fe500f3c8">R</a>;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,v,k,R,L,uavg,index_outer,indexC,indexI)</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys&lt;Nsys; sys++) {
<a name="l00133"></a>00133     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00134"></a>00134     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00135"></a>00135     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00136"></a>00136     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00137"></a>00137       <span class="keywordtype">int</span> qm1,qm2,qm3,qp1,qp2;
<a name="l00138"></a>00138       <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00139"></a>00139         indexC[dir] = indexI[dir]-3; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00140"></a>00140         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00141"></a>00141         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00142"></a>00142         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00143"></a>00143         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00144"></a>00144       } <span class="keywordflow">else</span> {
<a name="l00145"></a>00145         indexC[dir] = indexI[dir]+2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm3);
<a name="l00146"></a>00146         indexC[dir] = indexI[dir]+1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm2);
<a name="l00147"></a>00147         indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qm1);
<a name="l00148"></a>00148         indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp1);
<a name="l00149"></a>00149         indexC[dir] = indexI[dir]-2; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qp2);
<a name="l00150"></a>00150       }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152       <span class="keywordtype">int</span> p; <span class="comment">/* 1D index of the interface */</span>
<a name="l00153"></a>00153       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155       <span class="comment">/* find averaged state at this interface */</span>
<a name="l00156"></a>00156       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a7331366d789b2995436accbc35e1cc80">AveragingFunction</a>(uavg,&amp;u[nvars*qm1],&amp;u[nvars*qp1],solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00157"></a>00157 
<a name="l00158"></a>00158       <span class="comment">/* Get the left and right eigenvectors */</span>
<a name="l00159"></a>00159       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a8c603c73be1f08e408a1de94a088da7b">GetLeftEigenvectors</a>  (uavg,L,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00160"></a>00160       <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> solver-&gt;<a class="code" href="a00015.html#a22eef349f191a1aa267e14b08140c823">GetRightEigenvectors</a> (uavg,R,solver-&gt;<a class="code" href="a00015.html#a48e81a1806b5774943fd9a26e9a190f2">physics</a>,dir); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00161"></a>00161 
<a name="l00162"></a>00162       <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++)  {
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         <span class="comment">/* calculate the characteristic flux components along this characteristic */</span>
<a name="l00165"></a>00165         <span class="keywordtype">double</span> fm3, fm2, fm1, fp1, fp2;
<a name="l00166"></a>00166         fm3 = fm2 = fm1 = fp1 = fp2 = 0;
<a name="l00167"></a>00167         <span class="keywordflow">for</span> (k = 0; k &lt; nvars; k++) {
<a name="l00168"></a>00168           fm3 += L[v*nvars+k] * fC[qm3*nvars+k];
<a name="l00169"></a>00169           fm2 += L[v*nvars+k] * fC[qm2*nvars+k];
<a name="l00170"></a>00170           fm1 += L[v*nvars+k] * fC[qm1*nvars+k];
<a name="l00171"></a>00171           fp1 += L[v*nvars+k] * fC[qp1*nvars+k];
<a name="l00172"></a>00172           fp2 += L[v*nvars+k] * fC[qp2*nvars+k];
<a name="l00173"></a>00173         }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175         <span class="comment">/* Candidate stencils and their optimal weights*/</span>
<a name="l00176"></a>00176         <span class="keywordtype">double</span> f1, f2, f3;
<a name="l00177"></a>00177         <span class="keywordflow">if</span> (   ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == 0                ) &amp;&amp; (indexI[dir] == 0       ))
<a name="l00178"></a>00178             || ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) &amp;&amp; (indexI[dir] == dim[dir])) ) {
<a name="l00179"></a>00179           <span class="comment">/* Use WENO5 at the physical boundaries */</span>
<a name="l00180"></a>00180           f1 = (2*one_sixth)*fm3 - (7.0*one_sixth)*fm2 + (11.0*one_sixth)*fm1;
<a name="l00181"></a>00181           f2 = (-one_sixth)*fm2 + (5.0*one_sixth)*fm1 + (2*one_sixth)*fp1;
<a name="l00182"></a>00182           f3 = (2*one_sixth)*fm1 + (5*one_sixth)*fp1 - (one_sixth)*fp2;
<a name="l00183"></a>00183         } <span class="keywordflow">else</span> {
<a name="l00184"></a>00184           <span class="comment">/* HCWENO5 at the interior points */</span>
<a name="l00185"></a>00185           f1 = (one_sixth) * (fm2 + 5*fm1);
<a name="l00186"></a>00186           f2 = (one_sixth) * (5*fm1 + fp1);
<a name="l00187"></a>00187           f3 = (one_sixth) * (fm1 + 5*fp1);
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190         <span class="comment">/* calculate WENO weights */</span>
<a name="l00191"></a>00191         <span class="keywordtype">double</span> w1,w2,w3;
<a name="l00192"></a>00192         w1 = *(ww1+p*nvars+v);
<a name="l00193"></a>00193         w2 = *(ww2+p*nvars+v);
<a name="l00194"></a>00194         w3 = *(ww3+p*nvars+v);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         <span class="comment">/* calculate the hybridization parameter */</span>
<a name="l00197"></a>00197         <span class="keywordtype">double</span> sigma;
<a name="l00198"></a>00198         <span class="keywordflow">if</span> (   ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == 0                ) &amp;&amp; (indexI[dir] == 0       ))
<a name="l00199"></a>00199             || ((mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] == mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) &amp;&amp; (indexI[dir] == dim[dir])) ) {
<a name="l00200"></a>00200           <span class="comment">/* Standard WENO at physical boundaries */</span>
<a name="l00201"></a>00201           sigma = 0.0;
<a name="l00202"></a>00202         } <span class="keywordflow">else</span> {
<a name="l00203"></a>00203           <span class="keywordtype">double</span> cuckoo, df_jm12, df_jp12, df_jp32, r_j, r_jp1, r_int;
<a name="l00204"></a>00204           cuckoo = (0.9*weno-&gt;rc / (1.0-0.9*weno-&gt;rc)) * weno-&gt;xi * weno-&gt;xi;
<a name="l00205"></a>00205           df_jm12 = fm1 - fm2;
<a name="l00206"></a>00206           df_jp12 = fp1 - fm1;
<a name="l00207"></a>00207           df_jp32 = fp2 - fp1;
<a name="l00208"></a>00208           r_j   = (<a class="code" href="a00043.html#adf1be5ccbb7a2522b4f3a64043c72880">absolute</a>(2*df_jp12*df_jm12)+cuckoo)/(df_jp12*df_jp12+df_jm12*df_jm12+cuckoo);
<a name="l00209"></a>00209           r_jp1 = (<a class="code" href="a00043.html#adf1be5ccbb7a2522b4f3a64043c72880">absolute</a>(2*df_jp32*df_jp12)+cuckoo)/(df_jp32*df_jp32+df_jp12*df_jp12+cuckoo);
<a name="l00210"></a>00210           r_int = <a class="code" href="a00043.html#ac6afabdc09a49a433ee19d8a9486056d">min</a>(r_j, r_jp1);
<a name="l00211"></a>00211           sigma = <a class="code" href="a00043.html#ac6afabdc09a49a433ee19d8a9486056d">min</a>((r_int/weno-&gt;rc), 1.0); 
<a name="l00212"></a>00212         }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (upw &gt; 0) {
<a name="l00215"></a>00215           <span class="keywordflow">for</span> (k=0; k&lt;nvars; k++) {
<a name="l00216"></a>00216             A[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = (one_half*sigma)  * L[v*nvars+k];
<a name="l00217"></a>00217             B[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = (1.0)             * L[v*nvars+k];
<a name="l00218"></a>00218             C[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = (one_sixth*sigma) * L[v*nvars+k];
<a name="l00219"></a>00219           }
<a name="l00220"></a>00220         } <span class="keywordflow">else</span> {
<a name="l00221"></a>00221           <span class="keywordflow">for</span> (k=0; k&lt;nvars; k++) {
<a name="l00222"></a>00222             C[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = (one_half*sigma)  * L[v*nvars+k];
<a name="l00223"></a>00223             B[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = (1.0)             * L[v*nvars+k];
<a name="l00224"></a>00224             A[(Nsys*indexI[dir]+sys)*nvars*nvars+v*nvars+k] = (one_sixth*sigma) * L[v*nvars+k];
<a name="l00225"></a>00225           }
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227         <span class="keywordtype">double</span> fWENO, fCompact;
<a name="l00228"></a>00228         fWENO    = w1*f1 + w2*f2 + w3*f3;
<a name="l00229"></a>00229         fCompact = one_sixth * (one_third*fm2 + 19.0*one_third*fm1 + 10.0*one_third*fp1);
<a name="l00230"></a>00230         F[(Nsys*indexI[dir]+sys)*nvars+v] = sigma*fCompact + (1.0-sigma)*fWENO;
<a name="l00231"></a>00231       }
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233   }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 <span class="preprocessor">#ifdef serial</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span>
<a name="l00237"></a>00237   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00238"></a>00238   <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU</a>(A,B,C,F,dim[dir]+1,Nsys,nvars,lu,NULL); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 <span class="preprocessor">#else</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span>
<a name="l00242"></a>00242   <span class="comment">/* Solve the tridiagonal system */</span>
<a name="l00243"></a>00243   <span class="comment">/* all processes except the last will solve without the last interface to avoid overlap */</span>
<a name="l00244"></a>00244   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1)  { 
<a name="l00245"></a>00245     <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU</a>(A,B,C,F,dim[dir]  ,Nsys,nvars,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr); 
<a name="l00246"></a>00246   } <span class="keywordflow">else</span> { 
<a name="l00247"></a>00247     <a class="code" href="a00036.html#ad6ab74942c9de13cf0b4c12eb0d91780">IERR</a> <a class="code" href="a00062.html#ad2c404dd44e760ee729740176b186bd0">blocktridiagLU</a>(A,B,C,F,dim[dir]+1,Nsys,nvars,lu,&amp;mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir]); <a class="code" href="a00036.html#add9cf96ae374934d245a1dc1ab697a42">CHECKERR</a>(ierr);
<a name="l00248"></a>00248   }
<a name="l00249"></a>00249 
<a name="l00250"></a>00250   <span class="comment">/* Now get the solution to the last interface from the next proc */</span>
<a name="l00251"></a>00251   <span class="keywordtype">double</span> *sendbuf = compact-&gt;<a class="code" href="a00003.html#aba3b15034da676474db917f9f5533085">sendbuf</a>;
<a name="l00252"></a>00252   <span class="keywordtype">double</span> *recvbuf = compact-&gt;<a class="code" href="a00003.html#afc23e46e08649e112e8d64d780cea5cb">recvbuf</a>;
<a name="l00253"></a>00253   MPI_Request req[2] = {MPI_REQUEST_NULL,MPI_REQUEST_NULL};
<a name="l00254"></a>00254   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]) <span class="keywordflow">for</span> (d=0; d&lt;Nsys*nvars; d++) sendbuf[d] = F[d];
<a name="l00255"></a>00255   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) MPI_Irecv(recvbuf,Nsys*nvars,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]+1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[0]);
<a name="l00256"></a>00256   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir])                      MPI_Isend(sendbuf,Nsys*nvars,MPI_DOUBLE,mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir]-1,214,mpi-&gt;<a class="code" href="a00019.html#a45a2dae130e8ef21ae3aa9c7a9e7a138">comm</a>[dir],&amp;req[1]);
<a name="l00257"></a>00257   MPI_Waitall(2,&amp;req[0],MPI_STATUS_IGNORE);
<a name="l00258"></a>00258   <span class="keywordflow">if</span> (mpi-&gt;<a class="code" href="a00019.html#aa3c28612a64b8a97bde66b720e15c700">ip</a>[dir] != mpi-&gt;<a class="code" href="a00019.html#a0be0f30a83bc3f3d9f6ee3a36bbf2716">iproc</a>[dir]-1) <span class="keywordflow">for</span> (d=0; d&lt;Nsys*nvars; d++) F[d+Nsys*nvars*dim[dir]] = recvbuf[d];
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 <span class="preprocessor">#endif</span>
<a name="l00261"></a>00261 <span class="preprocessor"></span>
<a name="l00262"></a>00262   <span class="comment">/* save the solution to fI */</span>
<a name="l00263"></a>00263 <span class="preprocessor">#pragma omp parallel for schedule(auto) default(shared) private(sys,d,v,k,R,L,uavg,index_outer,indexC,indexI)</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (sys=0; sys&lt;Nsys; sys++) {
<a name="l00265"></a>00265     <a class="code" href="a00034.html#a03f49e4d44ae8aca85cb04cfe91e4ce4">_ArrayIndexnD_</a>(ndims,sys,bounds_outer,index_outer,0);
<a name="l00266"></a>00266     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00267"></a>00267     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00268"></a>00268       <span class="keywordtype">int</span> p; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00269"></a>00269       <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>((F+sys*nvars+Nsys*nvars*indexI[dir]),(fI+nvars*p),nvars);
<a name="l00270"></a>00270     }
<a name="l00271"></a>00271   }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273   <span class="keywordflow">return</span>(0);
<a name="l00274"></a>00274 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae8bfe856abd743f5af925dc03e708ee3"></a><!-- doxytag: member="interpolation.h::Interp2PrimSecondOrder" ref="ae8bfe856abd743f5af925dc03e708ee3" args="(double *, double *, int, void *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Interp2PrimSecondOrder </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>fC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>2nd order component-wise interpolation of the 2nd primitive on a uniform grid </p>
<p>Interpolation of the second primitive at the cell interfaces using the second-order central scheme</p>
<p>Computes the interpolated values of the second primitive of a function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> at the interfaces from the cell-centered values of the function using the second order central method on a uniform grid. The second primitive is defined as a function <img class="formulaInl" alt="${\bf h}\left({\bf u}\right)$" src="form_146.png"/> that satisfies: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} {\bf f}\left({\bf u}\left(x\right)\right) = \frac{1}{\Delta x^2} \int_{x-\Delta x/2}^{x+\Delta x/2} \left( \int_{\eta-\Delta x/2}^{\eta+\Delta x/2} {\bf h}\left({\bf u}\left(\zeta\right)\right) d\zeta \right) d\eta, \end{equation}" src="form_178.png"/>
</p>
<p> where <img class="formulaInl" alt="$x$" src="form_22.png"/> is the spatial coordinate along the dimension of the interpolation. This function the 2nd order central numerical approximation <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as <img class="formulaInl" alt="$\hat{\bf f}_{j+1/2} \approx {\bf h}_{j+1/2}$" src="form_148.png"/> as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \hat{\bf f}_{j+1/2} = \frac{1}{2}\left( {\bf f}_{j+1} - {\bf f}_j \right). \end{equation}" src="form_179.png"/>
</p>
<p><b>Implementation</b> <b>Notes:</b> + The scalar interpolation method is applied to the vector function in a component-wise manner. + The function computes the interpolant for the entire grid in one call. It loops over all the grid lines along the interpolation direction and carries out the 1D interpolation along these grid lines. + Location of cell-centers and cell interfaces along the spatial dimension of the interpolation is shown in the following figure: </p>
<div align="center">
<img src="chap1_1Ddomain.png" alt="chap1_1Ddomain.png"/>
</div>
 <p><b>Reference:</b> + Liu, Y., Shu, C.-W., Zhang, M., High Order Finite Difference WENO Schemes for Nonlinear Degenerate Parabolic Equations, SIAM J. Sci. Comput., 33 (2), 2011, pp. 939-965, <a href="http://dx.doi.org/10.1137/100791002.">http://dx.doi.org/10.1137/100791002.</a></p>
<p><b>Function</b> <b>arguments:</b> </p>
<p>Argument | Type | Explanation --------- | --------- | --------------------------------------------- fI | double* | Array to hold the computed interpolant at the grid interfaces. This array must have the same layout as the solution, but with <b>no</b> <b>ghost</b> <b>points</b>. Its size should be the same as u in all dimensions, except dir (the dimension along which to interpolate) along which it should be larger by 1 (number of interfaces is 1 more than the number of interior cell centers). fC | double* | Array with the cell-centered values of the flux function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/>. This array must have the same layout and size as the solution, <b>with</b> <b>ghost</b> <b>points</b>. dir | int | Spatial dimension along which to interpolate (eg: 0 for 1D; 0 or 1 for 2D; 0,1 or 2 for 3D) s | void* | Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>: the following variables are needed - <a class="el" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">HyPar::ghosts</a>, <a class="el" href="a00015.html#a484873c74138512e41bc50d17b7d955a">HyPar::ndims</a>, <a class="el" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">HyPar::nvars</a>, <a class="el" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">HyPar::dim_local</a>. m | void* | MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>: this is needed only by compact interpolation method that need to solve a global implicit system across MPI ranks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fI</em>&nbsp;</td><td>Array of interpolated function values at the interfaces </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fC</em>&nbsp;</td><td>Array of cell-centered values of the function <img class="formulaInl" alt="${\bf f}\left({\bf u}\right)$" src="form_145.png"/> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Spatial dimension along which to interpolation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> containing solver-related variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> containing MPI-related variables </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00145_source.html#l00056">56</a> of file <a class="el" href="a00145_source.html">Interp2PrimSecondOrder.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00058"></a>00058                                                                                                 {\bf f}\left({\bf u}\right)\f$ */
<a name="l00059"></a>00059                             <span class="keywordtype">int</span>     dir,  
<a name="l00060"></a>00060                             <span class="keywordtype">void</span>    *s,   
<a name="l00061"></a>00061                             <span class="keywordtype">void</span>    *m    
<a name="l00062"></a>00062                           )
<a name="l00063"></a>00063 {
<a name="l00064"></a>00064   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>         *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*)        s;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066   <span class="keywordtype">int</span> ghosts = solver-&gt;<a class="code" href="a00015.html#aafc992b5fa79d5a4036024615d03bce6">ghosts</a>;
<a name="l00067"></a>00067   <span class="keywordtype">int</span> ndims  = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00068"></a>00068   <span class="keywordtype">int</span> nvars  = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00069"></a>00069   <span class="keywordtype">int</span> *dim   = solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>;
<a name="l00070"></a>00070 
<a name="l00071"></a>00071   <span class="comment">/* create index and bounds for the outer loop, i.e., to loop over all 1D lines along</span>
<a name="l00072"></a>00072 <span class="comment">     dimension &quot;dir&quot;                                                                    */</span>
<a name="l00073"></a>00073   <span class="keywordtype">int</span> indexC[ndims], indexI[ndims], index_outer[ndims], bounds_outer[ndims], bounds_inter[ndims];
<a name="l00074"></a>00074   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_outer,ndims); bounds_outer[dir] =  1;
<a name="l00075"></a>00075   <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(dim,bounds_inter,ndims); bounds_inter[dir] += 1;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   <span class="keywordtype">int</span> done = 0; <a class="code" href="a00034.html#a2b2826031c0cd92495ab351d3e599fc5">_ArraySetValue_</a>(index_outer,ndims,0);
<a name="l00078"></a>00078   <span class="keywordflow">while</span> (!done) {
<a name="l00079"></a>00079     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexC,ndims);
<a name="l00080"></a>00080     <a class="code" href="a00034.html#a89e8330d9e06dd0666c50833628a125c">_ArrayCopy1D_</a>(index_outer,indexI,ndims);
<a name="l00081"></a>00081     <span class="keywordflow">for</span> (indexI[dir] = 0; indexI[dir] &lt; dim[dir]+1; indexI[dir]++) {
<a name="l00082"></a>00082       <span class="keywordtype">int</span> p, qL, qR;
<a name="l00083"></a>00083       <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,bounds_inter,indexI,0,p);
<a name="l00084"></a>00084       indexC[dir] = indexI[dir]-1; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qL);
<a name="l00085"></a>00085       indexC[dir] = indexI[dir]  ; <a class="code" href="a00034.html#afbb862a2fdf5b72b1f9ace42f64b556f">_ArrayIndex1D_</a>(ndims,dim,indexC,ghosts,qR);
<a name="l00086"></a>00086       <span class="keywordtype">int</span> v; <span class="keywordflow">for</span> (v=0; v&lt;nvars; v++) fI[p*nvars+v] = (fC[qR*nvars+v] - fC[qL*nvars+v]);
<a name="l00087"></a>00087     }
<a name="l00088"></a>00088     <a class="code" href="a00034.html#ac5ec1371623f11d03b0f42adaa24acbc">_ArrayIncrementIndex_</a>(ndims,bounds_outer,index_outer,done);
<a name="l00089"></a>00089   }
<a name="l00090"></a>00090   
<a name="l00091"></a>00091   <span class="keywordflow">return</span>(0);
<a name="l00092"></a>00092 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a249ae68fb7394160a7a709220b684acb"></a><!-- doxytag: member="interpolation.h::InterpSetLimiterVar" ref="a249ae68fb7394160a7a709220b684acb" args="(double *, double *, double *, int, void *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int InterpSetLimiterVar </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function to calculate and save the nonlinear interpolation coefficients for a non-linear (solution-dependent) interpolation scheme (eg. <a class="el" href="a00041.html#acfeff1b158131390b7129f4a857b15ff">_FIFTH_ORDER_WENO_</a>, <a class="el" href="a00041.html#a175a82b8ae2b24c0ba51e1b1dd68c0e5">_FIFTH_ORDER_CRWENO_</a>, <a class="el" href="a00041.html#a6d34f5e8aae80a0d2a27ea20368dfef1">_FIFTH_ORDER_HCWENO_</a>, etc). </p>

</div>
</div>
<a class="anchor" id="a22e0ae19117192cae9978a7a741d15a5"></a><!-- doxytag: member="interpolation.h::MUSCLInitialize" ref="a22e0ae19117192cae9978a7a741d15a5" args="(void *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MUSCLInitialize </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the 3rd order MUSCL scheme. The current implementation just needs to initialize the value of the parameter <img class="formulaInl" alt="$\epsilon$" src="form_8.png"/>, which is hard-coded to <img class="formulaInl" alt="$10^{-3}$" src="form_175.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00146_source.html#l00016">16</a> of file <a class="el" href="a00146_source.html">MUSCLInitialize.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00020"></a>00020 {
<a name="l00021"></a>00021   <a class="code" href="a00020.html" title="Structure of variables/parameters needed by the MUSCL scheme.">MUSCLParameters</a>  *muscl   = (<a class="code" href="a00020.html" title="Structure of variables/parameters needed by the MUSCL scheme.">MUSCLParameters</a>*) s;
<a name="l00022"></a>00022   <span class="comment">/* hard coding these parameters for now */</span>
<a name="l00023"></a>00023   <span class="comment">/* modify to read from an input file later */</span>
<a name="l00024"></a>00024   muscl-&gt;<a class="code" href="a00020.html#a974b448c3d0a13d483d36ef15de369b5">eps</a> = 1<a class="code" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">e</a>-3;
<a name="l00025"></a>00025   <span class="keywordflow">return</span>(0);
<a name="l00026"></a>00026 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aecbe557b2ccc254cdbbd312fc91717be"></a><!-- doxytag: member="interpolation.h::WENOInitialize" ref="aecbe557b2ccc254cdbbd312fc91717be" args="(void *, void *, char *, char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WENOInitialize </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>scheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the structure containing variables and parameters for WENO-type schemes</p>
<p>This function initializes the WENO-type methods. + Sets the parameters to default values. + Reads in the parameters from optional input file "weno.inp", if available. + Allocates memory for and initializes the nonlinear weights used by WENO-type schemes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scheme</em>&nbsp;</td><td>Name of scheme </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of interpolation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00150_source.html#l00024">24</a> of file <a class="el" href="a00150_source.html">WENOInitialize.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00030"></a>00030 {
<a name="l00031"></a>00031   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>           *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*) s;
<a name="l00032"></a>00032   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>    *mpi    = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00033"></a>00033   <a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>  *weno   = (<a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>*) solver-&gt;<a class="code" href="a00015.html#a29c46b81ad574e4dfbad5a7211487dcb">interp</a>;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035   <span class="keywordtype">int</span> nvars = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00036"></a>00036   <span class="keywordtype">int</span> ndims = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038   <span class="comment">/* default parameters */</span>
<a name="l00039"></a>00039   weno-&gt;<a class="code" href="a00030.html#af370a2df117483b6f752da8889a89bb0">mapped</a>      = 0;
<a name="l00040"></a>00040   weno-&gt;<a class="code" href="a00030.html#af3c02b1dce05b28870fa1994c40cd1f2">borges</a>      = 0;
<a name="l00041"></a>00041   weno-&gt;<a class="code" href="a00030.html#a8470a9f95ece04985a5031e745042b7e">yc</a>          = 0;
<a name="l00042"></a>00042   weno-&gt;<a class="code" href="a00030.html#a20e793c98bd33aef1cbbafcf3df48a55">no_limiting</a> = 0;
<a name="l00043"></a>00043   weno-&gt;<a class="code" href="a00030.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>         = 1<a class="code" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">e</a>-6;
<a name="l00044"></a>00044   weno-&gt;<a class="code" href="a00030.html#aace2d484b0e3651abd108f04803d316c">p</a>           = 2.0;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046   weno-&gt;<a class="code" href="a00030.html#af77cf650495294f69237f94cc237cba3">rc</a>          = 0.3;
<a name="l00047"></a>00047   weno-&gt;<a class="code" href="a00030.html#adf147b14a64e08756e9e30868e943da8">xi</a>          = 0.001;
<a name="l00048"></a>00048   weno-&gt;<a class="code" href="a00030.html#a2687e4b3cb5da7dbd00e565343f66c6c">tol</a>         = 1<a class="code" href="a00032.html#a35b3e91c83139b35bbacfaa59a58afd1">e</a>-16;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   if (!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) {
<a name="l00051"></a>00051     FILE *in;
<a name="l00052"></a>00052     <span class="keywordtype">int</span> ferr;
<a name="l00053"></a>00053     in = fopen(<span class="stringliteral">&quot;weno.inp&quot;</span>,<span class="stringliteral">&quot;r&quot;</span>);
<a name="l00054"></a>00054     <span class="keywordflow">if</span> (!in) printf(<span class="stringliteral">&quot;Warning: File weno.inp not found. Using default parameters for WENO5/CRWENO5/HCWENO5 scheme.\n&quot;</span>);
<a name="l00055"></a>00055     <span class="keywordflow">else</span> {
<a name="l00056"></a>00056       printf(<span class="stringliteral">&quot;Reading WENO parameters from weno.inp.\n&quot;</span>);
<a name="l00057"></a>00057       <span class="keywordtype">char</span> word[<a class="code" href="a00036.html#a51efea86a4d76d1259893f606b776573">_MAX_STRING_SIZE_</a>];
<a name="l00058"></a>00058       ferr = fscanf(in,<span class="stringliteral">&quot;%s&quot;</span>,word); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(1);
<a name="l00059"></a>00059       <span class="keywordflow">if</span> (!strcmp(word, <span class="stringliteral">&quot;begin&quot;</span>)){
<a name="l00060"></a>00060           <span class="keywordflow">while</span> (strcmp(word, <span class="stringliteral">&quot;end&quot;</span>)){
<a name="l00061"></a>00061               ferr = fscanf(in,<span class="stringliteral">&quot;%s&quot;</span>,word); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(1);
<a name="l00062"></a>00062           <span class="keywordflow">if</span>      (!strcmp(word,<span class="stringliteral">&quot;mapped&quot;</span>     )) { ferr = fscanf(in,<span class="stringliteral">&quot;%d&quot;</span> ,&amp;weno-&gt;<a class="code" href="a00030.html#af370a2df117483b6f752da8889a89bb0">mapped</a>     ); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(1); }
<a name="l00063"></a>00063           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(word,<span class="stringliteral">&quot;borges&quot;</span>     )) { ferr = fscanf(in,<span class="stringliteral">&quot;%d&quot;</span> ,&amp;weno-&gt;<a class="code" href="a00030.html#af3c02b1dce05b28870fa1994c40cd1f2">borges</a>     ); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(1); }
<a name="l00064"></a>00064           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(word,<span class="stringliteral">&quot;yc&quot;</span>         )) { ferr = fscanf(in,<span class="stringliteral">&quot;%d&quot;</span> ,&amp;weno-&gt;<a class="code" href="a00030.html#a8470a9f95ece04985a5031e745042b7e">yc</a>         ); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(1); }
<a name="l00065"></a>00065           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(word,<span class="stringliteral">&quot;no_limiting&quot;</span>)) { ferr = fscanf(in,<span class="stringliteral">&quot;%d&quot;</span> ,&amp;weno-&gt;<a class="code" href="a00030.html#a20e793c98bd33aef1cbbafcf3df48a55">no_limiting</a>); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(1); }
<a name="l00066"></a>00066           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(word,<span class="stringliteral">&quot;epsilon&quot;</span>    )) { ferr = fscanf(in,<span class="stringliteral">&quot;%lf&quot;</span>,&amp;weno-&gt;<a class="code" href="a00030.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>        ); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(1); }
<a name="l00067"></a>00067           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(word,<span class="stringliteral">&quot;p&quot;</span>          )) { ferr = fscanf(in,<span class="stringliteral">&quot;%lf&quot;</span>,&amp;weno-&gt;<a class="code" href="a00030.html#aace2d484b0e3651abd108f04803d316c">p</a>          ); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(1); }
<a name="l00068"></a>00068           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(word,<span class="stringliteral">&quot;rc&quot;</span>         )) { ferr = fscanf(in,<span class="stringliteral">&quot;%lf&quot;</span>,&amp;weno-&gt;<a class="code" href="a00030.html#af77cf650495294f69237f94cc237cba3">rc</a>         ); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(1); }
<a name="l00069"></a>00069           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(word,<span class="stringliteral">&quot;xi&quot;</span>         )) { ferr = fscanf(in,<span class="stringliteral">&quot;%lf&quot;</span>,&amp;weno-&gt;<a class="code" href="a00030.html#adf147b14a64e08756e9e30868e943da8">xi</a>         ); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(1); }
<a name="l00070"></a>00070           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(word,<span class="stringliteral">&quot;tol&quot;</span>        )) { ferr = fscanf(in,<span class="stringliteral">&quot;%lf&quot;</span>,&amp;weno-&gt;<a class="code" href="a00030.html#a2687e4b3cb5da7dbd00e565343f66c6c">tol</a>        ); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(1); }
<a name="l00071"></a>00071           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(word,<span class="stringliteral">&quot;end&quot;</span>)) {
<a name="l00072"></a>00072             <span class="keywordtype">char</span> useless[<a class="code" href="a00036.html#a51efea86a4d76d1259893f606b776573">_MAX_STRING_SIZE_</a>];
<a name="l00073"></a>00073             ferr = fscanf(in,<span class="stringliteral">&quot;%s&quot;</span>,useless); <span class="keywordflow">if</span> (ferr != 1) <span class="keywordflow">return</span>(ferr);
<a name="l00074"></a>00074             printf(<span class="stringliteral">&quot;Warning: keyword %s in file \&quot;weno.inp\&quot; with value %s not &quot;</span>,word,useless);
<a name="l00075"></a>00075             printf(<span class="stringliteral">&quot;recognized or extraneous. Ignoring.\n&quot;</span>);
<a name="l00076"></a>00076           }
<a name="l00077"></a>00077         }
<a name="l00078"></a>00078         } <span class="keywordflow">else</span> {
<a name="l00079"></a>00079           fprintf(stderr,<span class="stringliteral">&quot;Error: Illegal format in file \&quot;weno.inp\&quot;.\n&quot;</span>);
<a name="l00080"></a>00080         <span class="keywordflow">return</span>(1);
<a name="l00081"></a>00081         }
<a name="l00082"></a>00082       fclose(in);
<a name="l00083"></a>00083     }
<a name="l00084"></a>00084   }
<a name="l00085"></a>00085 
<a name="l00086"></a>00086   <span class="keywordtype">int</span>     integer_data[4];
<a name="l00087"></a>00087   <span class="keywordtype">double</span>  real_data[5];
<a name="l00088"></a>00088   <span class="keywordflow">if</span> (!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) {
<a name="l00089"></a>00089     integer_data[0] = weno-&gt;<a class="code" href="a00030.html#af370a2df117483b6f752da8889a89bb0">mapped</a>;
<a name="l00090"></a>00090     integer_data[1] = weno-&gt;<a class="code" href="a00030.html#af3c02b1dce05b28870fa1994c40cd1f2">borges</a>;
<a name="l00091"></a>00091     integer_data[2] = weno-&gt;<a class="code" href="a00030.html#a8470a9f95ece04985a5031e745042b7e">yc</a>;
<a name="l00092"></a>00092     integer_data[3] = weno-&gt;<a class="code" href="a00030.html#a20e793c98bd33aef1cbbafcf3df48a55">no_limiting</a>;
<a name="l00093"></a>00093     real_data[0]    = weno-&gt;<a class="code" href="a00030.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>;
<a name="l00094"></a>00094     real_data[1]    = weno-&gt;<a class="code" href="a00030.html#aace2d484b0e3651abd108f04803d316c">p</a>;
<a name="l00095"></a>00095     real_data[2]    = weno-&gt;<a class="code" href="a00030.html#af77cf650495294f69237f94cc237cba3">rc</a>;
<a name="l00096"></a>00096     real_data[3]    = weno-&gt;<a class="code" href="a00030.html#adf147b14a64e08756e9e30868e943da8">xi</a>;
<a name="l00097"></a>00097     real_data[4]    = weno-&gt;<a class="code" href="a00030.html#a2687e4b3cb5da7dbd00e565343f66c6c">tol</a>;
<a name="l00098"></a>00098   }
<a name="l00099"></a>00099   <a class="code" href="a00045.html#acd7957559b9206224c7da3cab4f22b27">MPIBroadcast_integer</a>(integer_data,4,0,&amp;mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>);
<a name="l00100"></a>00100   <a class="code" href="a00045.html#a45dcb265863a65d862bb16222e7e623c">MPIBroadcast_double</a> (real_data   ,5,0,&amp;mpi-&gt;<a class="code" href="a00019.html#adad7a6f85831f3ac84d854b6c80aef43">world</a>);
<a name="l00101"></a>00101   
<a name="l00102"></a>00102   weno-&gt;<a class="code" href="a00030.html#af370a2df117483b6f752da8889a89bb0">mapped</a>      = integer_data[0];
<a name="l00103"></a>00103   weno-&gt;<a class="code" href="a00030.html#af3c02b1dce05b28870fa1994c40cd1f2">borges</a>      = integer_data[1];
<a name="l00104"></a>00104   weno-&gt;<a class="code" href="a00030.html#a8470a9f95ece04985a5031e745042b7e">yc</a>          = integer_data[2];
<a name="l00105"></a>00105   weno-&gt;<a class="code" href="a00030.html#a20e793c98bd33aef1cbbafcf3df48a55">no_limiting</a> = integer_data[3];
<a name="l00106"></a>00106   weno-&gt;<a class="code" href="a00030.html#a974b448c3d0a13d483d36ef15de369b5">eps</a>         = real_data   [0];
<a name="l00107"></a>00107   weno-&gt;<a class="code" href="a00030.html#aace2d484b0e3651abd108f04803d316c">p</a>           = real_data   [1];
<a name="l00108"></a>00108   weno-&gt;<a class="code" href="a00030.html#af77cf650495294f69237f94cc237cba3">rc</a>          = real_data   [2];
<a name="l00109"></a>00109   weno-&gt;<a class="code" href="a00030.html#adf147b14a64e08756e9e30868e943da8">xi</a>          = real_data   [3];
<a name="l00110"></a>00110   weno-&gt;<a class="code" href="a00030.html#a2687e4b3cb5da7dbd00e565343f66c6c">tol</a>         = real_data   [4];
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   <span class="comment">/* WENO weight calculation is hard-coded for p=2, so return error if p != 2 in</span>
<a name="l00113"></a>00113 <span class="comment">   * user input file, so that there&apos;s no confusion */</span>
<a name="l00114"></a>00114   <span class="keywordflow">if</span> (weno-&gt;<a class="code" href="a00030.html#aace2d484b0e3651abd108f04803d316c">p</a> != 2.0) {
<a name="l00115"></a>00115     <span class="keywordflow">if</span> (!mpi-&gt;<a class="code" href="a00019.html#a6cfd95afd0afebd625b889fb6e58371c">rank</a>) printf(<span class="stringliteral">&quot;Warning from WENOInitialize(): \&quot;p\&quot; parameter is 2.0. Any other value will be ignored!\n&quot;</span>);
<a name="l00116"></a>00116   }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118   weno-&gt;<a class="code" href="a00030.html#ad0c30ee1add42468a6d7c022f2efdf70">offset</a> = (<span class="keywordtype">int</span>*) calloc (ndims,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00119"></a>00119   <span class="keywordtype">int</span> dir,d;
<a name="l00120"></a>00120   <span class="keywordflow">for</span> (dir=0; dir&lt;ndims; dir++) {
<a name="l00121"></a>00121     weno-&gt;<a class="code" href="a00030.html#ad0c30ee1add42468a6d7c022f2efdf70">offset</a>[dir] = 0;
<a name="l00122"></a>00122     <span class="keywordflow">for</span> (d=0; d&lt;dir; d++) {
<a name="l00123"></a>00123       <span class="keywordtype">int</span> size = nvars, i;
<a name="l00124"></a>00124       <span class="keywordflow">for</span> (i=0; i&lt;ndims; i++) 
<a name="l00125"></a>00125         size *= ( i==d ? solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>[i]+1 : solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>[i] );
<a name="l00126"></a>00126       weno-&gt;<a class="code" href="a00030.html#ad0c30ee1add42468a6d7c022f2efdf70">offset</a>[dir] += size;
<a name="l00127"></a>00127     }
<a name="l00128"></a>00128   }
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   <span class="keywordtype">int</span> total_size = 0;
<a name="l00131"></a>00131   <span class="keywordflow">for</span> (d=0; d&lt;ndims; d++) {
<a name="l00132"></a>00132     <span class="keywordtype">int</span> size = nvars, i;
<a name="l00133"></a>00133     <span class="keywordflow">for</span> (i=0; i&lt;ndims; i++) 
<a name="l00134"></a>00134       size *= ( i==d ? solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>[i]+1 : solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>[i] );
<a name="l00135"></a>00135     total_size += size;
<a name="l00136"></a>00136   }
<a name="l00137"></a>00137   weno-&gt;<a class="code" href="a00030.html#a439227feff9d7f55384e8780cfc2eb82">size</a> = total_size;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139   weno-&gt;<a class="code" href="a00030.html#a3ee56e3d8244b3d4582f1396a79f9791">w1</a> = (<span class="keywordtype">double</span>*) calloc (4*total_size,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00140"></a>00140   weno-&gt;<a class="code" href="a00030.html#a31eb3c1fcb3bc85ab4fa156325a1f849">w2</a> = (<span class="keywordtype">double</span>*) calloc (4*total_size,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00141"></a>00141   weno-&gt;<a class="code" href="a00030.html#aabd83eb3f8a7e3bb9f79a4a943bbd508">w3</a> = (<span class="keywordtype">double</span>*) calloc (4*total_size,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00142"></a>00142 
<a name="l00143"></a>00143   <span class="keywordflow">if</span> ((!strcmp(type,<a class="code" href="a00041.html#aa7752b40155314f9f2c063d4d9d8339d">_CHARACTERISTIC_</a>)) &amp;&amp; (nvars &gt; 1)) 
<a name="l00144"></a>00144     solver-&gt;<a class="code" href="a00015.html#afeeb150a9699ade5eccc7589fcae3fe0">SetInterpLimiterVar</a> = <a class="code" href="a00148.html#a6f1f5da1b6e5134bb1deccfad05a506d">WENOFifthOrderCalculateWeightsChar</a>;
<a name="l00145"></a>00145   <span class="keywordflow">else</span> solver-&gt;<a class="code" href="a00015.html#afeeb150a9699ade5eccc7589fcae3fe0">SetInterpLimiterVar</a> = <a class="code" href="a00148.html#a91383df8b8b5f32861e2ecb18dab8ab7">WENOFifthOrderCalculateWeights</a>;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147   <span class="comment">/* initialize WENO weights to their optimal values */</span>
<a name="l00148"></a>00148   for (d=0; d&lt;ndims; d++) <a class="code" href="a00149.html#a9518887c8f6d1554faf274a46afbf2ad">WENOFifthOrderInitializeWeights</a>(d,solver,mpi);
<a name="l00149"></a>00149 
<a name="l00150"></a>00150   <span class="keywordflow">return</span>(0);
<a name="l00151"></a>00151 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a37dd034f5e9eb221bd3fd51cc8d1b0f4"></a><!-- doxytag: member="interpolation.h::WENOCleanup" ref="a37dd034f5e9eb221bd3fd51cc8d1b0f4" args="(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WENOCleanup </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clean up the structure containing variables and parameters for WENO-type schemes</p>
<p>Cleans up all allocations related to the WENO-type methods. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>WENO object of type <a class="el" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00147_source.html#l00014">14</a> of file <a class="el" href="a00147_source.html">WENOCleanup.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00015"></a>00015 {
<a name="l00016"></a>00016   <a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>  *weno   = (<a class="code" href="a00030.html" title="Structure of variables/parameters needed by the WENO-type scheme.">WENOParameters</a>*) s;
<a name="l00017"></a>00017 
<a name="l00018"></a>00018   free(weno-&gt;<a class="code" href="a00030.html#ad0c30ee1add42468a6d7c022f2efdf70">offset</a>);
<a name="l00019"></a>00019   free(weno-&gt;<a class="code" href="a00030.html#a3ee56e3d8244b3d4582f1396a79f9791">w1</a>);
<a name="l00020"></a>00020   free(weno-&gt;<a class="code" href="a00030.html#a31eb3c1fcb3bc85ab4fa156325a1f849">w2</a>);
<a name="l00021"></a>00021   free(weno-&gt;<a class="code" href="a00030.html#aabd83eb3f8a7e3bb9f79a4a943bbd508">w3</a>);
<a name="l00022"></a>00022 
<a name="l00023"></a>00023   <span class="keywordflow">return</span>(0);
<a name="l00024"></a>00024 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af255a582e14c5820cf12f9f95b4e28fd"></a><!-- doxytag: member="interpolation.h::CompactSchemeInitialize" ref="af255a582e14c5820cf12f9f95b4e28fd" args="(void *, void *, char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CompactSchemeInitialize </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the structure containing variables and parameters for compact schemes</p>
<p>This function initializes the compact finite-difference methods: allocates the arrays to store the tridiagonal system. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Solver object of type <a class="el" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>MPI object of type <a class="el" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of interpolation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00128_source.html#l00017">17</a> of file <a class="el" href="a00128_source.html">CompactSchemeInitialize.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00022"></a>00022 {
<a name="l00023"></a>00023   <a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>         *solver = (<a class="code" href="a00015.html" title="Structure containing all solver-specific variables and functions.">HyPar</a>*) s;
<a name="l00024"></a>00024   <a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>  *mpi    = (<a class="code" href="a00019.html" title="Structure of MPI-related variables.">MPIVariables</a>*) m;
<a name="l00025"></a>00025   <a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a> *compact   = (<a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>*) solver-&gt;<a class="code" href="a00015.html#a56318721d534e74a96b440f8542a0232">compact</a>;
<a name="l00026"></a>00026 
<a name="l00027"></a>00027   <span class="keywordtype">int</span> nvars = solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00028"></a>00028   <span class="keywordtype">int</span> ndims = solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>;
<a name="l00029"></a>00029 
<a name="l00030"></a>00030   <span class="keywordtype">int</span> size = 1, d;
<a name="l00031"></a>00031   for (d=0; d&lt;solver-&gt;<a class="code" href="a00015.html#a484873c74138512e41bc50d17b7d955a">ndims</a>; d++) size *= (solver-&gt;<a class="code" href="a00015.html#a38e0371f331cecbe63a77fa03e202afe">dim_local</a>[d]+1);
<a name="l00032"></a>00032   size *= solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00033"></a>00033   <span class="keywordflow">if</span> (!strcmp(solver-&gt;<a class="code" href="a00015.html#a9591ba0fadb863561474e2ba251d2594">interp_type</a>,<a class="code" href="a00041.html#aa7752b40155314f9f2c063d4d9d8339d">_CHARACTERISTIC_</a>)) size *= solver-&gt;<a class="code" href="a00015.html#ae8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035   compact-&gt;<a class="code" href="a00003.html#ac900805a486cbb8489e3c176ed6e0d8e">A</a> = (<span class="keywordtype">double</span>*) calloc (size, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00036"></a>00036   compact-&gt;<a class="code" href="a00003.html#ad36954709307649365515214a02ab06d">B</a> = (<span class="keywordtype">double</span>*) calloc (size, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00037"></a>00037   compact-&gt;<a class="code" href="a00003.html#a0a26ce8d1878aac6ddc87e3f6290e039">C</a> = (<span class="keywordtype">double</span>*) calloc (size, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00038"></a>00038   compact-&gt;<a class="code" href="a00003.html#ac06de847603f5cfaec085f6fe500f3c8">R</a> = (<span class="keywordtype">double</span>*) calloc (size, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00039"></a>00039 
<a name="l00040"></a>00040   compact-&gt;<a class="code" href="a00003.html#aba3b15034da676474db917f9f5533085">sendbuf</a> = (<span class="keywordtype">double</span>*) calloc (size, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00041"></a>00041   compact-&gt;<a class="code" href="a00003.html#afc23e46e08649e112e8d64d780cea5cb">recvbuf</a> = (<span class="keywordtype">double</span>*) calloc (size, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00042"></a>00042 
<a name="l00043"></a>00043   <span class="keywordflow">return</span>(0);
<a name="l00044"></a>00044 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="acfaa225472f09e2ade88945e909d5893"></a><!-- doxytag: member="interpolation.h::CompactSchemeCleanup" ref="acfaa225472f09e2ade88945e909d5893" args="(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CompactSchemeCleanup </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clean up the structure containing variables and parameters for compact schemes</p>
<p>Cleans up all allocations related to the compact finite difference methods. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td><a class="el" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a> object of type <a class="el" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00127_source.html#l00014">14</a> of file <a class="el" href="a00127_source.html">CompactSchemeCleanup.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00015"></a>00015 {
<a name="l00016"></a>00016   <a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a> *compact   = (<a class="code" href="a00003.html" title="Structure of variables/parameters needed by the compact schemes.">CompactScheme</a>*) s;
<a name="l00017"></a>00017 
<a name="l00018"></a>00018   <span class="keywordflow">if</span> (compact-&gt;<a class="code" href="a00003.html#ac900805a486cbb8489e3c176ed6e0d8e">A</a>) free(compact-&gt;<a class="code" href="a00003.html#ac900805a486cbb8489e3c176ed6e0d8e">A</a>);
<a name="l00019"></a>00019   <span class="keywordflow">if</span> (compact-&gt;<a class="code" href="a00003.html#ad36954709307649365515214a02ab06d">B</a>) free(compact-&gt;<a class="code" href="a00003.html#ad36954709307649365515214a02ab06d">B</a>);
<a name="l00020"></a>00020   <span class="keywordflow">if</span> (compact-&gt;<a class="code" href="a00003.html#a0a26ce8d1878aac6ddc87e3f6290e039">C</a>) free(compact-&gt;<a class="code" href="a00003.html#a0a26ce8d1878aac6ddc87e3f6290e039">C</a>);
<a name="l00021"></a>00021   <span class="keywordflow">if</span> (compact-&gt;<a class="code" href="a00003.html#ac06de847603f5cfaec085f6fe500f3c8">R</a>) free(compact-&gt;<a class="code" href="a00003.html#ac06de847603f5cfaec085f6fe500f3c8">R</a>);
<a name="l00022"></a>00022 
<a name="l00023"></a>00023   <span class="keywordflow">if</span> (compact-&gt;<a class="code" href="a00003.html#aba3b15034da676474db917f9f5533085">sendbuf</a>) free(compact-&gt;<a class="code" href="a00003.html#aba3b15034da676474db917f9f5533085">sendbuf</a>);
<a name="l00024"></a>00024   <span class="keywordflow">if</span> (compact-&gt;<a class="code" href="a00003.html#afc23e46e08649e112e8d64d780cea5cb">recvbuf</a>) free(compact-&gt;<a class="code" href="a00003.html#afc23e46e08649e112e8d64d780cea5cb">recvbuf</a>);
<a name="l00025"></a>00025 
<a name="l00026"></a>00026   <span class="keywordflow">return</span>(0);
<a name="l00027"></a>00027 }
</pre></div></p>

</div>
</div>
</div>
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=10897352; 
var sc_invisible=1; 
var sc_security="83042f57"; 
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
target="_blank"><img class="statcounter"
src="//c.statcounter.com/10897352/0/83042f57/1/"
alt="website statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
