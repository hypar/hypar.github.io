<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HyPar: 3D Navier-Stokes Equations - Isotropic Turbulence Decay</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HyPar
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Finite-Difference Hyperbolic-Parabolic PDE Solver on Cartesian Grids</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a02522.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">3D Navier-Stokes Equations - Isotropic Turbulence Decay </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>See <a class="el" href="a02464.html">3D Navier-Stokes Equations - Isotropic Turbulence Decay</a> to familiarize yourself with this case.</p>
<p>Location: <b>hypar/Examples/3D/NavierStokes3D/DNS_IsotropicTurbulenceDecay_CUDA</b> (This directory contains all the input files needed to run this case.)</p>
<p>Governing equations: 3D Navier-Stokes Equations (<a class="el" href="a01067.html" title="3D Navier Stokes equations (compressible flows) ">navierstokes3d.h</a>)</p>
<p>Domain: \(0 \le x,y,z &lt; 2\pi\), "periodic" (<a class="el" href="a00971.html#a65ffa4253dee762c65092abcf04ecdee">_PERIODIC_</a>) boundaries everywhere.</p>
<p>Initial solution: Isotropic turbulent flow - The initial solution is specified in the Fourier space (with an energy distribution similar to that of turbulent flow), and then transformed to the physical space through an inverse transform.</p>
<p>Other parameters:</p><ul>
<li>\(\gamma = 1.4\) (<a class="el" href="a01067.html#a72f9e01745b3a8203067ab84aefc9aea">NavierStokes3D::gamma</a>)</li>
<li>\(Re = \frac {\rho u L } {\mu} = 333.33\) (<a class="el" href="a01067.html#a3b92a4b98cedf64473b3c13dfa7674b4">NavierStokes3D::Re</a>)</li>
<li>\(Pr = 0.72\) (Prandtl number) (<a class="el" href="a01067.html#af0f6e03342b9eb912e25f94ce0249a2c">NavierStokes3D::Pr</a>)</li>
<li>\(M_\infty = 0.3\) (turbulence fluctuation Mach number) (<a class="el" href="a01067.html#aa5f774fe7b4f69be5e085f1988ef2a6d">NavierStokes3D::Minf</a>)</li>
</ul>
<p>Numerical Method:</p><ul>
<li>Spatial discretization (hyperbolic): 5th order CRWENO (<a class="el" href="a00992.html#a33b1e24c12129941b0027a83c543a654" title="5th order CRWENO reconstruction (component-wise) on a uniform grid ">Interp1PrimFifthOrderCRWENO()</a>)</li>
<li>Spatial discretization (parabolic) : 4th order (<a class="el" href="a00983.html#a08c28e6bc4493172df7b7867e1f3d815">FirstDerivativeFourthOrderCentral()</a>) non-conservative 2-stage (<a class="el" href="a01277.html#a153eb91ec9b118a7b8c971facbc8d920">ParabolicFunctionNC2Stage()</a>)</li>
<li>Time integration: RK4 (<a class="el" href="a01112.html#aca6ebec6e6998f0c509bb38fa91f3321">TimeRK()</a>, <a class="el" href="a01118.html#a47de987716954223b3c26bb842b21bf8">_RK_44_</a>)</li>
</ul>
<p>Hardware Details:</p><ul>
<li>GPU: NVIDIA V100 (Volta)</li>
<li>CPU: IBM Power9</li>
<li>Configuration: 16 nodes, 4 GPUs and 4 MPI ranks per node (64 GPUs and 64 MPI ranks).</li>
</ul>
<h2>Input files required: </h2>
<p><b>solver.inp</b> </p><div class="fragment"><div class="line">begin</div><div class="line">  ndims               3</div><div class="line">  nvars               5</div><div class="line">  size                256 256 256</div><div class="line">  iproc               4 4 4</div><div class="line">  ghost               3</div><div class="line">  n_iter              1000</div><div class="line">  restart_iter        0</div><div class="line">  time_scheme         rk</div><div class="line">  time_scheme_type    ssprk3</div><div class="line">  hyp_space_scheme    weno5</div><div class="line">  hyp_interp_type     components</div><div class="line">  par_space_type      nonconservative-2stage</div><div class="line">  par_space_scheme    4</div><div class="line">  dt                  0.005</div><div class="line">  screen_op_iter      50</div><div class="line">  file_op_iter        100</div><div class="line">  ip_file_type        binary</div><div class="line">  input_mode          serial</div><div class="line">  op_file_format      binary</div><div class="line">  op_overwrite        no</div><div class="line">  model               navierstokes3d</div><div class="line">  use_gpu             yes</div><div class="line">  gpu_device_no       0</div><div class="line">end</div></div><!-- fragment --><p><b>boundary.inp</b> </p><div class="fragment"><div class="line">6</div><div class="line">periodic      0     1     0     0      0    6.3     0      6.3</div><div class="line">periodic      0    -1     0     0      0    6.3     0      6.3</div><div class="line">periodic      1     1     0   6.3      0      0     0      6.3</div><div class="line">periodic      1    -1     0   6.3      0      0     0      6.3</div><div class="line">periodic      2     1     0   6.3      0    6.3     0        0</div><div class="line">periodic      2    -1     0   6.3      0    6.3     0        0</div></div><!-- fragment --><p><b>physics.inp</b> </p><div class="fragment"><div class="line">begin</div><div class="line">  gamma     1.4</div><div class="line">  upwinding roe</div><div class="line">  Pr        0.72</div><div class="line">  Minf      0.3</div><div class="line">  Re        333.333333333333333</div><div class="line">end</div></div><!-- fragment --><p><b>weno.inp</b> (optional) </p><div class="fragment"><div class="line">begin</div><div class="line">  mapped        1</div><div class="line">  borges        0</div><div class="line">  yc            0</div><div class="line">  no_limiting   0</div><div class="line">  epsilon       0.000001</div><div class="line">  p             2.0</div><div class="line">  rc            0.3</div><div class="line">  xi            0.001</div><div class="line">end</div></div><!-- fragment --><p>To generate <b>initial.inp</b> (initial solution), compile and run the following code in the run directory. <b>Note:</b> this code requires the <b>FFTW</b> library installed (<a href="http://www.fftw.org/">http://www.fftw.org/</a>). To compile: </p><pre class="fragment">gcc -I/path/to/fftw3.h -L/path/to/libfftw3.a -lfftw3 init.c
</pre><p>(see the FFTW website on ways to install it). </p><div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  This code generates the initial solution for the</span></div><div class="line"><span class="comment">  isotropic turbulence decay problem, using the technique </span></div><div class="line"><span class="comment">  described in the 1981 NASA report by Rogallo.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  It needs the FFTW3 library installed. To compile it, </span></div><div class="line"><span class="comment">  make sure the fftw3.h and libfftw3 are available in</span></div><div class="line"><span class="comment">  the include and linking paths.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fftw3.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> PI = 4 * atan(1.0);</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> <a class="code" href="a01007.html#a840eef18a5986381093ff8c176a2153c">raiseto</a>(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> a) {</div><div class="line">    <span class="keywordflow">return</span> exp(a*log(x));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> magnitude(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b) {</div><div class="line">    <span class="keywordflow">return</span> sqrt(a*a + b*b);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> velocityComponent( <span class="keyword">const</span> <span class="keywordtype">int</span> N,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">int</span> dir,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> kp,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> u0,</div><div class="line">                        <span class="keywordtype">double</span>* <span class="keyword">const</span> uvel )</div><div class="line">{</div><div class="line">    <span class="keywordtype">long</span> N3 = N*N*N;</div><div class="line">    <span class="keywordtype">long</span> i,j,k;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> kk = sqrt(3 * (N/2)*(N/2));</div><div class="line">    <span class="keywordtype">int</span> kkmax = (int) kk;</div><div class="line"></div><div class="line">    fftw_complex *uhat = (fftw_complex*) fftw_malloc(N3 * <span class="keyword">sizeof</span>(fftw_complex));    </div><div class="line">    fftw_complex *u = (fftw_complex*) fftw_malloc(N3 * <span class="keyword">sizeof</span>(fftw_complex));   </div><div class="line"></div><div class="line">    fftw_plan inv_trans_u;</div><div class="line">    inv_trans_u = fftw_plan_dft_3d(N, N, N, uhat, u, 1, FFTW_MEASURE);</div><div class="line"></div><div class="line">  <span class="comment">/* Specifying the velocities in Fourier space */</span></div><div class="line">  <span class="keywordflow">for</span> (i=0; i&lt;N3; i++) uhat[i][0] = uhat[i][1] = 0.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (i = 1; i &lt; N/2; i++){</div><div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; N/2; j++){</div><div class="line">            <span class="keywordflow">for</span> (k = 0; k &lt; N/2; k++){</div><div class="line">                <span class="keywordtype">double</span> kk   = sqrt(i*i + j*j + k*k);</div><div class="line">                <span class="keywordtype">double</span> th1  = 2*PI * ((double)rand())/((<span class="keywordtype">double</span>)RAND_MAX);</div><div class="line">                <span class="keywordtype">double</span> th2  = 2*PI * ((double)rand())/((<span class="keywordtype">double</span>)RAND_MAX);</div><div class="line">                <span class="keywordtype">double</span> phi1 = 2*PI * ((double)rand())/((<span class="keywordtype">double</span>)RAND_MAX);</div><div class="line"></div><div class="line">                <span class="keywordtype">double</span> E = 16.0 * sqrt(2.0/PI) * (u0*u0/kp) * <a class="code" href="a01007.html#a840eef18a5986381093ff8c176a2153c">raiseto</a>(kk/kp, 4.0) </div><div class="line">                        * exp(-2.0*(kk/kp)*(kk/kp));</div><div class="line">                <span class="keywordtype">double</span> alfa_real = sqrt(E/(4*PI*kk*kk))*cos(th1)*cos(phi1);</div><div class="line">                <span class="keywordtype">double</span> alfa_imag = sqrt(E/(4*PI*kk*kk))*sin(th1)*cos(phi1);</div><div class="line">                <span class="keywordtype">double</span> beta_real = sqrt(E/(4*PI*kk*kk))*cos(th2)*sin(phi1);</div><div class="line">                <span class="keywordtype">double</span> beta_imag = sqrt(E/(4*PI*kk*kk))*sin(th2)*sin(phi1);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (dir == 0) {</div><div class="line">                  uhat[k+N*(j+N*i)][0] = (alfa_real*kk*j+beta_real*i*k)/(kk*sqrt(i*i+j*j));</div><div class="line">                  uhat[k+N*(j+N*i)][1] = (alfa_imag*kk*j+beta_imag*i*k)/(kk*sqrt(i*i+j*j));</div><div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dir == 1) {</div><div class="line">                  uhat[k+N*(j+N*i)][0] = (beta_real*j*k-alfa_real*kk*i)/(kk*sqrt(i*i+j*j));</div><div class="line">                  uhat[k+N*(j+N*i)][1] = (beta_imag*j*k-alfa_imag*kk*i)/(kk*sqrt(i*i+j*j));</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">                  uhat[k+N*(j+N*i)][0] = -(beta_real*sqrt(i*i+j*j))/kk;</div><div class="line">                  uhat[k+N*(j+N*i)][1] = -(beta_imag*sqrt(i*i+j*j))/kk;</div><div class="line">        }</div><div class="line"></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; 1; i++){</div><div class="line">        <span class="keywordflow">for</span> (k = 0; k &lt; N/2; k++){</div><div class="line">            <span class="keywordflow">for</span> (j = 1; j &lt; N/2; j++){</div><div class="line">                <span class="keywordtype">double</span> kk   = sqrt(i*i + j*j + k*k);</div><div class="line">                <span class="keywordtype">double</span> th1  = 2*PI * ((double)rand())/((<span class="keywordtype">double</span>)RAND_MAX);</div><div class="line">                <span class="keywordtype">double</span> th2  = 2*PI * ((double)rand())/((<span class="keywordtype">double</span>)RAND_MAX);</div><div class="line">                <span class="keywordtype">double</span> phi1 = 2*PI * ((double)rand())/((<span class="keywordtype">double</span>)RAND_MAX);</div><div class="line"></div><div class="line">                <span class="keywordtype">double</span> E = 16.0 * sqrt(2.0/PI) * (u0*u0/kp) * <a class="code" href="a01007.html#a840eef18a5986381093ff8c176a2153c">raiseto</a>(kk/kp, 4.0) </div><div class="line">                        * exp(-2.0*(kk/kp)*(kk/kp));</div><div class="line">                <span class="keywordtype">double</span> alfa_real = sqrt(E/(4*PI*kk*kk))*cos(th1)*cos(phi1);</div><div class="line">                <span class="keywordtype">double</span> alfa_imag = sqrt(E/(4*PI*kk*kk))*sin(th1)*cos(phi1);</div><div class="line">                <span class="keywordtype">double</span> beta_real = sqrt(E/(4*PI*kk*kk))*cos(th2)*sin(phi1);</div><div class="line">                <span class="keywordtype">double</span> beta_imag = sqrt(E/(4*PI*kk*kk))*sin(th2)*sin(phi1);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (dir == 0) {</div><div class="line">                  uhat[k+N*(j+N*i)][0] = (alfa_real*kk*j+beta_real*i*k)/(kk*sqrt(i*i+j*j));</div><div class="line">                  uhat[k+N*(j+N*i)][1] = (alfa_imag*kk*j+beta_imag*i*k)/(kk*sqrt(i*i+j*j));</div><div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dir == 1) {</div><div class="line">                  uhat[k+N*(j+N*i)][0] = (beta_real*j*k-alfa_real*kk*i)/(kk*sqrt(i*i+j*j));</div><div class="line">                  uhat[k+N*(j+N*i)][1] = (beta_imag*j*k-alfa_imag*kk*i)/(kk*sqrt(i*i+j*j));</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">                  uhat[k+N*(j+N*i)][0] = -(beta_real*sqrt(i*i+j*j))/kk;</div><div class="line">                  uhat[k+N*(j+N*i)][1] = -(beta_imag*sqrt(i*i+j*j))/kk;</div><div class="line">        }</div><div class="line"></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; 1; i++){</div><div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; 1; j++){</div><div class="line">            <span class="keywordflow">for</span> (k = 0; k &lt; N/2; k++){</div><div class="line">                uhat[k+N*(j+N*i)][0] = 0;</div><div class="line">                uhat[k+N*(j+N*i)][1] = 0;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">/* The following is necessary to ensure that the inverse Fourier</span></div><div class="line"><span class="comment">     transform yields a real velocity field with zero imaginary</span></div><div class="line"><span class="comment">     components */</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (i=N/2+1; i&lt;N; i++) {</div><div class="line">    <span class="keywordflow">for</span> (j=N/2+1; j&lt;N; j++) {</div><div class="line">      <span class="keywordflow">for</span> (k=N/2+1; k&lt;N; k++) {</div><div class="line">                uhat[k+N*(j+N*i)][0] =  uhat[(N-k)+N*((N-j)+N*(N-i))][0];</div><div class="line">                uhat[k+N*(j+N*i)][1] = -uhat[(N-k)+N*((N-j)+N*(N-i))][1];</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">for</span> (i=N/2+1; i&lt;N; i++) {</div><div class="line">    <span class="keywordflow">for</span> (j=N/2+1; j&lt;N; j++) {</div><div class="line">      <span class="keywordflow">for</span> (k=0; k&lt;1; k++) {</div><div class="line">                uhat[k+N*(j+N*i)][0] =  uhat[k+N*((N-j)+N*(N-i))][0];</div><div class="line">                uhat[k+N*(j+N*i)][1] = -uhat[k+N*((N-j)+N*(N-i))][1];</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">for</span> (i=N/2+1; i&lt;N; i++) {</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;1; j++) {</div><div class="line">      <span class="keywordflow">for</span> (k=N/2+1; k&lt;N; k++) {</div><div class="line">                uhat[k+N*(j+N*i)][0] =  uhat[(N-k)+N*(j+N*(N-i))][0];</div><div class="line">                uhat[k+N*(j+N*i)][1] = -uhat[(N-k)+N*(j+N*(N-i))][1];</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">for</span> (i=0; i&lt;1; i++) {</div><div class="line">    <span class="keywordflow">for</span> (j=N/2+1; j&lt;N; j++) {</div><div class="line">      <span class="keywordflow">for</span> (k=N/2+1; k&lt;N; k++) {</div><div class="line">                uhat[k+N*(j+N*i)][0] =  uhat[(N-k)+N*((N-j)+N*i)][0];</div><div class="line">                uhat[k+N*(j+N*i)][1] = -uhat[(N-k)+N*((N-j)+N*i)][1];</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">for</span> (i=0; i&lt;1; i++) {</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;1; j++) {</div><div class="line">      <span class="keywordflow">for</span> (k=N/2+1; k&lt;N; k++) {</div><div class="line">                uhat[k+N*(j+N*i)][0] =  uhat[(N-k)+N*(j+N*i)][0];</div><div class="line">                uhat[k+N*(j+N*i)][1] = -uhat[(N-k)+N*(j+N*i)][1];</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">for</span> (i=0; i&lt;1; i++) {</div><div class="line">    <span class="keywordflow">for</span> (j=N/2+1; j&lt;N; j++) {</div><div class="line">      <span class="keywordflow">for</span> (k=0; k&lt;1; k++) {</div><div class="line">                uhat[k+N*(j+N*i)][0] =  uhat[k+N*((N-j)+N*i)][0];</div><div class="line">                uhat[k+N*(j+N*i)][1] = -uhat[k+N*((N-j)+N*i)][1];</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">for</span> (i=N/2+1; i&lt;N; i++) {</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;1; j++) {</div><div class="line">      <span class="keywordflow">for</span> (k=0; k&lt;1; k++) {</div><div class="line">                uhat[k+N*(j+N*i)][0] =  uhat[k+N*(j+N*(N-i))][0];</div><div class="line">                uhat[k+N*(j+N*i)][1] = -uhat[k+N*(j+N*(N-i))][1];</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">/* Inverse Fourier transform */</span></div><div class="line">    fftw_execute(inv_trans_u);</div><div class="line">    fftw_free(uhat);</div><div class="line">    fftw_destroy_plan(inv_trans_u);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> imag_velocity = 0;</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; N3; i++){</div><div class="line">        <span class="keywordtype">double</span> uu = u[i][1];</div><div class="line">        imag_velocity += (uu*uu);</div><div class="line">    }</div><div class="line">    imag_velocity = sqrt(imag_velocity / ((<span class="keywordtype">double</span>)N3));</div><div class="line">    printf(<span class="stringliteral">&quot;RMS of imaginary component of computed velocity: %1.6e\n&quot;</span>,imag_velocity);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; N3; i++){</div><div class="line">    uvel[i] = u[i][0];</div><div class="line">    }</div><div class="line"></div><div class="line">  fftw_free(u);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setVelocityField(<span class="keyword">const</span> <span class="keywordtype">int</span> N,</div><div class="line">                      <span class="keywordtype">double</span>* <span class="keyword">const</span> uvel,</div><div class="line">                      <span class="keywordtype">double</span>* <span class="keyword">const</span> vvel,</div><div class="line">                      <span class="keywordtype">double</span>* <span class="keyword">const</span> wvel )</div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> kp = 4.0;</div><div class="line">    <span class="keywordtype">double</span> u0 = 0.3;</div><div class="line"></div><div class="line">    <span class="keywordtype">long</span> N3 = N*N*N;</div><div class="line">    <span class="keywordtype">long</span> i,j,k;</div><div class="line">    <span class="keywordtype">double</span> dx = 2*PI / ((double)N);</div><div class="line"></div><div class="line">  velocityComponent( N, 0, kp, u0, uvel ); </div><div class="line">  velocityComponent( N, 1, kp, u0, vvel ); </div><div class="line">  velocityComponent( N, 2, kp, u0, wvel ); </div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> rms_velocity = 0;</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; N3; i++){</div><div class="line">    <span class="keywordtype">double</span> uu, vv, ww;</div><div class="line">        uu = uvel[i];</div><div class="line">        vv = vvel[i];</div><div class="line">        ww = wvel[i];</div><div class="line">        rms_velocity += (uu*uu + vv*vv + ww*ww);</div><div class="line">    }</div><div class="line">    rms_velocity = sqrt(rms_velocity / (3*((<span class="keywordtype">double</span>)N3)));</div><div class="line">  </div><div class="line">  <span class="comment">/* scale the velocity components so that rms velocity matches u0 */</span></div><div class="line">  <span class="keywordtype">double</span> factor = u0 / rms_velocity;</div><div class="line">  printf(<span class="stringliteral">&quot;Scaling factor = %1.16E\n&quot;</span>,factor);</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; N3; i++){</div><div class="line">        uvel[i] *= factor;</div><div class="line">        vvel[i] *= factor;</div><div class="line">        wvel[i] *= factor;</div><div class="line">    }</div><div class="line"></div><div class="line">    rms_velocity = 0;</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; N3; i++){</div><div class="line">    <span class="keywordtype">double</span> uu, vv, ww;</div><div class="line">        uu = uvel[i];</div><div class="line">        vv = vvel[i];</div><div class="line">        ww = wvel[i];</div><div class="line">        rms_velocity += (uu*uu + vv*vv + ww*ww);</div><div class="line">    }</div><div class="line">    rms_velocity = sqrt(rms_velocity / (3*((<span class="keywordtype">double</span>)N3)));</div><div class="line">    printf(<span class="stringliteral">&quot;RMS velocity (component-wise): %1.16E\n&quot;</span>,rms_velocity);</div><div class="line"></div><div class="line">  <span class="comment">/* calculate the divergence of velocity */</span></div><div class="line">  <span class="keywordtype">double</span> DivergenceNorm = 0;</div><div class="line">  <span class="keywordflow">for</span> (i=0; i&lt;N; i++) {</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++) {</div><div class="line">      <span class="keywordflow">for</span> (k=0; k&lt;N; k++) {</div><div class="line">        <span class="keywordtype">double</span> u1, u2, v1, v2, w1, w2;</div><div class="line">        u1 = (i==0   ? uvel[k+N*(j+N*(N-1))] : uvel[k+N*(j+N*(i-1))] );</div><div class="line">        u2 = (i==N-1 ? uvel[k+N*(j+N*(0  ))] : uvel[k+N*(j+N*(i+1))] );</div><div class="line">        v1 = (j==0   ? vvel[k+N*((N-1)+N*i)] : vvel[k+N*((j-1)+N*i)] );</div><div class="line">        v2 = (j==N-1 ? vvel[k+N*((0  )+N*i)] : vvel[k+N*((j+1)+N*i)] );</div><div class="line">        w1 = (k==0   ? wvel[(N-1)+N*(j+N*i)] : wvel[(k-1)+N*(j+N*i)] );</div><div class="line">        w2 = (k==N-1 ? wvel[(0  )+N*(j+N*i)] : wvel[(k+1)+N*(j+N*i)] );</div><div class="line">        <span class="keywordtype">double</span> Divergence = ( (u2-u1) + (v2-v1) + (w2-w1) ) / (2.0*dx);</div><div class="line">        DivergenceNorm += (Divergence*Divergence);</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">  DivergenceNorm = sqrt(DivergenceNorm / ((<span class="keywordtype">double</span>)N3));</div><div class="line">  printf(<span class="stringliteral">&quot;Velocity divergence: %1.16E\n&quot;</span>,DivergenceNorm);</div><div class="line"></div><div class="line">  <span class="comment">/* calculate the Taylor microscales */</span></div><div class="line">  <span class="keywordtype">double</span> TaylorMicroscale[3];</div><div class="line">  <span class="keywordtype">double</span> Numerator[3] = {0,0,0};</div><div class="line">  <span class="keywordtype">double</span> Denominator[3] = {0,0,0};</div><div class="line">  <span class="keywordflow">for</span> (i=0; i&lt;N; i++) {</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++) {</div><div class="line">      <span class="keywordflow">for</span> (k=0; k&lt;N; k++) {</div><div class="line">        <span class="keywordtype">double</span> u1, u2, uu, v1, v2, vv, w1, w2, ww;</div><div class="line">        u1 = (i==0   ? uvel[k+N*(j+N*(N-1))] : uvel[k+N*(j+N*(i-1))] );</div><div class="line">        u2 = (i==N-1 ? uvel[k+N*(j+N*(0  ))] : uvel[k+N*(j+N*(i+1))] );</div><div class="line">        v1 = (j==0   ? vvel[k+N*((N-1)+N*i)] : vvel[k+N*((j-1)+N*i)] );</div><div class="line">        v2 = (j==N-1 ? vvel[k+N*((0  )+N*i)] : vvel[k+N*((j+1)+N*i)] );</div><div class="line">        w1 = (k==0   ? wvel[(N-1)+N*(j+N*i)] : wvel[(k-1)+N*(j+N*i)] );</div><div class="line">        w2 = (k==N-1 ? wvel[(0  )+N*(j+N*i)] : wvel[(k+1)+N*(j+N*i)] );</div><div class="line">        uu  = uvel[k+N*(j+N*i)];</div><div class="line">        vv  = vvel[k+N*(j+N*i)];</div><div class="line">        ww  = wvel[k+N*(j+N*i)];</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> du, dv, dw;</div><div class="line">        du = (u2 - u1) / (2.0*dx);</div><div class="line">        dv = (v2 - v1) / (2.0*dx);</div><div class="line">        dw = (w2 - w1) / (2.0*dx);</div><div class="line"></div><div class="line">        Numerator[0] += (uu*uu);</div><div class="line">        Numerator[1] += (vv*vv);</div><div class="line">        Numerator[2] += (ww*ww);</div><div class="line"></div><div class="line">        Denominator[0] += (du*du);</div><div class="line">        Denominator[1] += (dv*dv);</div><div class="line">        Denominator[2] += (dw*dw);</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">  Numerator[0] /= (N*N*N); Denominator[0] /= (N*N*N);</div><div class="line">  Numerator[1] /= (N*N*N); Denominator[1] /= (N*N*N);</div><div class="line">  Numerator[2] /= (N*N*N); Denominator[2] /= (N*N*N);</div><div class="line"></div><div class="line">  TaylorMicroscale[0] = sqrt(Numerator[0]/Denominator[0]);</div><div class="line">  TaylorMicroscale[1] = sqrt(Numerator[1]/Denominator[1]);</div><div class="line">  TaylorMicroscale[2] = sqrt(Numerator[2]/Denominator[2]);</div><div class="line"></div><div class="line">  printf(<span class="stringliteral">&quot;Taylor microscales: %1.16E, %1.16E, %1.16E\n&quot;</span>,</div><div class="line">         TaylorMicroscale[0],TaylorMicroscale[1],TaylorMicroscale[2]);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="a01451.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>()</div><div class="line">{</div><div class="line">    FILE *out, *in;</div><div class="line">    <span class="keywordtype">int</span> NI,NJ,NK,ndims;</div><div class="line">  <span class="keywordtype">char</span> ip_file_type[50];</div><div class="line">  strcpy(ip_file_type,<span class="stringliteral">&quot;ascii&quot;</span>);</div><div class="line"></div><div class="line">  printf(<span class="stringliteral">&quot;Reading file \&quot;solver.inp\&quot;...\n&quot;</span>);</div><div class="line">  in = fopen(<span class="stringliteral">&quot;solver.inp&quot;</span>,<span class="stringliteral">&quot;r&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (!in) printf(<span class="stringliteral">&quot;Error: Input file \&quot;solver.inp\&quot; not found. Default values will be used.\n&quot;</span>);</div><div class="line">  <span class="keywordflow">else</span> {</div><div class="line">    <span class="keywordtype">char</span> word[500];</div><div class="line">    fscanf(in,<span class="stringliteral">&quot;%s&quot;</span>,word);</div><div class="line">    <span class="keywordflow">if</span> (!strcmp(word, <span class="stringliteral">&quot;begin&quot;</span>)){</div><div class="line">      <span class="keywordflow">while</span> (strcmp(word, <span class="stringliteral">&quot;end&quot;</span>)){</div><div class="line">        fscanf(in,<span class="stringliteral">&quot;%s&quot;</span>,word);</div><div class="line">        <span class="keywordflow">if</span> (!strcmp(word, <span class="stringliteral">&quot;ndims&quot;</span>)) fscanf(in,<span class="stringliteral">&quot;%d&quot;</span>,&amp;ndims);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(word, <span class="stringliteral">&quot;size&quot;</span>)) {</div><div class="line">          fscanf(in,<span class="stringliteral">&quot;%d&quot;</span>,&amp;NI);</div><div class="line">          fscanf(in,<span class="stringliteral">&quot;%d&quot;</span>,&amp;NJ);</div><div class="line">          fscanf(in,<span class="stringliteral">&quot;%d&quot;</span>,&amp;NK);</div><div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(word, <span class="stringliteral">&quot;ip_file_type&quot;</span>)) fscanf(in,<span class="stringliteral">&quot;%s&quot;</span>,ip_file_type);</div><div class="line">      }</div><div class="line">    } <span class="keywordflow">else</span> printf(<span class="stringliteral">&quot;Error: Illegal format in solver.inp. Crash and burn!\n&quot;</span>);</div><div class="line">  }</div><div class="line">  fclose(in);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (ndims != 3) {</div><div class="line">    printf(<span class="stringliteral">&quot;ndims is not 3 in solver.inp. this code is to generate 3D exact conditions\n&quot;</span>);</div><div class="line">    <span class="keywordflow">return</span>(0);</div><div class="line">  }</div><div class="line"></div><div class="line">    printf(<span class="stringliteral">&quot;Grid:\t\t\t%d x %d x %d\n&quot;</span>,NI,NJ,NK);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ((NI != NJ) || (NI != NK) || (NJ != NK)) { </div><div class="line">    printf(<span class="stringliteral">&quot;Error: NI,NJ,NK not equal. Bye!\n&quot;</span>); </div><div class="line">    <span class="keywordflow">return</span>(0); </div><div class="line">  }</div><div class="line">    <span class="keywordtype">int</span> N = NI;</div><div class="line">  <span class="keywordtype">long</span> N3 = N*N*N;</div><div class="line">    <span class="keywordtype">int</span> i,j,k;</div><div class="line">    <span class="keywordtype">double</span> dx = 2*PI / ((double)N);</div><div class="line"></div><div class="line">  <span class="comment">/* Calculating the velocity components through a Fourier transform */</span></div><div class="line">  <span class="keywordtype">double</span>* u = (<span class="keywordtype">double</span>*) calloc (N3, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line">  <span class="keywordtype">double</span>* v = (<span class="keywordtype">double</span>*) calloc (N3, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line">  <span class="keywordtype">double</span>* w = (<span class="keywordtype">double</span>*) calloc (N3, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line">  setVelocityField(N, u, v, w);</div><div class="line"></div><div class="line">  <span class="comment">/* grid and solution in conserved variable form */</span></div><div class="line">  <span class="keywordtype">double</span> *x,*y,*z,*U;</div><div class="line">    x    = (<span class="keywordtype">double</span>*) calloc (N, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line">    y    = (<span class="keywordtype">double</span>*) calloc (N, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line">    z    = (<span class="keywordtype">double</span>*) calloc (N, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line">    U  = (<span class="keywordtype">double</span>*) calloc (5*N3, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; N; i++){</div><div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; N; j++){</div><div class="line">      <span class="keywordflow">for</span> (k = 0; k &lt; N; k++){</div><div class="line">          x[i] = i*dx;</div><div class="line">          y[j] = j*dx;</div><div class="line">          z[k] = k*dx;</div><div class="line">        <span class="keywordtype">double</span> RHO, uvel, vvel, wvel, P;</div><div class="line">        RHO = 1.0;</div><div class="line">                uvel = u[k+N*(j+N*i)];</div><div class="line">                vvel = v[k+N*(j+N*i)];</div><div class="line">                wvel = w[k+N*(j+N*i)];</div><div class="line">        P   = 1.0/1.4;</div><div class="line">        <span class="keywordtype">long</span> p = i + N*j + N*N*k;</div><div class="line">        U[5*p+0] = RHO;</div><div class="line">        U[5*p+1] = RHO*uvel;</div><div class="line">        U[5*p+2] = RHO*vvel;</div><div class="line">        U[5*p+3] = RHO*wvel;</div><div class="line">        U[5*p+4] = P/0.4 + 0.5 * RHO * (uvel*uvel + vvel*vvel + wvel*wvel);</div><div class="line">      }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    free(u);</div><div class="line">    free(v);</div><div class="line">    free(w);</div><div class="line"></div><div class="line">  FILE *op;</div><div class="line">  <span class="keywordflow">if</span> (!strcmp(ip_file_type,<span class="stringliteral">&quot;ascii&quot;</span>)) {</div><div class="line"></div><div class="line">    printf(<span class="stringliteral">&quot;Writing ASCII initial solution file initial.inp\n&quot;</span>);</div><div class="line">    op = fopen(<span class="stringliteral">&quot;initial.inp&quot;</span>,<span class="stringliteral">&quot;w&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; N; i++)  fprintf(op,<span class="stringliteral">&quot;%1.16E &quot;</span>,x[i]);</div><div class="line">    fprintf(op,<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span> (j = 0; j &lt; N; j++)  fprintf(op,<span class="stringliteral">&quot;%1.16E &quot;</span>,y[j]);</div><div class="line">    fprintf(op,<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span> (k = 0; k &lt; N; k++)  fprintf(op,<span class="stringliteral">&quot;%1.16E &quot;</span>,z[k]);</div><div class="line">    fprintf(op,<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">      <span class="keywordflow">for</span> (i = 0; i &lt; N; i++) {</div><div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; N; j++) {</div><div class="line">          <span class="keywordflow">for</span> (k = 0; k &lt; N; k++) {</div><div class="line">          <span class="keywordtype">int</span> p = i + N*j + N*N*k;</div><div class="line">          fprintf(op,<span class="stringliteral">&quot;%1.16E &quot;</span>,U[5*p+0]);</div><div class="line">        }</div><div class="line">      }</div><div class="line">    }</div><div class="line">    fprintf(op,<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; N; i++) {</div><div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; N; j++) {</div><div class="line">          <span class="keywordflow">for</span> (k = 0; k &lt; N; k++) {</div><div class="line">          <span class="keywordtype">int</span> p = i + N*j + N*N*k;</div><div class="line">          fprintf(op,<span class="stringliteral">&quot;%1.16E &quot;</span>,U[5*p+1]);</div><div class="line">        }</div><div class="line">      }</div><div class="line">    }</div><div class="line">    fprintf(op,<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; N; i++) {</div><div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; N; j++) {</div><div class="line">          <span class="keywordflow">for</span> (k = 0; k &lt; N; k++) {</div><div class="line">          <span class="keywordtype">int</span> p = i + N*j + N*N*k;</div><div class="line">          fprintf(op,<span class="stringliteral">&quot;%1.16E &quot;</span>,U[5*p+2]);</div><div class="line">        }</div><div class="line">      }</div><div class="line">    }</div><div class="line">    fprintf(op,<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">      <span class="keywordflow">for</span> (i = 0; i &lt; N; i++) {</div><div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; N; j++) {</div><div class="line">          <span class="keywordflow">for</span> (k = 0; k &lt; N; k++) {</div><div class="line">          <span class="keywordtype">int</span> p = i + N*j + N*N*k;</div><div class="line">          fprintf(op,<span class="stringliteral">&quot;%1.16E &quot;</span>,U[5*p+3]);</div><div class="line">        }</div><div class="line">      }</div><div class="line">    }</div><div class="line">    fprintf(op,<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; N; i++) {</div><div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; N; j++) {</div><div class="line">          <span class="keywordflow">for</span> (k = 0; k &lt; N; k++) {</div><div class="line">          <span class="keywordtype">int</span> p = i + N*j + N*N*k;</div><div class="line">          fprintf(op,<span class="stringliteral">&quot;%1.16E &quot;</span>,U[5*p+4]);</div><div class="line">        }</div><div class="line">      }</div><div class="line">    }</div><div class="line">    fprintf(op,<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">      fclose(op);</div><div class="line"></div><div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((!strcmp(ip_file_type,<span class="stringliteral">&quot;binary&quot;</span>)) || (!strcmp(ip_file_type,<span class="stringliteral">&quot;bin&quot;</span>))) {</div><div class="line"></div><div class="line">    printf(<span class="stringliteral">&quot;Writing binary initial solution file initial.inp\n&quot;</span>);</div><div class="line">    op = fopen(<span class="stringliteral">&quot;initial.inp&quot;</span>,<span class="stringliteral">&quot;wb&quot;</span>);</div><div class="line">    fwrite(x,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),N,op);</div><div class="line">    fwrite(y,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),N,op);</div><div class="line">    fwrite(z,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),N,op);</div><div class="line">    fwrite(U,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),5*N3,op);</div><div class="line">    fclose(op);</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line">    free(x);</div><div class="line">    free(y);</div><div class="line">    free(z);</div><div class="line">  free(U);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span>(0);</div><div class="line">}</div></div><!-- fragment --><h2>Output: </h2>
<p>Note that <b>iproc</b> is set to </p><pre class="fragment">  4 4 4
</pre><p>in <b>solver.inp</b> (i.e., 4 processors along <em>x</em>, 4 processors along <em>y</em>, and 4 processor along <em>z</em>). Thus, this example should be run with 64 MPI ranks (or change <b>iproc</b>) and 64 GPUs.</p>
<p>After running the code, there should be 11 output files <b>op_00000.bin</b>, <b>op_00001.bin</b>, ... <b>op_00010.bin</b>; the first one is the solution at \(t=0\) and the final one is the solution at \(t=5\).</p>
<p>See <a class="el" href="a02464.html">3D Navier-Stokes Equations - Isotropic Turbulence Decay</a> for detailed postprocessing instructions. The following figure shows the initial and final (t=5) energy spectra: </p><div class="image">
<img src="Solution_3DNavStok_IsoTurb_CUDA_Spectrum.png" alt="Solution_3DNavStok_IsoTurb_CUDA_Spectrum.png"/>
</div>
<p>The following figures show the density and internal energy contours on the X-Y plane mid-slice at the final time: </p><div class="image">
<img src="Solution_3DNavStok_IsoTurb_CUDA_density.png" alt="Solution_3DNavStok_IsoTurb_CUDA_density.png"/>
</div>
 <div class="image">
<img src="Solution_3DNavStok_IsoTurb_CUDA_energy.png" alt="Solution_3DNavStok_IsoTurb_CUDA_energy.png"/>
</div>
<p>Expected screen output: </p><div class="fragment"><div class="line">HyPar - Parallel (MPI) version with 64 processes</div><div class="line">Allocated simulation object(s).</div><div class="line">Reading solver inputs from file &quot;solver.inp&quot;.</div><div class="line">  No. of dimensions                          : 3</div><div class="line">  No. of variables                           : 5</div><div class="line">  Domain size                                : 256 256 256 </div><div class="line">  Processes along each dimension             : 4 4 4 </div><div class="line">  Exact solution domain size                 : 256 256 256 </div><div class="line">  No. of ghosts pts                          : 3</div><div class="line">  No. of iter.                               : 1000</div><div class="line">  Restart iteration                          : 0</div><div class="line">  Time integration scheme                    : rk (ssprk3)</div><div class="line">  Spatial discretization scheme (hyperbolic) : weno5</div><div class="line">  Split hyperbolic flux term?                : no</div><div class="line">  Interpolation type for hyperbolic term     : components</div><div class="line">  Spatial discretization type   (parabolic ) : nonconservative-2stage</div><div class="line">  Spatial discretization scheme (parabolic ) : 4</div><div class="line">  Time Step                                  : 5.000000E-03</div><div class="line">  Check for conservation                     : no</div><div class="line">  Screen output iterations                   : 50</div><div class="line">  File output iterations                     : 100</div><div class="line">  Initial solution file type                 : binary</div><div class="line">  Initial solution read mode                 : serial</div><div class="line">  Solution file write mode                   : serial</div><div class="line">  Solution file format                       : binary</div><div class="line">  Overwrite solution file                    : no</div><div class="line">  Use GPU                                    : yes</div><div class="line">  GPU device no                              : 0</div><div class="line">  Physical model                             : navierstokes3d</div><div class="line">Partitioning domain and allocating data arrays.</div><div class="line">Reading array from binary file initial.inp (Serial mode).</div><div class="line">Volume integral of the initial solution:</div><div class="line"> 0:  2.4805021344162057E+02</div><div class="line"> 1:  3.6748382115092681E-14</div><div class="line"> 2:  5.6732396558345499E-14</div><div class="line"> 3:  3.9412917374193057E-14</div><div class="line"> 4:  4.7643358853329369E+02</div><div class="line">Reading boundary conditions from boundary.inp.</div><div class="line">  Boundary                       periodic:  Along dimension  0 and face +1</div><div class="line">  Boundary                       periodic:  Along dimension  0 and face -1</div><div class="line">  Boundary                       periodic:  Along dimension  1 and face +1</div><div class="line">  Boundary                       periodic:  Along dimension  1 and face -1</div><div class="line">  Boundary                       periodic:  Along dimension  2 and face +1</div><div class="line">  Boundary                       periodic:  Along dimension  2 and face -1</div><div class="line">6 boundary condition(s) read.</div><div class="line">Initializing solvers.</div><div class="line">Reading WENO parameters from weno.inp.</div><div class="line">Initializing physics. Model = &quot;navierstokes3d&quot;</div><div class="line">Reading physical model inputs from file &quot;physics.inp&quot;.</div><div class="line">Setting up time integration.</div><div class="line">Solving in time (from 0 to 1000 iterations)</div><div class="line">Writing solution file op_00000.bin.</div><div class="line">iter=     50  t=2.500E-01  wctime: 8.3E-02 (s)  </div><div class="line">iter=    100  t=5.000E-01  wctime: 8.2E-02 (s)  </div><div class="line">Writing solution file op_00001.bin.</div><div class="line">iter=    150  t=7.500E-01  wctime: 8.2E-02 (s)  </div><div class="line">iter=    200  t=1.000E+00  wctime: 8.3E-02 (s)  </div><div class="line">Writing solution file op_00002.bin.</div><div class="line">iter=    250  t=1.250E+00  wctime: 8.3E-02 (s)  </div><div class="line">iter=    300  t=1.500E+00  wctime: 8.3E-02 (s)  </div><div class="line">Writing solution file op_00003.bin.</div><div class="line">iter=    350  t=1.750E+00  wctime: 8.2E-02 (s)  </div><div class="line">iter=    400  t=2.000E+00  wctime: 8.2E-02 (s)  </div><div class="line">Writing solution file op_00004.bin.</div><div class="line">iter=    450  t=2.250E+00  wctime: 8.2E-02 (s)  </div><div class="line">iter=    500  t=2.500E+00  wctime: 8.2E-02 (s)  </div><div class="line">Writing solution file op_00005.bin.</div><div class="line">iter=    550  t=2.750E+00  wctime: 8.3E-02 (s)  </div><div class="line">iter=    600  t=3.000E+00  wctime: 8.2E-02 (s)  </div><div class="line">Writing solution file op_00006.bin.</div><div class="line">iter=    650  t=3.250E+00  wctime: 8.2E-02 (s)  </div><div class="line">iter=    700  t=3.500E+00  wctime: 8.3E-02 (s)  </div><div class="line">Writing solution file op_00007.bin.</div><div class="line">iter=    750  t=3.750E+00  wctime: 8.3E-02 (s)  </div><div class="line">iter=    800  t=4.000E+00  wctime: 8.3E-02 (s)  </div><div class="line">Writing solution file op_00008.bin.</div><div class="line">iter=    850  t=4.250E+00  wctime: 8.2E-02 (s)  </div><div class="line">iter=    900  t=4.500E+00  wctime: 8.2E-02 (s)  </div><div class="line">Writing solution file op_00009.bin.</div><div class="line">iter=    950  t=4.750E+00  wctime: 8.3E-02 (s)  </div><div class="line">iter=   1000  t=5.000E+00  wctime: 8.2E-02 (s)  </div><div class="line">Completed time integration (Final time: 5.000000), total wctime: 82.421372 (seconds).</div><div class="line">Writing solution file op_00010.bin.</div><div class="line">Solver runtime (in seconds): 9.5411868999999996E+01</div><div class="line">Total  runtime (in seconds): 1.0222746800000000E+02</div><div class="line">Deallocating arrays.</div><div class="line">Finished.</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=10897352; 
var sc_invisible=1; 
var sc_security="83042f57"; 
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
target="_blank"><img class="statcounter"
src="//c.statcounter.com/10897352/0/83042f57/1/"
alt="website statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
